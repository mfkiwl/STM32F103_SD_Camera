; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\usart.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\usart.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\HARDWARE\LED -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\STM32F10x_FWLib\inc -I..\CORE -I..\HARDWARE\SPI -I..\HARDWARE\MMC_SD -I..\HARDWARE\SPI -I..\HARDWARE\LED -I..\HARDWARE\WNOTEPAD -I..\HARDWARE\RTC -I..\FATFS -I..\FATFS\option -I..\HARDWARE\USART3 -I..\APPS -I..\HARDWARE\OV2640 -I..\HARDWARE\24LC1024 -I..\HARDWARE\RAM -I.\RTE\_Target_1 -ID:\EmbeddedTools\MDK51_RAM\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\EmbeddedTools\MDK51_RAM\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\usart.crf ..\SYSTEM\usart\usart.c]
                          THUMB

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;99     
;;;100    void USART1_IRQHandler(void)                	//串口1中断服务程序
000000  b570              PUSH     {r4-r6,lr}
;;;101    {
;;;102    	u8 Res;
;;;103    	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
000002  4c15              LDR      r4,|L1.88|
000004  f2405125          MOV      r1,#0x525
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USART_GetITStatus
00000e  2800              CMP      r0,#0
000010  d00e              BEQ      |L1.48|
;;;104    	{
;;;105    		Res =USART_ReceiveData(USART1);//(USART1->DR);	//读取接收到的数据
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       USART_ReceiveData
;;;106    		
;;;107    		if((USART_RX_STA&0x80)==0)//接收未完成
000018  4a10              LDR      r2,|L1.92|
00001a  b2c1              UXTB     r1,r0                 ;105
00001c  7810              LDRB     r0,[r2,#0]  ; USART_RX_STA
00001e  0603              LSLS     r3,r0,#24
000020  d406              BMI      |L1.48|
;;;108    			{
;;;109    			if(USART_RX_STA&0x40)//接收到了0x0d
000022  0644              LSLS     r4,r0,#25
000024  f04f0300          MOV      r3,#0
000028  d506              BPL      |L1.56|
;;;110    				{
;;;111    				if(Res!=0x0a)USART_RX_STA=0;//接收错误,重新开始
00002a  290a              CMP      r1,#0xa
00002c  d001              BEQ      |L1.50|
                  |L1.46|
00002e  7013              STRB     r3,[r2,#0]
                  |L1.48|
;;;112    				else USART_RX_STA|=0x80;	//接收完成了 
;;;113    				}
;;;114    			else //还没收到0X0D
;;;115    				{	
;;;116    				if(Res==0x0d)USART_RX_STA|=0x40;
;;;117    				else
;;;118    					{
;;;119    					USART_RX_BUF[USART_RX_STA&0X3F]=Res ;
;;;120    					USART_RX_STA++;
;;;121    					if(USART_RX_STA>63)USART_RX_STA=0;//接收数据错误,重新开始接收	  
;;;122    					}		 
;;;123    				}
;;;124    			}   		 
;;;125         } 
;;;126    } 
000030  bd70              POP      {r4-r6,pc}
                  |L1.50|
000032  f0400080          ORR      r0,r0,#0x80           ;112
000036  e00d              B        |L1.84|
                  |L1.56|
000038  290d              CMP      r1,#0xd               ;116
00003a  d009              BEQ      |L1.80|
00003c  f000043f          AND      r4,r0,#0x3f           ;119
000040  4d07              LDR      r5,|L1.96|
000042  1c40              ADDS     r0,r0,#1              ;119
000044  b2c0              UXTB     r0,r0                 ;120
000046  5529              STRB     r1,[r5,r4]            ;119
000048  7010              STRB     r0,[r2,#0]            ;120
00004a  283f              CMP      r0,#0x3f              ;121
00004c  d8ef              BHI      |L1.46|
00004e  bd70              POP      {r4-r6,pc}
                  |L1.80|
000050  f0400040          ORR      r0,r0,#0x40           ;116
                  |L1.84|
000054  7010              STRB     r0,[r2,#0]            ;112
000056  bd70              POP      {r4-r6,pc}
;;;127    
                          ENDP

                  |L1.88|
                          DCD      0x40013800
                  |L1.92|
                          DCD      ||.data||
                  |L1.96|
                          DCD      ||.bss||

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;16     //定义_sys_exit()以避免使用半主机模式    
;;;17     void _sys_exit(int x) 
000000  4770              BX       lr
;;;18     { 
;;;19     	x = x; 
;;;20     } 
;;;21     //重定义fputc函数 
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;21     //重定义fputc函数 
;;;22     int fputc(int ch, FILE *f)
000000  4904              LDR      r1,|L3.20|
                  |L3.2|
;;;23     {      
;;;24     	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
000002  880a              LDRH     r2,[r1,#0]
000004  0652              LSLS     r2,r2,#25
000006  d5fc              BPL      |L3.2|
;;;25         USART1->DR = (u8) ch;      
000008  4a02              LDR      r2,|L3.20|
00000a  b2c1              UXTB     r1,r0
00000c  1d12              ADDS     r2,r2,#4
00000e  8011              STRH     r1,[r2,#0]
;;;26     	return ch;
;;;27     }
000010  4770              BX       lr
;;;28     #endif 
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40013800

                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;54     
;;;55     void uart_init(u32 bound){
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  b086              SUB      sp,sp,#0x18
;;;56         //GPIO端口设置
;;;57         GPIO_InitTypeDef GPIO_InitStructure;
;;;58     	USART_InitTypeDef USART_InitStructure;
;;;59     	NVIC_InitTypeDef NVIC_InitStructure;
;;;60     	 
;;;61     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO, ENABLE);
000006  2101              MOVS     r1,#1
000008  f2440005          MOV      r0,#0x4005
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;62          //USART1_TX   PA.9
;;;63         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000010  f44f7000          MOV      r0,#0x200
000014  f8ad0010          STRH     r0,[sp,#0x10]
;;;64         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2403              MOVS     r4,#3
00001a  f88d4012          STRB     r4,[sp,#0x12]
;;;65         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001e  2018              MOVS     r0,#0x18
;;;66         GPIO_Init(GPIOA, &GPIO_InitStructure);
000020  4e1d              LDR      r6,|L4.152|
000022  f88d0013          STRB     r0,[sp,#0x13]         ;65
000026  a904              ADD      r1,sp,#0x10
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       GPIO_Init
;;;67        
;;;68         //USART1_RX	  PA.10
;;;69         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00002e  1530              ASRS     r0,r6,#20
000030  f8ad0010          STRH     r0,[sp,#0x10]
;;;70         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000034  2004              MOVS     r0,#4
000036  f88d0013          STRB     r0,[sp,#0x13]
;;;71         GPIO_Init(GPIOA, &GPIO_InitStructure);  
00003a  a904              ADD      r1,sp,#0x10
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       GPIO_Init
;;;72     
;;;73        //Usart1 NVIC 配置
;;;74     
;;;75         NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000042  2025              MOVS     r0,#0x25
000044  f88d0014          STRB     r0,[sp,#0x14]
;;;76     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;
000048  f88d4015          STRB     r4,[sp,#0x15]
;;;77     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		//
00004c  f88d4016          STRB     r4,[sp,#0x16]
;;;78     
;;;79     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
000050  2001              MOVS     r0,#1
000052  f88d0017          STRB     r0,[sp,#0x17]
;;;80     	NVIC_Init(&NVIC_InitStructure);	//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器USART1
000056  a805              ADD      r0,sp,#0x14
000058  f7fffffe          BL       NVIC_Init
;;;81       
;;;82        //USART 初始化设置
;;;83        
;;;84     	USART_InitStructure.USART_BaudRate = bound;//一般设置为9600;
;;;85     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00005c  2000              MOVS     r0,#0
00005e  f8ad0004          STRH     r0,[sp,#4]
;;;86     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000062  f8ad0006          STRH     r0,[sp,#6]
;;;87     	USART_InitStructure.USART_Parity = USART_Parity_No;
000066  f8ad0008          STRH     r0,[sp,#8]
;;;88     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00006a  f8ad000c          STRH     r0,[sp,#0xc]
;;;89     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00006e  200c              MOVS     r0,#0xc
;;;90     
;;;91         USART_Init(USART1, &USART_InitStructure);
000070  4c0a              LDR      r4,|L4.156|
000072  f8ad000a          STRH     r0,[sp,#0xa]          ;89
000076  9500              STR      r5,[sp,#0]            ;85
000078  4669              MOV      r1,sp
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       USART_Init
;;;92        
;;;93     
;;;94         USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启中断
000080  2201              MOVS     r2,#1
000082  f2405125          MOV      r1,#0x525
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       USART_ITConfig
;;;95        
;;;96         USART_Cmd(USART1, ENABLE);                    //使能串口 
00008c  2101              MOVS     r1,#1
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       USART_Cmd
;;;97     
;;;98     }
000094  b006              ADD      sp,sp,#0x18
000096  bd70              POP      {r4-r6,pc}
;;;99     
                          ENDP

                  |L4.152|
                          DCD      0x40010800
                  |L4.156|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART_RX_BUF
                          %        64

                          AREA ||.data||, DATA, ALIGN=0

                  USART_RX_STA
000000  00                DCB      0x00

                          AREA ||area_number.9||, DATA, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.data||
                  __stdout
                          DCD      0x00000000
