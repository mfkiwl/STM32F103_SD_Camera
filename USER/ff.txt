; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\ff.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\ff.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\HARDWARE\LED -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\STM32F10x_FWLib\inc -I..\CORE -I..\HARDWARE\SPI -I..\HARDWARE\MMC_SD -I..\HARDWARE\SPI -I..\HARDWARE\LED -I..\HARDWARE\WNOTEPAD -I..\HARDWARE\RTC -I..\FATFS -I..\FATFS\option -I..\HARDWARE\USART3 -I..\APPS -I..\HARDWARE\OV2640 -I..\HARDWARE\24LC1024 -I..\HARDWARE\RAM -I.\RTE\_Target_1 -ID:\EmbeddedTools\MDK51_RAM\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\EmbeddedTools\MDK51_RAM\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\ff.crf ..\FATFS\ff.c]
                          THUMB

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;1981   static
;;;1982   BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
000000  b510              PUSH     {r4,lr}
;;;1983   	FATFS *fs,	/* File system object */
;;;1984   	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
;;;1985   )
;;;1986   {
000002  4604              MOV      r4,r0
;;;1987   	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
000004  460a              MOV      r2,r1
000006  7840              LDRB     r0,[r0,#1]
000008  2301              MOVS     r3,#1
00000a  f1040130          ADD      r1,r4,#0x30
00000e  f7fffffe          BL       disk_read
000012  b108              CBZ      r0,|L1.24|
;;;1988   		return 3;
000014  2003              MOVS     r0,#3
;;;1989   	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
;;;1990   		return 2;
;;;1991   
;;;1992   	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
;;;1993   		return 0;
;;;1994   	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
;;;1995   		return 0;
;;;1996   
;;;1997   	return 1;
;;;1998   }
000016  bd10              POP      {r4,pc}
                  |L1.24|
000018  f8b4122e          LDRH     r1,[r4,#0x22e]        ;1989
00001c  f5a1402a          SUB      r0,r1,#0xaa00         ;1989
000020  3855              SUBS     r0,r0,#0x55           ;1989
000022  d001              BEQ      |L1.40|
000024  2002              MOVS     r0,#2                 ;1990
000026  bd10              POP      {r4,pc}
                  |L1.40|
000028  f8940066          LDRB     r0,[r4,#0x66]         ;1992
00002c  f8b41067          LDRH     r1,[r4,#0x67]         ;1992
000030  ea402101          ORR      r1,r0,r1,LSL #8       ;1992
000034  4808              LDR      r0,|L1.88|
000036  ebb02f01          CMP      r0,r1,LSL #8          ;1992
00003a  d008              BEQ      |L1.78|
00003c  f8941082          LDRB     r1,[r4,#0x82]         ;1994
000040  f8b42083          LDRH     r2,[r4,#0x83]         ;1994
000044  ea412102          ORR      r1,r1,r2,LSL #8       ;1994
000048  ebb02f01          CMP      r0,r1,LSL #8          ;1994
00004c  d101              BNE      |L1.82|
                  |L1.78|
00004e  2000              MOVS     r0,#0                 ;1995
000050  bd10              POP      {r4,pc}
                  |L1.82|
000052  2001              MOVS     r0,#1                 ;1997
000054  bd10              POP      {r4,pc}
;;;1999   
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0x54414600

                          AREA ||i.chk_mounted||, CODE, READONLY, ALIGN=2

                  chk_mounted PROC
;;;2007   static
;;;2008   FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2009   	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
;;;2010   	FATFS **rfs,		/* Pointer to pointer to the found file system object */
;;;2011   	BYTE chk_wp			/* !=0: Check media write protection for write access */
;;;2012   )
;;;2013   {
000004  4615              MOV      r5,r2
000006  460a              MOV      r2,r1
;;;2014   	BYTE fmt, b, pi, *tbl;
;;;2015   	UINT vol;
;;;2016   	DSTATUS stat;
;;;2017   	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
;;;2018   	WORD nrsv;
;;;2019   	const TCHAR *p = *path;
;;;2020   	FATFS *fs;
;;;2021   
;;;2022   	/* Get logical drive number from the path name */
;;;2023   	vol = p[0] - '0';					/* Is there a drive number? 驱动器号*/
000008  6801              LDR      r1,[r0,#0]
00000a  780b              LDRB     r3,[r1,#0]
00000c  3b30              SUBS     r3,r3,#0x30
;;;2024   	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it 提取驱动器号0：*/
00000e  2b09              CMP      r3,#9
000010  d808              BHI      |L2.36|
000012  784c              LDRB     r4,[r1,#1]
000014  2c3a              CMP      r4,#0x3a
000016  d105              BNE      |L2.36|
000018  1c89              ADDS     r1,r1,#2
;;;2025   		p += 2; *path = p;				/* Return pointer to the path name */
00001a  6001              STR      r1,[r0,#0]
00001c  b113              CBZ      r3,|L2.36|
;;;2026   	} else {							/* No drive number is given */
;;;2027   #if _FS_RPATH  //0为绝对路径
;;;2028   		vol = CurrVol;					/* Use current drive 如果为相对路径则使用当前的驱动*/
;;;2029   #else
;;;2030   		vol = 0;						/* Use drive 0 */
;;;2031   #endif
;;;2032   	}
;;;2033   
;;;2034   	/* Check if the file system object is valid or not */
;;;2035   	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
;;;2036   		return FR_INVALID_DRIVE;
00001e  200b              MOVS     r0,#0xb
                  |L2.32|
;;;2037   	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
;;;2038   	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? 执行到这一句*/
;;;2039   
;;;2040   	ENTER_FF(fs);						/* Lock file system */
;;;2041   
;;;2042   	if (fs->fs_type) {					/* If the logical drive has been mounted */
;;;2043   		stat = disk_status(fs->drv);
;;;2044   		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
;;;2045   			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
;;;2046   				return FR_WRITE_PROTECTED;
;;;2047   			return FR_OK;				/* The file system object is valid */
;;;2048   		}
;;;2049   	}
;;;2050   
;;;2051   	/* The file system object is not valid. */
;;;2052   	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
;;;2053   
;;;2054   	fs->fs_type = 0;					/* Clear the file system object */
;;;2055   	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
;;;2056   	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
;;;2057   	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
;;;2058   		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
;;;2059   	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
;;;2060   		return FR_WRITE_PROTECTED;
;;;2061   #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
;;;2062   	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
;;;2063   		return FR_DISK_ERR;
;;;2064   #endif
;;;2065   	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
;;;2066   	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
;;;2067   	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
;;;2068   	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
;;;2069   		/* Check the partition listed in the partition table */
;;;2070   		pi = LD2PT(vol);
;;;2071   		if (pi) pi--;
;;;2072   		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
;;;2073   		if (tbl[4]) {						/* Is the partition existing? */
;;;2074   			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
;;;2075   			fmt = check_fs(fs, bsect);		/* Check the partition */
;;;2076   		}
;;;2077   	}
;;;2078   	if (fmt == 3) return FR_DISK_ERR;
;;;2079   	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
;;;2080   
;;;2081   	/* An FAT volume is found. Following code initializes the file system object */
;;;2082   
;;;2083   	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
;;;2084   		return FR_NO_FILESYSTEM;
;;;2085   
;;;2086   	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
;;;2087   	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
;;;2088   	fs->fsize = fasize;
;;;2089   
;;;2090   	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
;;;2091   	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
;;;2092   	fasize *= b;										/* Number of sectors for FAT area */
;;;2093   
;;;2094   	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
;;;2095   	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
;;;2096   
;;;2097   	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
;;;2098   	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
;;;2099   
;;;2100   	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
;;;2101   	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
;;;2102   
;;;2103   	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
;;;2104   	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
;;;2105   
;;;2106   	/* Determine the FAT sub type */
;;;2107   	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
;;;2108   	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
;;;2109   	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
;;;2110   	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
;;;2111   	fmt = FS_FAT12;
;;;2112   	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
;;;2113   	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
;;;2114   
;;;2115   	/* Boundaries and Limits */
;;;2116   	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
;;;2117   	fs->database = bsect + sysect;						/* Data start sector */
;;;2118   	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
;;;2119   	if (fmt == FS_FAT32) {
;;;2120   		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
;;;2121   		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
;;;2122   		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
;;;2123   	} else {
;;;2124   		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
;;;2125   		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
;;;2126   		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
;;;2127   			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
;;;2128   	}
;;;2129   	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
;;;2130   		return FR_NO_FILESYSTEM;
;;;2131   
;;;2132   #if !_FS_READONLY
;;;2133   	/* Initialize cluster allocation information */
;;;2134   	fs->free_clust = 0xFFFFFFFF;
;;;2135   	fs->last_clust = 0;
;;;2136   
;;;2137   	/* Get fsinfo if available */
;;;2138   	if (fmt == FS_FAT32) {
;;;2139   	 	fs->fsi_flag = 0;
;;;2140   		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
;;;2141   		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
;;;2142   			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
;;;2143   			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
;;;2144   			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
;;;2145   				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
;;;2146   				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
;;;2147   		}
;;;2148   	}
;;;2149   #endif
;;;2150   	fs->fs_type = fmt;		/* FAT sub-type */
;;;2151   	fs->id = ++Fsid;		/* File system mount ID */
;;;2152   	fs->winsect = 0;		/* Invalidate sector cache */
;;;2153   	fs->wflag = 0;
;;;2154   #if _FS_RPATH
;;;2155   	fs->cdir = 0;			/* Current directory (root dir) */
;;;2156   #endif
;;;2157   #if _FS_SHARE				/* Clear file lock semaphores */
;;;2158   	clear_lock(fs);
;;;2159   #endif
;;;2160   
;;;2161   	return FR_OK;
;;;2162   }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L2.36|
000024  4876              LDR      r0,|L2.512|
000026  6804              LDR      r4,[r0,#0]            ;2037
000028  6014              STR      r4,[r2,#0]            ;2038
00002a  b19c              CBZ      r4,|L2.84|
00002c  7820              LDRB     r0,[r4,#0]            ;2042
00002e  b120              CBZ      r0,|L2.58|
000030  7860              LDRB     r0,[r4,#1]            ;2043
000032  f7fffffe          BL       disk_status
000036  07c1              LSLS     r1,r0,#31             ;2044
000038  d00e              BEQ      |L2.88|
                  |L2.58|
00003a  f04f0900          MOV      r9,#0                 ;2054
00003e  f8849000          STRB     r9,[r4,#0]            ;2054
000042  4648              MOV      r0,r9                 ;2054
000044  f8849001          STRB     r9,[r4,#1]            ;2055
000048  f7fffffe          BL       disk_initialize
00004c  07c1              LSLS     r1,r0,#31             ;2057
00004e  d008              BEQ      |L2.98|
000050  2003              MOVS     r0,#3                 ;2058
000052  e7e5              B        |L2.32|
                  |L2.84|
000054  200c              MOVS     r0,#0xc               ;2038
000056  e7e3              B        |L2.32|
                  |L2.88|
000058  b10d              CBZ      r5,|L2.94|
00005a  0740              LSLS     r0,r0,#29             ;2045
00005c  d404              BMI      |L2.104|
                  |L2.94|
00005e  2000              MOVS     r0,#0                 ;2047
000060  e7de              B        |L2.32|
                  |L2.98|
000062  b11d              CBZ      r5,|L2.108|
000064  0740              LSLS     r0,r0,#29             ;2059
000066  d501              BPL      |L2.108|
                  |L2.104|
000068  200a              MOVS     r0,#0xa               ;2060
00006a  e7d9              B        |L2.32|
                  |L2.108|
00006c  2600              MOVS     r6,#0                 ;2066
00006e  4631              MOV      r1,r6                 ;2066
000070  4620              MOV      r0,r4                 ;2066
000072  f7fffffe          BL       check_fs
000076  2801              CMP      r0,#1                 ;2068
000078  d10c              BNE      |L2.148|
00007a  f50470f7          ADD      r0,r4,#0x1ee          ;2072
00007e  7901              LDRB     r1,[r0,#4]            ;2073
000080  b3f1              CBZ      r1,|L2.256|
000082  7a01              LDRB     r1,[r0,#8]            ;2074
000084  f8d00009          LDR      r0,[r0,#9]            ;2074
000088  ea412600          ORR      r6,r1,r0,LSL #8       ;2074
00008c  4631              MOV      r1,r6                 ;2075
00008e  4620              MOV      r0,r4                 ;2075
000090  f7fffffe          BL       check_fs
                  |L2.148|
000094  2803              CMP      r0,#3                 ;2078
000096  d001              BEQ      |L2.156|
000098  bb90              CBNZ     r0,|L2.256|
00009a  e001              B        |L2.160|
                  |L2.156|
00009c  2001              MOVS     r0,#1                 ;2078
00009e  e7bf              B        |L2.32|
                  |L2.160|
0000a0  f8b4003b          LDRH     r0,[r4,#0x3b]         ;2083
0000a4  f5b07f00          CMP      r0,#0x200             ;2083
0000a8  d157              BNE      |L2.346|
0000aa  f8b40046          LDRH     r0,[r4,#0x46]         ;2086
0000ae  b928              CBNZ     r0,|L2.188|
0000b0  f8940054          LDRB     r0,[r4,#0x54]         ;2087
0000b4  f8d41055          LDR      r1,[r4,#0x55]         ;2087
0000b8  ea402001          ORR      r0,r0,r1,LSL #8       ;2087
                  |L2.188|
0000bc  61e0              STR      r0,[r4,#0x1c]         ;2090
0000be  f8941040          LDRB     r1,[r4,#0x40]         ;2090
0000c2  4684              MOV      r12,r0                ;2088
0000c4  70e1              STRB     r1,[r4,#3]            ;2090
0000c6  2901              CMP      r1,#1                 ;2091
0000c8  d001              BEQ      |L2.206|
0000ca  2902              CMP      r1,#2                 ;2091
0000cc  d145              BNE      |L2.346|
                  |L2.206|
0000ce  f894503d          LDRB     r5,[r4,#0x3d]         ;2094
0000d2  4348              MULS     r0,r1,r0              ;2092
0000d4  70a5              STRB     r5,[r4,#2]            ;2094
0000d6  b19d              CBZ      r5,|L2.256|
0000d8  1e6a              SUBS     r2,r5,#1              ;2095
0000da  4215              TST      r5,r2                 ;2095
0000dc  d13d              BNE      |L2.346|
0000de  f8b42041          LDRH     r2,[r4,#0x41]         ;2097
0000e2  8122              STRH     r2,[r4,#8]            ;2097
0000e4  0711              LSLS     r1,r2,#28             ;2098
0000e6  d138              BNE      |L2.346|
0000e8  f8b41043          LDRH     r1,[r4,#0x43]         ;2100
0000ec  b929              CBNZ     r1,|L2.250|
0000ee  f8941050          LDRB     r1,[r4,#0x50]         ;2101
0000f2  f8d43051          LDR      r3,[r4,#0x51]         ;2101
0000f6  ea412103          ORR      r1,r1,r3,LSL #8       ;2101
                  |L2.250|
0000fa  8fe3              LDRH     r3,[r4,#0x3e]         ;2103
0000fc  b103              CBZ      r3,|L2.256|
0000fe  e000              B        |L2.258|
                  |L2.256|
000100  e02b              B        |L2.346|
                  |L2.258|
000102  181f              ADDS     r7,r3,r0              ;2107
000104  eb071712          ADD      r7,r7,r2,LSR #4       ;2107
000108  42b9              CMP      r1,r7                 ;2108
00010a  d326              BCC      |L2.346|
00010c  1bc9              SUBS     r1,r1,r7              ;2109
00010e  fbb1f1f5          UDIV     r1,r1,r5              ;2109
000112  b311              CBZ      r1,|L2.346|
000114  2501              MOVS     r5,#1                 ;2111
000116  f64078f6          MOV      r8,#0xff6             ;2112
00011a  4541              CMP      r1,r8                 ;2112
00011c  d300              BCC      |L2.288|
00011e  2502              MOVS     r5,#2                 ;2112
                  |L2.288|
000120  f64f78f6          MOV      r8,#0xfff6            ;2113
000124  4541              CMP      r1,r8                 ;2113
000126  d300              BCC      |L2.298|
000128  2503              MOVS     r5,#3                 ;2113
                  |L2.298|
00012a  4437              ADD      r7,r7,r6              ;2117
00012c  1c89              ADDS     r1,r1,#2              ;2113
00012e  4433              ADD      r3,r3,r6              ;2118
000130  62a7              STR      r7,[r4,#0x28]         ;2119
000132  6223              STR      r3,[r4,#0x20]         ;2119
000134  61a1              STR      r1,[r4,#0x18]         ;2119
000136  2d03              CMP      r5,#3                 ;2119
000138  d011              BEQ      |L2.350|
00013a  b172              CBZ      r2,|L2.346|
00013c  4418              ADD      r0,r0,r3              ;2125
00013e  6260              STR      r0,[r4,#0x24]         ;2126
000140  2d02              CMP      r5,#2                 ;2126
000142  d017              BEQ      |L2.372|
000144  f0010001          AND      r0,r1,#1              ;2127
000148  eb010141          ADD      r1,r1,r1,LSL #1       ;2127
00014c  eb000051          ADD      r0,r0,r1,LSR #1       ;2127
                  |L2.336|
000150  f20010ff          ADD      r0,r0,#0x1ff          ;2127
000154  ebbc2f50          CMP      r12,r0,LSR #9         ;2129
000158  d20e              BCS      |L2.376|
                  |L2.346|
00015a  200d              MOVS     r0,#0xd               ;2130
00015c  e760              B        |L2.32|
                  |L2.350|
00015e  2a00              CMP      r2,#0                 ;2120
000160  d1fb              BNE      |L2.346|
000162  f894005c          LDRB     r0,[r4,#0x5c]         ;2121
000166  f8d4205d          LDR      r2,[r4,#0x5d]         ;2121
00016a  ea402002          ORR      r0,r0,r2,LSL #8       ;2121
00016e  6260              STR      r0,[r4,#0x24]         ;2122
000170  0088              LSLS     r0,r1,#2              ;2122
000172  e7ed              B        |L2.336|
                  |L2.372|
000174  0048              LSLS     r0,r1,#1              ;2127
000176  e7eb              B        |L2.336|
                  |L2.376|
000178  f04f30ff          MOV      r0,#0xffffffff        ;2134
00017c  e9c49003          STRD     r9,r0,[r4,#0xc]       ;2138
000180  464f              MOV      r7,r9                 ;2135
000182  2d03              CMP      r5,#3                 ;2138
000184  d131              BNE      |L2.490|
000186  7167              STRB     r7,[r4,#5]            ;2139
000188  f8b40060          LDRH     r0,[r4,#0x60]         ;2140
00018c  2301              MOVS     r3,#1                 ;2141
00018e  1982              ADDS     r2,r0,r6              ;2140
000190  6162              STR      r2,[r4,#0x14]         ;2141
000192  7860              LDRB     r0,[r4,#1]            ;2141
000194  f1040130          ADD      r1,r4,#0x30           ;2141
000198  f7fffffe          BL       disk_read
00019c  bb28              CBNZ     r0,|L2.490|
00019e  f8b4022e          LDRH     r0,[r4,#0x22e]        ;2142
0001a2  f5a0412a          SUB      r1,r0,#0xaa00         ;2142
0001a6  3955              SUBS     r1,r1,#0x55           ;2142
0001a8  d11f              BNE      |L2.490|
0001aa  f8940030          LDRB     r0,[r4,#0x30]         ;2143
0001ae  f8d41031          LDR      r1,[r4,#0x31]         ;2143
0001b2  ea402001          ORR      r0,r0,r1,LSL #8       ;2143
0001b6  4913              LDR      r1,|L2.516|
0001b8  4288              CMP      r0,r1                 ;2143
0001ba  d116              BNE      |L2.490|
0001bc  f8940214          LDRB     r0,[r4,#0x214]        ;2144
0001c0  f8d41215          LDR      r1,[r4,#0x215]        ;2144
0001c4  ea402001          ORR      r0,r0,r1,LSL #8       ;2144
0001c8  490f              LDR      r1,|L2.520|
0001ca  4288              CMP      r0,r1                 ;2144
0001cc  d10d              BNE      |L2.490|
0001ce  f894021c          LDRB     r0,[r4,#0x21c]        ;2145
0001d2  f8d4121d          LDR      r1,[r4,#0x21d]        ;2145
0001d6  ea402001          ORR      r0,r0,r1,LSL #8       ;2145
0001da  60e0              STR      r0,[r4,#0xc]          ;2146
0001dc  f8940218          LDRB     r0,[r4,#0x218]        ;2146
0001e0  f8d41219          LDR      r1,[r4,#0x219]        ;2146
0001e4  ea402001          ORR      r0,r0,r1,LSL #8       ;2146
0001e8  6120              STR      r0,[r4,#0x10]         ;2146
                  |L2.490|
0001ea  4905              LDR      r1,|L2.512|
0001ec  7025              STRB     r5,[r4,#0]            ;2150
0001ee  1f09              SUBS     r1,r1,#4              ;2151
0001f0  8808              LDRH     r0,[r1,#0]            ;2151  ; Fsid
0001f2  1c40              ADDS     r0,r0,#1              ;2151
0001f4  8008              STRH     r0,[r1,#0]            ;2151
0001f6  80e0              STRH     r0,[r4,#6]            ;2151
0001f8  62e7              STR      r7,[r4,#0x2c]         ;2153
0001fa  7127              STRB     r7,[r4,#4]            ;2153
0001fc  e72f              B        |L2.94|
;;;2163   
                          ENDP

0001fe  0000              DCW      0x0000
                  |L2.512|
                          DCD      ||.data||+0x4
                  |L2.516|
                          DCD      0x41615252
                  |L2.520|
                          DCD      0x61417272

                          AREA ||i.clust2sect||, CODE, READONLY, ALIGN=1

                  clust2sect PROC
;;;800    
;;;801    DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
000000  6982              LDR      r2,[r0,#0x18]
;;;802    	FATFS *fs,		/* File system object */
;;;803    	DWORD clst		/* Cluster# to be converted */
;;;804    )
;;;805    {
;;;806    	clst -= 2;
;;;807    	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
000002  1e89              SUBS     r1,r1,#2
000004  1e92              SUBS     r2,r2,#2
000006  428a              CMP      r2,r1
000008  d801              BHI      |L3.14|
00000a  2000              MOVS     r0,#0
;;;808    	return clst * fs->csize + fs->database;
;;;809    }
00000c  4770              BX       lr
                  |L3.14|
00000e  6a82              LDR      r2,[r0,#0x28]         ;808
000010  7880              LDRB     r0,[r0,#2]            ;808
000012  fb012000          MLA      r0,r1,r0,r2           ;808
000016  4770              BX       lr
;;;810    
                          ENDP


                          AREA ||i.create_chain||, CODE, READONLY, ALIGN=1

                  create_chain PROC
;;;977    static
;;;978    DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;979    	FATFS *fs,			/* File system object */
;;;980    	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
;;;981    )
;;;982    {
000004  000f              MOVS     r7,r1
000006  4606              MOV      r6,r0
000008  d006              BEQ      |L4.24|
;;;983    	DWORD cs, ncl, scl;
;;;984    	FRESULT res;
;;;985    
;;;986    
;;;987    	if (clst == 0) {		/* Create a new chain */
;;;988    		scl = fs->last_clust;			/* Get suggested start point */
;;;989    		if (!scl || scl >= fs->n_fatent) scl = 1;
;;;990    	}
;;;991    	else {					/* Stretch the current chain */
;;;992    		cs = get_fat(fs, clst);			/* Check the cluster status */
00000a  f7fffffe          BL       get_fat
;;;993    		if (cs < 2) return 1;			/* It is an invalid cluster */
00000e  2802              CMP      r0,#2
000010  d209              BCS      |L4.38|
000012  2001              MOVS     r0,#1
                  |L4.20|
;;;994    		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
;;;995    		scl = clst;
;;;996    	}
;;;997    
;;;998    	ncl = scl;				/* Start cluster */
;;;999    	for (;;) {
;;;1000   		ncl++;							/* Next cluster */
;;;1001   		if (ncl >= fs->n_fatent) {		/* Wrap around */
;;;1002   			ncl = 2;
;;;1003   			if (ncl > scl) return 0;	/* No free cluster */
;;;1004   		}
;;;1005   		cs = get_fat(fs, ncl);			/* Get the cluster status */
;;;1006   		if (cs == 0) break;				/* Found a free cluster */
;;;1007   		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
;;;1008   			return cs;
;;;1009   		if (ncl == scl) return 0;		/* No free cluster */
;;;1010   	}
;;;1011   
;;;1012   	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
;;;1013   	if (res == FR_OK && clst != 0) {
;;;1014   		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
;;;1015   	}
;;;1016   	if (res == FR_OK) {
;;;1017   		fs->last_clust = ncl;			/* Update FSINFO */
;;;1018   		if (fs->free_clust != 0xFFFFFFFF) {
;;;1019   			fs->free_clust--;
;;;1020   			fs->fsi_flag = 1;
;;;1021   		}
;;;1022   	} else {
;;;1023   		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
;;;1024   	}
;;;1025   
;;;1026   	return ncl;		/* Return new cluster number or error code */
;;;1027   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L4.24|
000018  68f5              LDR      r5,[r6,#0xc]          ;989
00001a  b115              CBZ      r5,|L4.34|
00001c  69b0              LDR      r0,[r6,#0x18]         ;989
00001e  42a8              CMP      r0,r5                 ;989
000020  d805              BHI      |L4.46|
                  |L4.34|
000022  2501              MOVS     r5,#1                 ;989
000024  e003              B        |L4.46|
                  |L4.38|
000026  69b1              LDR      r1,[r6,#0x18]         ;994
000028  4281              CMP      r1,r0                 ;994
00002a  d8f3              BHI      |L4.20|
00002c  463d              MOV      r5,r7                 ;995
                  |L4.46|
00002e  462c              MOV      r4,r5                 ;998
                  |L4.48|
000030  69b0              LDR      r0,[r6,#0x18]         ;1001
000032  1c64              ADDS     r4,r4,#1              ;1001
000034  42a0              CMP      r0,r4                 ;1001
000036  d802              BHI      |L4.62|
000038  2402              MOVS     r4,#2                 ;1002
00003a  2d02              CMP      r5,#2                 ;1003
00003c  d30a              BCC      |L4.84|
                  |L4.62|
00003e  4621              MOV      r1,r4                 ;1005
000040  4630              MOV      r0,r6                 ;1005
000042  f7fffffe          BL       get_fat
000046  b138              CBZ      r0,|L4.88|
000048  1c41              ADDS     r1,r0,#1              ;1007
00004a  d0e3              BEQ      |L4.20|
00004c  2801              CMP      r0,#1                 ;1007
00004e  d0e1              BEQ      |L4.20|
000050  42ac              CMP      r4,r5                 ;1009
000052  d1ed              BNE      |L4.48|
                  |L4.84|
000054  2000              MOVS     r0,#0                 ;1009
000056  e7dd              B        |L4.20|
                  |L4.88|
000058  f06f4270          MVN      r2,#0xf0000000        ;1012
00005c  4621              MOV      r1,r4                 ;1012
00005e  4630              MOV      r0,r6                 ;1012
000060  f7fffffe          BL       put_fat
000064  b930              CBNZ     r0,|L4.116|
000066  b157              CBZ      r7,|L4.126|
000068  4622              MOV      r2,r4                 ;1014
00006a  4639              MOV      r1,r7                 ;1014
00006c  4630              MOV      r0,r6                 ;1014
00006e  f7fffffe          BL       put_fat
000072  b120              CBZ      r0,|L4.126|
                  |L4.116|
000074  2801              CMP      r0,#1                 ;1023
000076  d00b              BEQ      |L4.144|
000078  2401              MOVS     r4,#1                 ;1023
                  |L4.122|
00007a  4620              MOV      r0,r4                 ;1026
00007c  e7ca              B        |L4.20|
                  |L4.126|
00007e  60f4              STR      r4,[r6,#0xc]          ;1018
000080  6930              LDR      r0,[r6,#0x10]         ;1018
000082  1c41              ADDS     r1,r0,#1              ;1018
000084  d0f9              BEQ      |L4.122|
000086  1e40              SUBS     r0,r0,#1              ;1018
000088  6130              STR      r0,[r6,#0x10]         ;1020
00008a  2001              MOVS     r0,#1                 ;1020
00008c  7170              STRB     r0,[r6,#5]            ;1020
00008e  e7f4              B        |L4.122|
                  |L4.144|
000090  f04f34ff          MOV      r4,#0xffffffff        ;1023
000094  e7f1              B        |L4.122|
;;;1028   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;1622   static
;;;1623   FRESULT create_name (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1624   	DIR *dj,			/* Pointer to the directory object */
;;;1625   	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
;;;1626   )
;;;1627   {
000004  4689              MOV      r9,r1
000006  680c              LDR      r4,[r1,#0]
000008  e000              B        |L5.12|
                  |L5.10|
00000a  1c64              ADDS     r4,r4,#1
                  |L5.12|
;;;1628   #ifdef _EXCVT
;;;1629   	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
;;;1630   #endif
;;;1631   
;;;1632   #if _USE_LFN	/* LFN configuration */
;;;1633   	BYTE b, cf;
;;;1634   	WCHAR w, *lfn;
;;;1635   	UINT i, ni, si, di;
;;;1636   	const TCHAR *p;
;;;1637   
;;;1638   	/* Create LFN in Unicode */
;;;1639   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
;;;1640   	lfn = dj->lfn;
;;;1641   	si = di = 0;
;;;1642   	for (;;) {
;;;1643   		w = p[si++];					/* Get a character */
;;;1644   		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
;;;1645   		if (di >= _MAX_LFN)				/* Reject too long name */
;;;1646   			return FR_INVALID_NAME;
;;;1647   #if !_LFN_UNICODE
;;;1648   		w &= 0xFF;
;;;1649   		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;1650   			b = (BYTE)p[si++];			/* Get 2nd byte */
;;;1651   			if (!IsDBCS2(b))
;;;1652   				return FR_INVALID_NAME;	/* Reject invalid sequence */
;;;1653   			w = (w << 8) + b;			/* Create a DBC */
;;;1654   		}
;;;1655   		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
;;;1656   		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
;;;1657   #endif
;;;1658   		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
;;;1659   			return FR_INVALID_NAME;
;;;1660   		lfn[di++] = w;					/* Store the Unicode char */
;;;1661   	}
;;;1662   	*path = &p[si];						/* Return pointer to the next segment */
;;;1663   	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
;;;1664   #if _FS_RPATH
;;;1665   	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
;;;1666   		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
;;;1667   		lfn[di] = 0;
;;;1668   		for (i = 0; i < 11; i++)
;;;1669   			dj->fn[i] = (i < di) ? '.' : ' ';
;;;1670   		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
;;;1671   		return FR_OK;
;;;1672   	}
;;;1673   #endif
;;;1674   	while (di) {						/* Strip trailing spaces and dots */
;;;1675   		w = lfn[di-1];
;;;1676   		if (w != ' ' && w != '.') break;
;;;1677   		di--;
;;;1678   	}
;;;1679   	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
;;;1680   
;;;1681   	lfn[di] = 0;						/* LFN is created */
;;;1682   
;;;1683   	/* Create SFN in directory form */
;;;1684   	mem_set(dj->fn, ' ', 11);
;;;1685   	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
;;;1686   	if (si) cf |= NS_LOSS | NS_LFN;
;;;1687   	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
;;;1688   
;;;1689   	b = i = 0; ni = 8;
;;;1690   	for (;;) {
;;;1691   		w = lfn[si++];					/* Get an LFN char */
;;;1692   		if (!w) break;					/* Break on end of the LFN */
;;;1693   		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
;;;1694   			cf |= NS_LOSS | NS_LFN; continue;
;;;1695   		}
;;;1696   
;;;1697   		if (i >= ni || si == di) {		/* Extension or end of SFN */
;;;1698   			if (ni == 11) {				/* Long extension */
;;;1699   				cf |= NS_LOSS | NS_LFN; break;
;;;1700   			}
;;;1701   			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
;;;1702   			if (si > di) break;			/* No extension */
;;;1703   			si = di; i = 8; ni = 11;	/* Enter extension section */
;;;1704   			b <<= 2; continue;
;;;1705   		}
;;;1706   
;;;1707   		if (w >= 0x80) {				/* Non ASCII char */
;;;1708   #ifdef _EXCVT
;;;1709   			w = ff_convert(w, 0);		/* Unicode -> OEM code */
;;;1710   			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
;;;1711   #else
;;;1712   			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
;;;1713   #endif
;;;1714   			cf |= NS_LFN;				/* Force create LFN entry */
;;;1715   		}
;;;1716   
;;;1717   		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
;;;1718   			if (i >= ni - 1) {
;;;1719   				cf |= NS_LOSS | NS_LFN; i = ni; continue;
;;;1720   			}
;;;1721   			dj->fn[i++] = (BYTE)(w >> 8);
;;;1722   		} else {						/* Single byte char */
;;;1723   			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
;;;1724   				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
;;;1725   			} else {
;;;1726   				if (IsUpper(w)) {		/* ASCII large capital */
;;;1727   					b |= 2;
;;;1728   				} else {
;;;1729   					if (IsLower(w)) {	/* ASCII small capital */
;;;1730   						b |= 1; w -= 0x20;
;;;1731   					}
;;;1732   				}
;;;1733   			}
;;;1734   		}
;;;1735   		dj->fn[i++] = (BYTE)w;
;;;1736   	}
;;;1737   
;;;1738   	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
;;;1739   
;;;1740   	if (ni == 8) b <<= 2;
;;;1741   	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
;;;1742   		cf |= NS_LFN;
;;;1743   	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
;;;1744   		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
;;;1745   		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
;;;1746   	}
;;;1747   
;;;1748   	dj->fn[NS] = cf;	/* SFN is created */
;;;1749   
;;;1750   	return FR_OK;
;;;1751   
;;;1752   
;;;1753   #else	/* Non-LFN configuration */
;;;1754   	BYTE b, c, d, *sfn;
;;;1755   	UINT ni, si, i;
;;;1756   	const char *p;
;;;1757   
;;;1758   	/* Create file name in directory form */
;;;1759   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
00000c  7821              LDRB     r1,[r4,#0]
00000e  292f              CMP      r1,#0x2f
000010  d0fb              BEQ      |L5.10|
000012  295c              CMP      r1,#0x5c
000014  d0f9              BEQ      |L5.10|
;;;1760   	sfn = dj->fn;
;;;1761   	mem_set(sfn, ' ', 11);
000016  6985              LDR      r5,[r0,#0x18]
000018  220b              MOVS     r2,#0xb
00001a  2120              MOVS     r1,#0x20
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       mem_set
;;;1762   	si = i = b = 0; ni = 8;
000022  2000              MOVS     r0,#0
000024  4602              MOV      r2,r0
000026  4613              MOV      r3,r2
000028  2708              MOVS     r7,#8
                  |L5.42|
;;;1763   #if _FS_RPATH
;;;1764   	if (p[si] == '.') { /* Is this a dot entry? */
;;;1765   		for (;;) {
;;;1766   			c = (BYTE)p[si++];
;;;1767   			if (c != '.' || si >= 3) break;
;;;1768   			sfn[i++] = c;
;;;1769   		}
;;;1770   		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
;;;1771   		*path = &p[si];									/* Return pointer to the next segment */
;;;1772   		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
;;;1773   		return FR_OK;
;;;1774   	}
;;;1775   #endif
;;;1776   	for (;;) {
;;;1777   		c = (BYTE)p[si++];
00002a  5ce1              LDRB     r1,[r4,r3]
00002c  1c5b              ADDS     r3,r3,#1
;;;1778   		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
00002e  2920              CMP      r1,#0x20
000030  d94c              BLS      |L5.204|
000032  292f              CMP      r1,#0x2f
000034  d04a              BEQ      |L5.204|
000036  295c              CMP      r1,#0x5c
000038  d048              BEQ      |L5.204|
;;;1779   		if (c == '.' || i >= ni) {
00003a  292e              CMP      r1,#0x2e
00003c  d001              BEQ      |L5.66|
00003e  42b8              CMP      r0,r7
000040  d308              BCC      |L5.84|
                  |L5.66|
;;;1780   			if (ni != 8 || c != '.') return FR_INVALID_NAME;
000042  2f08              CMP      r7,#8
000044  d14f              BNE      |L5.230|
000046  292e              CMP      r1,#0x2e
000048  d14d              BNE      |L5.230|
;;;1781   			i = 8; ni = 11;
00004a  2008              MOVS     r0,#8
00004c  270b              MOVS     r7,#0xb
;;;1782   			b <<= 2; continue;
00004e  0691              LSLS     r1,r2,#26
000050  0e0a              LSRS     r2,r1,#24
000052  e7ea              B        |L5.42|
                  |L5.84|
;;;1783   		}
;;;1784   		if (c >= 0x80) {				/* Extended char? */
000054  2980              CMP      r1,#0x80
000056  d301              BCC      |L5.92|
;;;1785   			b |= 3;						/* Eliminate NT flag */
000058  f0420203          ORR      r2,r2,#3
                  |L5.92|
;;;1786   #ifdef _EXCVT
;;;1787   			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
;;;1788   #else
;;;1789   #if !_DF1S	/* ASCII only cfg */
;;;1790   			return FR_INVALID_NAME;
;;;1791   #endif
;;;1792   #endif
;;;1793   		}
;;;1794   		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
00005c  f1a10681          SUB      r6,r1,#0x81
000060  2e1e              CMP      r6,#0x1e
000062  d902              BLS      |L5.106|
000064  3e5f              SUBS     r6,r6,#0x5f
000066  2e1c              CMP      r6,#0x1c
000068  d813              BHI      |L5.146|
                  |L5.106|
;;;1795   			d = (BYTE)p[si++];			/* Get 2nd byte */
00006a  5ce6              LDRB     r6,[r4,r3]
;;;1796   			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
00006c  1c5b              ADDS     r3,r3,#1
00006e  f1a60c40          SUB      r12,r6,#0x40
000072  f1bc0f3f          CMP      r12,#0x3f
000076  d304              BCC      |L5.130|
000078  f1a60c80          SUB      r12,r6,#0x80
00007c  f1bc0f7d          CMP      r12,#0x7d
000080  d231              BCS      |L5.230|
                  |L5.130|
000082  f1a70c01          SUB      r12,r7,#1
000086  4560              CMP      r0,r12
000088  d22d              BCS      |L5.230|
;;;1797   				return FR_INVALID_NAME;
;;;1798   			sfn[i++] = c;
00008a  5429              STRB     r1,[r5,r0]
00008c  1c40              ADDS     r0,r0,#1
;;;1799   			sfn[i++] = d;
00008e  542e              STRB     r6,[r5,r0]
000090  e01a              B        |L5.200|
                  |L5.146|
;;;1800   		} else {						/* Single byte code */
;;;1801   			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
000092  a621              ADR      r6,|L5.280|
000094  e000              B        |L5.152|
                  |L5.150|
000096  1c76              ADDS     r6,r6,#1
                  |L5.152|
000098  f896c000          LDRB     r12,[r6,#0]
00009c  f1bc0f00          CMP      r12,#0
0000a0  d002              BEQ      |L5.168|
0000a2  458c              CMP      r12,r1
0000a4  d1f7              BNE      |L5.150|
0000a6  e01e              B        |L5.230|
                  |L5.168|
;;;1802   				return FR_INVALID_NAME;
;;;1803   			if (IsUpper(c)) {			/* ASCII large capital? */
0000a8  f1a10641          SUB      r6,r1,#0x41
0000ac  2e19              CMP      r6,#0x19
0000ae  d802              BHI      |L5.182|
;;;1804   				b |= 2;
0000b0  f0420202          ORR      r2,r2,#2
0000b4  e007              B        |L5.198|
                  |L5.182|
;;;1805   			} else {
;;;1806   				if (IsLower(c)) {		/* ASCII small capital? */
0000b6  f1a10661          SUB      r6,r1,#0x61
0000ba  2e19              CMP      r6,#0x19
0000bc  d803              BHI      |L5.198|
;;;1807   					b |= 1; c -= 0x20;
0000be  3920              SUBS     r1,r1,#0x20
0000c0  f0420201          ORR      r2,r2,#1
0000c4  b2c9              UXTB     r1,r1
                  |L5.198|
;;;1808   				}
;;;1809   			}
;;;1810   			sfn[i++] = c;
0000c6  5429              STRB     r1,[r5,r0]
                  |L5.200|
0000c8  1c40              ADDS     r0,r0,#1
0000ca  e7ae              B        |L5.42|
                  |L5.204|
;;;1811   		}
;;;1812   	}
;;;1813   	*path = &p[si];						/* Return pointer to the next segment */
0000cc  441c              ADD      r4,r4,r3
;;;1814   	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
0000ce  f8c94000          STR      r4,[r9,#0]
0000d2  2920              CMP      r1,#0x20
0000d4  d801              BHI      |L5.218|
0000d6  2104              MOVS     r1,#4
0000d8  e000              B        |L5.220|
                  |L5.218|
0000da  2100              MOVS     r1,#0
                  |L5.220|
;;;1815   
;;;1816   	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
0000dc  b118              CBZ      r0,|L5.230|
;;;1817   	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
0000de  7828              LDRB     r0,[r5,#0]
0000e0  28e5              CMP      r0,#0xe5
0000e2  d003              BEQ      |L5.236|
0000e4  e004              B        |L5.240|
                  |L5.230|
0000e6  2006              MOVS     r0,#6                 ;1816
                  |L5.232|
;;;1818   
;;;1819   	if (ni == 8) b <<= 2;
;;;1820   	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
;;;1821   	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
;;;1822   
;;;1823   	sfn[NS] = c;		/* Store NT flag, File name is created */
;;;1824   
;;;1825   	return FR_OK;
;;;1826   #endif
;;;1827   }
0000e8  e8bd87f0          POP      {r4-r10,pc}
                  |L5.236|
0000ec  2005              MOVS     r0,#5                 ;1817
0000ee  7028              STRB     r0,[r5,#0]            ;1817
                  |L5.240|
0000f0  2f08              CMP      r7,#8                 ;1819
0000f2  d101              BNE      |L5.248|
0000f4  0690              LSLS     r0,r2,#26             ;1819
0000f6  0e02              LSRS     r2,r0,#24             ;1819
                  |L5.248|
0000f8  f0020003          AND      r0,r2,#3              ;1820
0000fc  2801              CMP      r0,#1                 ;1820
0000fe  d101              BNE      |L5.260|
000100  f0410110          ORR      r1,r1,#0x10           ;1820
                  |L5.260|
000104  f3c20081          UBFX     r0,r2,#2,#2           ;1821
000108  2801              CMP      r0,#1                 ;1821
00010a  d101              BNE      |L5.272|
00010c  f0410108          ORR      r1,r1,#8              ;1821
                  |L5.272|
000110  72e9              STRB     r1,[r5,#0xb]          ;1823
000112  2000              MOVS     r0,#0                 ;1825
000114  e7e8              B        |L5.232|
;;;1828   
                          ENDP

000116  0000              DCW      0x0000
                  |L5.280|
000118  222a2b2c          DCB      """*+,:;<=>?[]|",127,0
00011c  3a3b3c3d
000120  3e3f5b5d
000124  7c7f00  
000127  00                DCB      0

                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=1

                  dir_next PROC
;;;1112   static
;;;1113   FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1114   	DIR *dj,		/* Pointer to directory object */
;;;1115   	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
;;;1116   )
;;;1117   {
000004  4604              MOV      r4,r0
;;;1118   	DWORD clst;
;;;1119   	WORD i;
;;;1120   
;;;1121   
;;;1122   	stretch = stretch;		/* To suppress warning on read-only cfg. */
;;;1123   	i = dj->index + 1;
000006  88c0              LDRH     r0,[r0,#6]
000008  460e              MOV      r6,r1                 ;1117
00000a  1c40              ADDS     r0,r0,#1
00000c  0407              LSLS     r7,r0,#16
00000e  0c3f              LSRS     r7,r7,#16
000010  d02d              BEQ      |L6.110|
;;;1124   	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
000012  6920              LDR      r0,[r4,#0x10]
000014  b358              CBZ      r0,|L6.110|
;;;1125   		return FR_NO_FILE;
;;;1126   
;;;1127   	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
000016  0739              LSLS     r1,r7,#28
000018  d15d              BNE      |L6.214|
00001a  1c40              ADDS     r0,r0,#1
;;;1128   		dj->sect++;					/* Next sector */
;;;1129   
;;;1130   		if (dj->clust == 0) {	/* Static table */
00001c  6120              STR      r0,[r4,#0x10]
00001e  68e1              LDR      r1,[r4,#0xc]
000020  6820              LDR      r0,[r4,#0]
000022  b129              CBZ      r1,|L6.48|
;;;1131   			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
;;;1132   				return FR_NO_FILE;
;;;1133   		}
;;;1134   		else {					/* Dynamic table */
;;;1135   			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
000024  7882              LDRB     r2,[r0,#2]
000026  1e52              SUBS     r2,r2,#1
000028  ea121f17          TST      r2,r7,LSR #4
00002c  d004              BEQ      |L6.56|
00002e  e052              B        |L6.214|
                  |L6.48|
000030  8900              LDRH     r0,[r0,#8]            ;1131
000032  42b8              CMP      r0,r7                 ;1131
000034  d91b              BLS      |L6.110|
000036  e04e              B        |L6.214|
                  |L6.56|
;;;1136   				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
000038  f7fffffe          BL       get_fat
00003c  4605              MOV      r5,r0
;;;1137   				if (clst <= 1) return FR_INT_ERR;
00003e  2801              CMP      r0,#1
000040  d91a              BLS      |L6.120|
;;;1138   				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
000042  1c68              ADDS     r0,r5,#1
000044  d032              BEQ      |L6.172|
;;;1139   				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
000046  6820              LDR      r0,[r4,#0]
000048  6981              LDR      r1,[r0,#0x18]
00004a  42a9              CMP      r1,r5
00004c  d83d              BHI      |L6.202|
;;;1140   #if !_FS_READONLY
;;;1141   					BYTE c;
;;;1142   					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
00004e  b176              CBZ      r6,|L6.110|
;;;1143   					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
000050  68e1              LDR      r1,[r4,#0xc]
000052  f7fffffe          BL       create_chain
000056  0005              MOVS     r5,r0
;;;1144   					if (clst == 0) return FR_DENIED;			/* No free cluster */
000058  d00c              BEQ      |L6.116|
;;;1145   					if (clst == 1) return FR_INT_ERR;
00005a  2d01              CMP      r5,#1
00005c  d00c              BEQ      |L6.120|
;;;1146   					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
00005e  1c68              ADDS     r0,r5,#1
000060  d024              BEQ      |L6.172|
;;;1147   					/* Clean-up stretched table */
;;;1148   					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
000062  2100              MOVS     r1,#0
000064  6820              LDR      r0,[r4,#0]
000066  f7fffffe          BL       move_window
00006a  b9f8              CBNZ     r0,|L6.172|
00006c  e006              B        |L6.124|
                  |L6.110|
00006e  2004              MOVS     r0,#4                 ;1142
                  |L6.112|
;;;1149   					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
;;;1150   					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
;;;1151   					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
;;;1152   						dj->fs->wflag = 1;
;;;1153   						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
;;;1154   						dj->fs->winsect++;
;;;1155   					}
;;;1156   					dj->fs->winsect -= c;						/* Rewind window address */
;;;1157   #else
;;;1158   					return FR_NO_FILE;			/* Report EOT */
;;;1159   #endif
;;;1160   				}
;;;1161   				dj->clust = clst;				/* Initialize data for new cluster */
;;;1162   				dj->sect = clust2sect(dj->fs, clst);
;;;1163   			}
;;;1164   		}
;;;1165   	}
;;;1166   
;;;1167   	dj->index = i;
;;;1168   	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
;;;1169   
;;;1170   	return FR_OK;
;;;1171   }
000070  e8bd81f0          POP      {r4-r8,pc}
                  |L6.116|
000074  2007              MOVS     r0,#7                 ;1144
000076  e7fb              B        |L6.112|
                  |L6.120|
000078  2002              MOVS     r0,#2                 ;1145
00007a  e7f9              B        |L6.112|
                  |L6.124|
00007c  6820              LDR      r0,[r4,#0]            ;1149
00007e  f44f7200          MOV      r2,#0x200             ;1149
000082  2100              MOVS     r1,#0                 ;1149
000084  3030              ADDS     r0,r0,#0x30           ;1149
000086  f7fffffe          BL       mem_set
00008a  4629              MOV      r1,r5                 ;1150
00008c  6820              LDR      r0,[r4,#0]            ;1150
00008e  f7fffffe          BL       clust2sect
000092  6821              LDR      r1,[r4,#0]            ;1150
000094  2600              MOVS     r6,#0                 ;1151
000096  f04f0801          MOV      r8,#1                 ;1138
00009a  62c8              STR      r0,[r1,#0x2c]         ;1151
00009c  e00e              B        |L6.188|
                  |L6.158|
00009e  f8808004          STRB     r8,[r0,#4]            ;1152
0000a2  2100              MOVS     r1,#0                 ;1153
0000a4  6820              LDR      r0,[r4,#0]            ;1153
0000a6  f7fffffe          BL       move_window
0000aa  b108              CBZ      r0,|L6.176|
                  |L6.172|
0000ac  2001              MOVS     r0,#1                 ;1153
0000ae  e7df              B        |L6.112|
                  |L6.176|
0000b0  6820              LDR      r0,[r4,#0]            ;1154
0000b2  6ac1              LDR      r1,[r0,#0x2c]         ;1154
0000b4  1c49              ADDS     r1,r1,#1              ;1154
0000b6  1c76              ADDS     r6,r6,#1              ;1154
0000b8  b2f6              UXTB     r6,r6                 ;1151
0000ba  62c1              STR      r1,[r0,#0x2c]         ;1151
                  |L6.188|
0000bc  6820              LDR      r0,[r4,#0]            ;1151
0000be  7881              LDRB     r1,[r0,#2]            ;1151
0000c0  42b1              CMP      r1,r6                 ;1151
0000c2  d8ec              BHI      |L6.158|
0000c4  6ac1              LDR      r1,[r0,#0x2c]         ;1156
0000c6  1b89              SUBS     r1,r1,r6              ;1156
0000c8  62c1              STR      r1,[r0,#0x2c]         ;1156
                  |L6.202|
0000ca  60e5              STR      r5,[r4,#0xc]          ;1162
0000cc  4629              MOV      r1,r5                 ;1162
0000ce  6820              LDR      r0,[r4,#0]            ;1162
0000d0  f7fffffe          BL       clust2sect
0000d4  6120              STR      r0,[r4,#0x10]         ;1162
                  |L6.214|
0000d6  80e7              STRH     r7,[r4,#6]            ;1167
0000d8  f007010f          AND      r1,r7,#0xf            ;1168
0000dc  2230              MOVS     r2,#0x30              ;1168
0000de  6820              LDR      r0,[r4,#0]            ;1168
0000e0  eb021141          ADD      r1,r2,r1,LSL #5       ;1168
0000e4  4408              ADD      r0,r0,r1              ;1168
0000e6  6160              STR      r0,[r4,#0x14]         ;1170
0000e8  2000              MOVS     r0,#0                 ;1170
0000ea  e7c1              B        |L6.112|
;;;1172   
                          ENDP


                          AREA ||i.dir_read||, CODE, READONLY, ALIGN=1

                  dir_read PROC
;;;1413   static
;;;1414   FRESULT dir_read (
000000  b510              PUSH     {r4,lr}
;;;1415   	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
;;;1416   )
;;;1417   {
000002  4604              MOV      r4,r0
;;;1418   	FRESULT res;
;;;1419   	BYTE c, *dir;
;;;1420   #if _USE_LFN
;;;1421   	BYTE a, ord = 0xFF, sum = 0xFF;
;;;1422   #endif
;;;1423   
;;;1424   	res = FR_NO_FILE;
000004  2004              MOVS     r0,#4
000006  e015              B        |L7.52|
                  |L7.8|
;;;1425   	while (dj->sect) {
;;;1426   		res = move_window(dj->fs, dj->sect);
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       move_window
;;;1427   		if (res != FR_OK) break;
00000e  b9b0              CBNZ     r0,|L7.62|
;;;1428   		dir = dj->dir;					/* Ptr to the directory entry of current index */
;;;1429   		c = dir[DIR_Name];
000010  6962              LDR      r2,[r4,#0x14]
000012  7811              LDRB     r1,[r2,#0]
;;;1430   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
000014  b161              CBZ      r1,|L7.48|
;;;1431   #if _USE_LFN	/* LFN configuration */
;;;1432   		a = dir[DIR_Attr] & AM_MASK;
;;;1433   		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
;;;1434   			ord = 0xFF;
;;;1435   		} else {
;;;1436   			if (a == AM_LFN) {			/* An LFN entry is found */
;;;1437   				if (c & LLE) {			/* Is it start of LFN sequence? */
;;;1438   					sum = dir[LDIR_Chksum];
;;;1439   					c &= ~LLE; ord = c;
;;;1440   					dj->lfn_idx = dj->index;
;;;1441   				}
;;;1442   				/* Check LFN validity and capture it */
;;;1443   				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
;;;1444   			} else {					/* An SFN entry is found */
;;;1445   				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
;;;1446   					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
;;;1447   				break;
;;;1448   			}
;;;1449   		}
;;;1450   #else		/* Non LFN configuration */
;;;1451   		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
000016  29e5              CMP      r1,#0xe5
000018  d004              BEQ      |L7.36|
00001a  292e              CMP      r1,#0x2e
00001c  d002              BEQ      |L7.36|
00001e  7ad1              LDRB     r1,[r2,#0xb]
000020  0709              LSLS     r1,r1,#28
000022  d50e              BPL      |L7.66|
                  |L7.36|
;;;1452   			break;
;;;1453   #endif
;;;1454   		res = dir_next(dj, 0);				/* Next entry */
000024  2100              MOVS     r1,#0
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       dir_next
;;;1455   		if (res != FR_OK) break;
00002c  b110              CBZ      r0,|L7.52|
00002e  e006              B        |L7.62|
                  |L7.48|
000030  2004              MOVS     r0,#4                 ;1430
000032  e004              B        |L7.62|
                  |L7.52|
000034  6921              LDR      r1,[r4,#0x10]         ;1425
000036  2900              CMP      r1,#0                 ;1425
000038  d1e6              BNE      |L7.8|
;;;1456   	}
;;;1457   
;;;1458   	if (res != FR_OK) dj->sect = 0;
00003a  2800              CMP      r0,#0
00003c  d001              BEQ      |L7.66|
                  |L7.62|
00003e  2100              MOVS     r1,#0
000040  6121              STR      r1,[r4,#0x10]
                  |L7.66|
;;;1459   
;;;1460   	return res;
;;;1461   }
000042  bd10              POP      {r4,pc}
;;;1462   #endif
                          ENDP


                          AREA ||i.dir_register||, CODE, READONLY, ALIGN=1

                  dir_register PROC
;;;1470   static
;;;1471   FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;1472   	DIR *dj				/* Target directory with object name to be created */
;;;1473   )
;;;1474   {
000002  4605              MOV      r5,r0
;;;1475   	FRESULT res;
;;;1476   	BYTE c, *dir;
;;;1477   #if _USE_LFN	/* LFN configuration */
;;;1478   	WORD n, ne, is;
;;;1479   	BYTE sn[12], *fn, sum;
;;;1480   	WCHAR *lfn;
;;;1481   
;;;1482   
;;;1483   	fn = dj->fn; lfn = dj->lfn;
;;;1484   	mem_cpy(sn, fn, 12);
;;;1485   
;;;1486   	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
;;;1487   		return FR_INVALID_NAME;
;;;1488   
;;;1489   	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
;;;1490   		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
;;;1491   		for (n = 1; n < 100; n++) {
;;;1492   			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
;;;1493   			res = dir_find(dj);				/* Check if the name collides with existing SFN */
;;;1494   			if (res != FR_OK) break;
;;;1495   		}
;;;1496   		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
;;;1497   		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
;;;1498   		fn[NS] = sn[NS]; dj->lfn = lfn;
;;;1499   	}
;;;1500   
;;;1501   	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
;;;1502   		for (ne = 0; lfn[ne]; ne++) ;
;;;1503   		ne = (ne + 25) / 13;
;;;1504   	} else {						/* Otherwise reserve only an SFN entry. */
;;;1505   		ne = 1;
;;;1506   	}
;;;1507   
;;;1508   	/* Reserve contiguous entries */
;;;1509   	res = dir_sdi(dj, 0);
;;;1510   	if (res != FR_OK) return res;
;;;1511   	n = is = 0;
;;;1512   	do {
;;;1513   		res = move_window(dj->fs, dj->sect);
;;;1514   		if (res != FR_OK) break;
;;;1515   		c = *dj->dir;				/* Check the entry status */
;;;1516   		if (c == DDE || c == 0) {	/* Is it a blank entry? */
;;;1517   			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
;;;1518   			if (++n == ne) break;	/* A contiguous entry that required count is found */
;;;1519   		} else {
;;;1520   			n = 0;					/* Not a blank entry. Restart to search */
;;;1521   		}
;;;1522   		res = dir_next(dj, 1);		/* Next entry with table stretch */
;;;1523   	} while (res == FR_OK);
;;;1524   
;;;1525   	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
;;;1526   		res = dir_sdi(dj, is);
;;;1527   		if (res == FR_OK) {
;;;1528   			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
;;;1529   			ne--;
;;;1530   			do {					/* Store LFN entries in bottom first */
;;;1531   				res = move_window(dj->fs, dj->sect);
;;;1532   				if (res != FR_OK) break;
;;;1533   				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
;;;1534   				dj->fs->wflag = 1;
;;;1535   				res = dir_next(dj, 0);	/* Next entry */
;;;1536   			} while (res == FR_OK && --ne);
;;;1537   		}
;;;1538   	}
;;;1539   
;;;1540   #else	/* Non LFN configuration */
;;;1541   	res = dir_sdi(dj, 0);
000004  2100              MOVS     r1,#0
000006  f7fffffe          BL       dir_sdi
;;;1542   	if (res == FR_OK) {
00000a  e00e              B        |L8.42|
                  |L8.12|
;;;1543   		do {	/* Find a blank entry for the SFN */
;;;1544   			res = move_window(dj->fs, dj->sect);
00000c  6929              LDR      r1,[r5,#0x10]
00000e  6828              LDR      r0,[r5,#0]
000010  f7fffffe          BL       move_window
000014  0004              MOVS     r4,r0
;;;1545   			if (res != FR_OK) break;
000016  d11f              BNE      |L8.88|
;;;1546   			c = *dj->dir;
000018  6968              LDR      r0,[r5,#0x14]
00001a  7800              LDRB     r0,[r0,#0]
;;;1547   			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
00001c  28e5              CMP      r0,#0xe5
00001e  d007              BEQ      |L8.48|
000020  b130              CBZ      r0,|L8.48|
;;;1548   			res = dir_next(dj, 1);			/* Next entry with table stretch */
000022  2101              MOVS     r1,#1
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       dir_next
                  |L8.42|
00002a  0004              MOVS     r4,r0                 ;1541
00002c  d0ee              BEQ      |L8.12|
00002e  e013              B        |L8.88|
                  |L8.48|
;;;1549   		} while (res == FR_OK);
;;;1550   	}
;;;1551   #endif
;;;1552   
;;;1553   	if (res == FR_OK) {		/* Initialize the SFN entry */
;;;1554   		res = move_window(dj->fs, dj->sect);
000030  6929              LDR      r1,[r5,#0x10]
000032  6828              LDR      r0,[r5,#0]
000034  f7fffffe          BL       move_window
000038  0004              MOVS     r4,r0
;;;1555   		if (res == FR_OK) {
00003a  d10d              BNE      |L8.88|
;;;1556   			dir = dj->dir;
;;;1557   			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
00003c  696e              LDR      r6,[r5,#0x14]
00003e  2220              MOVS     r2,#0x20
000040  2100              MOVS     r1,#0
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       mem_set
;;;1558   			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
000048  220b              MOVS     r2,#0xb
00004a  4630              MOV      r0,r6
00004c  69a9              LDR      r1,[r5,#0x18]
00004e  f7fffffe          BL       mem_cpy
;;;1559   #if _USE_LFN
;;;1560   			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
;;;1561   #endif
;;;1562   			dj->fs->wflag = 1;
000052  6829              LDR      r1,[r5,#0]
000054  2001              MOVS     r0,#1
000056  7108              STRB     r0,[r1,#4]
                  |L8.88|
;;;1563   		}
;;;1564   	}
;;;1565   
;;;1566   	return res;
000058  4620              MOV      r0,r4
;;;1567   }
00005a  bd70              POP      {r4-r6,pc}
;;;1568   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_remove||, CODE, READONLY, ALIGN=1

                  dir_remove PROC
;;;1577   static
;;;1578   FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
000000  b510              PUSH     {r4,lr}
;;;1579   	DIR *dj				/* Directory object pointing the entry to be removed */
;;;1580   )
;;;1581   {
000002  4604              MOV      r4,r0
;;;1582   	FRESULT res;
;;;1583   #if _USE_LFN	/* LFN configuration */
;;;1584   	WORD i;
;;;1585   
;;;1586   	i = dj->index;	/* SFN index */
;;;1587   	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
;;;1588   	if (res == FR_OK) {
;;;1589   		do {
;;;1590   			res = move_window(dj->fs, dj->sect);
;;;1591   			if (res != FR_OK) break;
;;;1592   			*dj->dir = DDE;			/* Mark the entry "deleted" */
;;;1593   			dj->fs->wflag = 1;
;;;1594   			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
;;;1595   			res = dir_next(dj, 0);		/* Next entry */
;;;1596   		} while (res == FR_OK);
;;;1597   		if (res == FR_NO_FILE) res = FR_INT_ERR;
;;;1598   	}
;;;1599   
;;;1600   #else			/* Non LFN configuration */
;;;1601   	res = dir_sdi(dj, dj->index);
000004  88c1              LDRH     r1,[r0,#6]
000006  f7fffffe          BL       dir_sdi
;;;1602   	if (res == FR_OK) {
00000a  2800              CMP      r0,#0
00000c  d10b              BNE      |L9.38|
;;;1603   		res = move_window(dj->fs, dj->sect);
00000e  6921              LDR      r1,[r4,#0x10]
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       move_window
;;;1604   		if (res == FR_OK) {
000016  2800              CMP      r0,#0
000018  d105              BNE      |L9.38|
;;;1605   			*dj->dir = DDE;			/* Mark the entry "deleted" */
00001a  6962              LDR      r2,[r4,#0x14]
00001c  21e5              MOVS     r1,#0xe5
00001e  7011              STRB     r1,[r2,#0]
;;;1606   			dj->fs->wflag = 1;
000020  6822              LDR      r2,[r4,#0]
000022  2101              MOVS     r1,#1
000024  7111              STRB     r1,[r2,#4]
                  |L9.38|
;;;1607   		}
;;;1608   	}
;;;1609   #endif
;;;1610   
;;;1611   	return res;
;;;1612   }
000026  bd10              POP      {r4,pc}
;;;1613   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_sdi||, CODE, READONLY, ALIGN=1

                  dir_sdi PROC
;;;1064   static
;;;1065   FRESULT dir_sdi (
000000  b570              PUSH     {r4-r6,lr}
;;;1066   	DIR *dj,		/* Pointer to directory object */
;;;1067   	WORD idx		/* Directory index number */
;;;1068   )
;;;1069   {
000002  460d              MOV      r5,r1
;;;1070   	DWORD clst;
;;;1071   	WORD ic;
;;;1072   
;;;1073   
;;;1074   	dj->index = idx;
000004  80c1              STRH     r1,[r0,#6]
;;;1075   	clst = dj->sclust;
;;;1076   	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
000006  6881              LDR      r1,[r0,#8]
000008  4604              MOV      r4,r0                 ;1069
00000a  2901              CMP      r1,#1
00000c  d01e              BEQ      |L10.76|
00000e  6820              LDR      r0,[r4,#0]
000010  6982              LDR      r2,[r0,#0x18]
000012  428a              CMP      r2,r1
000014  d91a              BLS      |L10.76|
;;;1077   		return FR_INT_ERR;
;;;1078   	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
000016  b921              CBNZ     r1,|L10.34|
000018  7802              LDRB     r2,[r0,#0]
00001a  2a03              CMP      r2,#3
00001c  d104              BNE      |L10.40|
;;;1079   		clst = dj->fs->dirbase;
00001e  6a41              LDR      r1,[r0,#0x24]
000020  b111              CBZ      r1,|L10.40|
                  |L10.34|
;;;1080   
;;;1081   	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
;;;1082   		dj->clust = clst;
;;;1083   		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
;;;1084   			return FR_INT_ERR;
;;;1085   		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
;;;1086   	}
;;;1087   	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
;;;1088   		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
000022  7880              LDRB     r0,[r0,#2]
000024  0106              LSLS     r6,r0,#4
;;;1089   		while (idx >= ic) {	/* Follow cluster chain */
000026  e017              B        |L10.88|
                  |L10.40|
000028  60e1              STR      r1,[r4,#0xc]          ;1083
00002a  8901              LDRH     r1,[r0,#8]            ;1083
00002c  42a9              CMP      r1,r5                 ;1083
00002e  d90d              BLS      |L10.76|
000030  6a40              LDR      r0,[r0,#0x24]         ;1085
000032  e017              B        |L10.100|
                  |L10.52|
;;;1090   			clst = get_fat(dj->fs, clst);				/* Get next cluster */
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       get_fat
00003a  4601              MOV      r1,r0
;;;1091   			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
00003c  1c40              ADDS     r0,r0,#1
00003e  d007              BEQ      |L10.80|
;;;1092   			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
000040  2902              CMP      r1,#2
000042  d303              BCC      |L10.76|
000044  6820              LDR      r0,[r4,#0]
000046  6980              LDR      r0,[r0,#0x18]
000048  4288              CMP      r0,r1
00004a  d803              BHI      |L10.84|
                  |L10.76|
;;;1093   				return FR_INT_ERR;
00004c  2002              MOVS     r0,#2
;;;1094   			idx -= ic;
;;;1095   		}
;;;1096   		dj->clust = clst;
;;;1097   		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
;;;1098   	}
;;;1099   
;;;1100   	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
;;;1101   
;;;1102   	return FR_OK;	/* Seek succeeded */
;;;1103   }
00004e  bd70              POP      {r4-r6,pc}
                  |L10.80|
000050  2001              MOVS     r0,#1                 ;1091
000052  bd70              POP      {r4-r6,pc}
                  |L10.84|
000054  1ba8              SUBS     r0,r5,r6              ;1094
000056  b285              UXTH     r5,r0                 ;1094
                  |L10.88|
000058  42b5              CMP      r5,r6                 ;1089
00005a  d2eb              BCS      |L10.52|
00005c  60e1              STR      r1,[r4,#0xc]          ;1097
00005e  6820              LDR      r0,[r4,#0]            ;1097
000060  f7fffffe          BL       clust2sect
                  |L10.100|
000064  eb001015          ADD      r0,r0,r5,LSR #4       ;1097
000068  6120              STR      r0,[r4,#0x10]         ;1100
00006a  f005010f          AND      r1,r5,#0xf            ;1100
00006e  2230              MOVS     r2,#0x30              ;1100
000070  6820              LDR      r0,[r4,#0]            ;1100
000072  eb021141          ADD      r1,r2,r1,LSL #5       ;1100
000076  4408              ADD      r0,r0,r1              ;1100
000078  6160              STR      r0,[r4,#0x14]         ;1102
00007a  2000              MOVS     r0,#0                 ;1102
00007c  bd70              POP      {r4-r6,pc}
;;;1104   
                          ENDP


                          AREA ||i.f_chmod||, CODE, READONLY, ALIGN=1

                  f_chmod PROC
;;;3334   
;;;3335   FRESULT f_chmod (
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;3336   	const TCHAR *path,	/* Pointer to the file path */
;;;3337   	BYTE value,			/* Attribute bits */
;;;3338   	BYTE mask			/* Attribute mask to change */
;;;3339   )
;;;3340   {
000002  b08a              SUB      sp,sp,#0x28
000004  4615              MOV      r5,r2
000006  460c              MOV      r4,r1
;;;3341   	FRESULT res;
;;;3342   	DIR dj;
;;;3343   	BYTE *dir;
;;;3344   	DEF_NAMEBUF;
;;;3345   
;;;3346   
;;;3347   	res = chk_mounted(&path, &dj.fs, 1);
000008  2201              MOVS     r2,#1
00000a  4669              MOV      r1,sp
00000c  a80a              ADD      r0,sp,#0x28
00000e  f7fffffe          BL       chk_mounted
;;;3348   	if (res == FR_OK) {
000012  2800              CMP      r0,#0
000014  d116              BNE      |L11.68|
;;;3349   		INIT_BUF(dj);
000016  a807              ADD      r0,sp,#0x1c
;;;3350   		res = follow_path(&dj, path);		/* Follow the file path */
000018  9006              STR      r0,[sp,#0x18]
00001a  4668              MOV      r0,sp
00001c  990a              LDR      r1,[sp,#0x28]
00001e  f7fffffe          BL       follow_path
;;;3351   		FREE_BUF();
;;;3352   		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
;;;3353   			res = FR_INVALID_NAME;
;;;3354   		if (res == FR_OK) {
000022  2800              CMP      r0,#0
000024  d10e              BNE      |L11.68|
;;;3355   			dir = dj.dir;
;;;3356   			if (!dir) {						/* Is it a root directory? */
000026  9805              LDR      r0,[sp,#0x14]
000028  b170              CBZ      r0,|L11.72|
;;;3357   				res = FR_INVALID_NAME;
;;;3358   			} else {						/* File or sub directory */
;;;3359   				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
00002a  f0050227          AND      r2,r5,#0x27
;;;3360   				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
00002e  7ac1              LDRB     r1,[r0,#0xb]
000030  4014              ANDS     r4,r4,r2
000032  4391              BICS     r1,r1,r2
000034  430c              ORRS     r4,r4,r1
000036  72c4              STRB     r4,[r0,#0xb]
;;;3361   				dj.fs->wflag = 1;
000038  9900              LDR      r1,[sp,#0]
00003a  2001              MOVS     r0,#1
00003c  7108              STRB     r0,[r1,#4]
;;;3362   				res = sync(dj.fs);
00003e  9800              LDR      r0,[sp,#0]
000040  f7fffffe          BL       sync
                  |L11.68|
;;;3363   			}
;;;3364   		}
;;;3365   	}
;;;3366   
;;;3367   	LEAVE_FF(dj.fs, res);
;;;3368   }
000044  b00d              ADD      sp,sp,#0x34
000046  bd30              POP      {r4,r5,pc}
                  |L11.72|
000048  2006              MOVS     r0,#6                 ;3357
00004a  e7fb              B        |L11.68|
;;;3369   
                          ENDP


                          AREA ||i.f_close||, CODE, READONLY, ALIGN=1

                  f_close PROC
;;;2643   
;;;2644   FRESULT f_close (
000000  b510              PUSH     {r4,lr}
;;;2645   	FIL *fp		/* Pointer to the file object to be closed */
;;;2646   )
;;;2647   {
000002  4604              MOV      r4,r0
;;;2648   	FRESULT res;
;;;2649   
;;;2650   #if _FS_READONLY
;;;2651   	FATFS *fs = fp->fs;
;;;2652   	res = validate(fs, fp->id);
;;;2653   	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
;;;2654   	LEAVE_FF(fs, res);
;;;2655   
;;;2656   #else
;;;2657   	res = f_sync(fp);		/* Flush cached data */
000004  f7fffffe          BL       f_sync
;;;2658   #if _FS_SHARE
;;;2659   	if (res == FR_OK) {		/* Decrement open counter */
;;;2660   #if _FS_REENTRANT
;;;2661   		res = validate(fp->fs, fp->id);
;;;2662   		if (res == FR_OK) {
;;;2663   			res = dec_lock(fp->lockid);	
;;;2664   			unlock_fs(fp->fs, FR_OK);
;;;2665   		}
;;;2666   #else
;;;2667   		res = dec_lock(fp->lockid);
;;;2668   #endif
;;;2669   	}
;;;2670   #endif
;;;2671   	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L12.16|
00000c  2100              MOVS     r1,#0
00000e  6021              STR      r1,[r4,#0]
                  |L12.16|
;;;2672   	return res;
;;;2673   #endif
;;;2674   }
000010  bd10              POP      {r4,pc}
;;;2675   
                          ENDP


                          AREA ||i.f_getfree||, CODE, READONLY, ALIGN=1

                  f_getfree PROC
;;;3080   
;;;3081   FRESULT f_getfree (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3082   	const TCHAR *path,	/* Pointer to the logical drive number (root dir) 指向物理驱动器号（根目录）*/
;;;3083   	DWORD *nclst,		/* Pointer to the variable to return number of free clusters指向返回空闲簇的变量 */
;;;3084   	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return 指向对应的文件系统结构体*/
;;;3085   )
;;;3086   {
000004  4615              MOV      r5,r2
000006  468a              MOV      r10,r1
;;;3087   	FRESULT res;
;;;3088   	DWORD n, clst, sect, stat;
;;;3089   	UINT i;
;;;3090   	BYTE fat, *p;
;;;3091   
;;;3092   
;;;3093   	/* Get drive number */
;;;3094   	res = chk_mounted(&path, fatfs, 0);
000008  2200              MOVS     r2,#0
00000a  4629              MOV      r1,r5
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       chk_mounted
000012  ea5f0800          MOVS     r8,r0
;;;3095   	if (res == FR_OK) {
000016  d154              BNE      |L13.194|
;;;3096   		/* If free_clust is valid, return it without full cluster scan */
;;;3097   		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
000018  6828              LDR      r0,[r5,#0]
00001a  6987              LDR      r7,[r0,#0x18]
00001c  6901              LDR      r1,[r0,#0x10]
00001e  1eba              SUBS     r2,r7,#2
000020  4291              CMP      r1,r2
000022  d802              BHI      |L13.42|
;;;3098   			*nclst = (*fatfs)->free_clust;
000024  f8ca1000          STR      r1,[r10,#0]
000028  e04b              B        |L13.194|
                  |L13.42|
;;;3099   		} else {
;;;3100   			/* Get number of free clusters */
;;;3101   			fat = (*fatfs)->fs_type;
00002a  f8909000          LDRB     r9,[r0,#0]
;;;3102   			n = 0;
00002e  2400              MOVS     r4,#0
;;;3103   			if (fat == FS_FAT12) {
000030  f1b90f01          CMP      r9,#1
000034  d001              BEQ      |L13.58|
;;;3104   				clst = 2;
;;;3105   				do {
;;;3106   					stat = get_fat(*fatfs, clst);
;;;3107   					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
;;;3108   					if (stat == 1) { res = FR_INT_ERR; break; }
;;;3109   					if (stat == 0) n++;
;;;3110   				} while (++clst < (*fatfs)->n_fatent);
;;;3111   			} else {
;;;3112   				clst = (*fatfs)->n_fatent;
;;;3113   				sect = (*fatfs)->fatbase;
;;;3114   				i = 0; p = 0;
;;;3115   				do {
000036  6a06              LDR      r6,[r0,#0x20]
000038  e017              B        |L13.106|
                  |L13.58|
00003a  2602              MOVS     r6,#2                 ;3104
                  |L13.60|
00003c  4631              MOV      r1,r6                 ;3106
00003e  6828              LDR      r0,[r5,#0]            ;3106
000040  f7fffffe          BL       get_fat
000044  1c41              ADDS     r1,r0,#1              ;3107
000046  d003              BEQ      |L13.80|
000048  2801              CMP      r0,#1                 ;3108
00004a  d003              BEQ      |L13.84|
00004c  b128              CBZ      r0,|L13.90|
00004e  e005              B        |L13.92|
                  |L13.80|
000050  2001              MOVS     r0,#1                 ;3107
000052  e000              B        |L13.86|
                  |L13.84|
000054  2002              MOVS     r0,#2                 ;3108
                  |L13.86|
000056  4680              MOV      r8,r0                 ;3108
000058  e029              B        |L13.174|
                  |L13.90|
00005a  1c64              ADDS     r4,r4,#1              ;3108
                  |L13.92|
00005c  6828              LDR      r0,[r5,#0]            ;3110
00005e  1c76              ADDS     r6,r6,#1              ;3110
000060  6980              LDR      r0,[r0,#0x18]         ;3110
000062  4286              CMP      r6,r0                 ;3110
000064  d3ea              BCC      |L13.60|
000066  e022              B        |L13.174|
                  |L13.104|
;;;3116   					if (!i) {
000068  b959              CBNZ     r1,|L13.130|
                  |L13.106|
;;;3117   						res = move_window(*fatfs, sect++);
00006a  4631              MOV      r1,r6
00006c  1c76              ADDS     r6,r6,#1
00006e  6828              LDR      r0,[r5,#0]
000070  f7fffffe          BL       move_window
000074  ea5f0800          MOVS     r8,r0
;;;3118   						if (res != FR_OK) break;
000078  d119              BNE      |L13.174|
;;;3119   						p = (*fatfs)->win;
;;;3120   						i = SS(*fatfs);
00007a  6828              LDR      r0,[r5,#0]
00007c  f44f7100          MOV      r1,#0x200
000080  3030              ADDS     r0,r0,#0x30
                  |L13.130|
;;;3121   					}
;;;3122   					if (fat == FS_FAT16) {
000082  f1b90f02          CMP      r9,#2
000086  d007              BEQ      |L13.152|
;;;3123   						if (LD_WORD(p) == 0) n++;
;;;3124   						p += 2; i -= 2;
;;;3125   					} else {
;;;3126   						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
000088  7802              LDRB     r2,[r0,#0]
00008a  f8d03001          LDR      r3,[r0,#1]
00008e  ea422203          ORR      r2,r2,r3,LSL #8
000092  0112              LSLS     r2,r2,#4
000094  d006              BEQ      |L13.164|
000096  e006              B        |L13.166|
                  |L13.152|
000098  8802              LDRH     r2,[r0,#0]            ;3123
00009a  b902              CBNZ     r2,|L13.158|
00009c  1c64              ADDS     r4,r4,#1              ;3123
                  |L13.158|
00009e  1c80              ADDS     r0,r0,#2              ;3123
0000a0  1e89              SUBS     r1,r1,#2              ;3123
0000a2  e002              B        |L13.170|
                  |L13.164|
0000a4  1c64              ADDS     r4,r4,#1              ;3124
                  |L13.166|
0000a6  1d00              ADDS     r0,r0,#4              ;3124
0000a8  1f09              SUBS     r1,r1,#4              ;3124
                  |L13.170|
0000aa  1e7f              SUBS     r7,r7,#1              ;3124
;;;3127   						p += 4; i -= 4;
;;;3128   					}
;;;3129   				} while (--clst);
0000ac  d1dc              BNE      |L13.104|
                  |L13.174|
;;;3130   			}
;;;3131   			(*fatfs)->free_clust = n;
0000ae  6828              LDR      r0,[r5,#0]
;;;3132   			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
0000b0  f1b90f03          CMP      r9,#3
0000b4  6104              STR      r4,[r0,#0x10]
0000b6  d102              BNE      |L13.190|
0000b8  6829              LDR      r1,[r5,#0]
0000ba  2001              MOVS     r0,#1
0000bc  7148              STRB     r0,[r1,#5]
                  |L13.190|
;;;3133   			*nclst = n;
0000be  f8ca4000          STR      r4,[r10,#0]
                  |L13.194|
;;;3134   		}
;;;3135   	}
;;;3136   	LEAVE_FF(*fatfs, res);
0000c2  4640              MOV      r0,r8
;;;3137   }
0000c4  e8bd8ffe          POP      {r1-r11,pc}
;;;3138   
                          ENDP


                          AREA ||i.f_lseek||, CODE, READONLY, ALIGN=1

                  f_lseek PROC
;;;2807   
;;;2808   FRESULT f_lseek (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2809   	FIL *fp,		/* Pointer to the file object */
;;;2810   	DWORD ofs		/* File pointer from top of file */
;;;2811   )
;;;2812   {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;2813   	FRESULT res;
;;;2814   
;;;2815   
;;;2816   	res = validate(fp->fs, fp->id);		/* Check validity of the object */
000008  8881              LDRH     r1,[r0,#4]
00000a  6800              LDR      r0,[r0,#0]
00000c  f7fffffe          BL       validate
000010  ea5f0800          MOVS     r8,r0
;;;2817   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000014  d103              BNE      |L14.30|
;;;2818   	if (fp->flag & FA__ERROR)			/* Check abort flag */
000016  79a1              LDRB     r1,[r4,#6]
000018  0608              LSLS     r0,r1,#24
00001a  d502              BPL      |L14.34|
                  |L14.28|
;;;2819   		LEAVE_FF(fp->fs, FR_INT_ERR);
00001c  2002              MOVS     r0,#2
                  |L14.30|
;;;2820   
;;;2821   #if _USE_FASTSEEK
;;;2822   	if (fp->cltbl) {	/* Fast seek */
;;;2823   		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
;;;2824   
;;;2825   		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
;;;2826   			tbl = fp->cltbl;
;;;2827   			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
;;;2828   			cl = fp->sclust;			/* Top of the chain */
;;;2829   			if (cl) {
;;;2830   				do {
;;;2831   					/* Get a fragment */
;;;2832   					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
;;;2833   					do {
;;;2834   						pcl = cl; ncl++;
;;;2835   						cl = get_fat(fp->fs, cl);
;;;2836   						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
;;;2837   						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2838   					} while (cl == pcl + 1);
;;;2839   					if (ulen <= tlen) {		/* Store the length and top of the fragment */
;;;2840   						*tbl++ = ncl; *tbl++ = tcl;
;;;2841   					}
;;;2842   				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
;;;2843   			}
;;;2844   			*fp->cltbl = ulen;	/* Number of items used */
;;;2845   			if (ulen <= tlen)
;;;2846   				*tbl = 0;		/* Terminate table */
;;;2847   			else
;;;2848   				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
;;;2849   
;;;2850   		} else {						/* Fast seek */
;;;2851   			if (ofs > fp->fsize)		/* Clip offset at the file size */
;;;2852   				ofs = fp->fsize;
;;;2853   			fp->fptr = ofs;				/* Set file pointer */
;;;2854   			if (ofs) {
;;;2855   				fp->clust = clmt_clust(fp, ofs - 1);
;;;2856   				dsc = clust2sect(fp->fs, fp->clust);
;;;2857   				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
;;;2858   				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
;;;2859   				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
;;;2860   #if !_FS_TINY
;;;2861   #if !_FS_READONLY
;;;2862   					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;2863   						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2864   							ABORT(fp->fs, FR_DISK_ERR);
;;;2865   						fp->flag &= ~FA__DIRTY;
;;;2866   					}
;;;2867   #endif
;;;2868   					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
;;;2869   						ABORT(fp->fs, FR_DISK_ERR);
;;;2870   #endif
;;;2871   					fp->dsect = dsc;
;;;2872   				}
;;;2873   			}
;;;2874   		}
;;;2875   	} else
;;;2876   #endif
;;;2877   
;;;2878   	/* Normal Seek */
;;;2879   	{
;;;2880   		DWORD clst, bcs, nsect, ifptr;
;;;2881   
;;;2882   		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
;;;2883   #if !_FS_READONLY
;;;2884   			 && !(fp->flag & FA_WRITE)
;;;2885   #endif
;;;2886   			) ofs = fp->fsize;
;;;2887   
;;;2888   		ifptr = fp->fptr;
;;;2889   		fp->fptr = nsect = 0;
;;;2890   		if (ofs) {
;;;2891   			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
;;;2892   			if (ifptr > 0 &&
;;;2893   				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
;;;2894   				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
;;;2895   				ofs -= fp->fptr;
;;;2896   				clst = fp->clust;
;;;2897   			} else {									/* When seek to back cluster, */
;;;2898   				clst = fp->sclust;						/* start from the first cluster */
;;;2899   #if !_FS_READONLY
;;;2900   				if (clst == 0) {						/* If no cluster chain, create a new chain */
;;;2901   					clst = create_chain(fp->fs, 0);
;;;2902   					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;2903   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2904   					fp->sclust = clst;
;;;2905   				}
;;;2906   #endif
;;;2907   				fp->clust = clst;
;;;2908   			}
;;;2909   			if (clst != 0) {
;;;2910   				while (ofs > bcs) {						/* Cluster following loop */
;;;2911   #if !_FS_READONLY
;;;2912   					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
;;;2913   						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
;;;2914   						if (clst == 0) {				/* When disk gets full, clip file size */
;;;2915   							ofs = bcs; break;
;;;2916   						}
;;;2917   					} else
;;;2918   #endif
;;;2919   						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
;;;2920   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2921   					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
;;;2922   					fp->clust = clst;
;;;2923   					fp->fptr += bcs;
;;;2924   					ofs -= bcs;
;;;2925   				}
;;;2926   				fp->fptr += ofs;
;;;2927   				if (ofs % SS(fp->fs)) {
;;;2928   					nsect = clust2sect(fp->fs, clst);	/* Current sector */
;;;2929   					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
;;;2930   					nsect += ofs / SS(fp->fs);
;;;2931   				}
;;;2932   			}
;;;2933   		}
;;;2934   		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
;;;2935   #if !_FS_TINY
;;;2936   #if !_FS_READONLY
;;;2937   			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
;;;2938   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2939   					ABORT(fp->fs, FR_DISK_ERR);
;;;2940   				fp->flag &= ~FA__DIRTY;
;;;2941   			}
;;;2942   #endif
;;;2943   			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
;;;2944   				ABORT(fp->fs, FR_DISK_ERR);
;;;2945   #endif
;;;2946   			fp->dsect = nsect;
;;;2947   		}
;;;2948   #if !_FS_READONLY
;;;2949   		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
;;;2950   			fp->fsize = fp->fptr;
;;;2951   			fp->flag |= FA__WRITTEN;
;;;2952   		}
;;;2953   #endif
;;;2954   	}
;;;2955   
;;;2956   	LEAVE_FF(fp->fs, res);
;;;2957   }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L14.34|
000022  68e0              LDR      r0,[r4,#0xc]          ;2882
000024  42a8              CMP      r0,r5                 ;2882
000026  d202              BCS      |L14.46|
000028  0789              LSLS     r1,r1,#30             ;2884
00002a  d400              BMI      |L14.46|
00002c  4605              MOV      r5,r0                 ;2886
                  |L14.46|
00002e  2700              MOVS     r7,#0                 ;2889
000030  68a0              LDR      r0,[r4,#8]            ;2889
000032  60a7              STR      r7,[r4,#8]            ;2890
000034  b1fd              CBZ      r5,|L14.118|
000036  6822              LDR      r2,[r4,#0]            ;2891
000038  7891              LDRB     r1,[r2,#2]            ;2891
00003a  024e              LSLS     r6,r1,#9              ;2891
00003c  b168              CBZ      r0,|L14.90|
00003e  1e69              SUBS     r1,r5,#1              ;2893
000040  1e40              SUBS     r0,r0,#1              ;2893
000042  fbb1f1f6          UDIV     r1,r1,r6              ;2893
000046  fbb0f3f6          UDIV     r3,r0,r6              ;2893
00004a  4299              CMP      r1,r3                 ;2893
00004c  d305              BCC      |L14.90|
00004e  1e71              SUBS     r1,r6,#1              ;2894
000050  4388              BICS     r0,r0,r1              ;2894
000052  60a0              STR      r0,[r4,#8]            ;2896
000054  1a2d              SUBS     r5,r5,r0              ;2895
000056  6961              LDR      r1,[r4,#0x14]         ;2896
000058  e00c              B        |L14.116|
                  |L14.90|
00005a  6921              LDR      r1,[r4,#0x10]         ;2900
00005c  b949              CBNZ     r1,|L14.114|
00005e  2100              MOVS     r1,#0                 ;2901
000060  4610              MOV      r0,r2                 ;2901
000062  f7fffffe          BL       create_chain
000066  4601              MOV      r1,r0                 ;2901
000068  2801              CMP      r0,#1                 ;2902
00006a  d03f              BEQ      |L14.236|
00006c  1c48              ADDS     r0,r1,#1              ;2903
00006e  d04e              BEQ      |L14.270|
000070  6121              STR      r1,[r4,#0x10]         ;2904
                  |L14.114|
000072  6161              STR      r1,[r4,#0x14]         ;2907
                  |L14.116|
000074  b9d1              CBNZ     r1,|L14.172|
                  |L14.118|
000076  e026              B        |L14.198|
                  |L14.120|
000078  79a0              LDRB     r0,[r4,#6]            ;2912
00007a  0780              LSLS     r0,r0,#30             ;2912
00007c  6820              LDR      r0,[r4,#0]            ;2912
00007e  d505              BPL      |L14.140|
000080  f7fffffe          BL       create_chain
000084  0001              MOVS     r1,r0                 ;2913
000086  d104              BNE      |L14.146|
000088  4635              MOV      r5,r6                 ;2915
00008a  e011              B        |L14.176|
                  |L14.140|
00008c  f7fffffe          BL       get_fat
000090  4601              MOV      r1,r0                 ;2919
                  |L14.146|
000092  1c48              ADDS     r0,r1,#1              ;2920
000094  d03b              BEQ      |L14.270|
000096  2901              CMP      r1,#1                 ;2921
000098  d928              BLS      |L14.236|
00009a  6820              LDR      r0,[r4,#0]            ;2921
00009c  6980              LDR      r0,[r0,#0x18]         ;2921
00009e  4288              CMP      r0,r1                 ;2921
0000a0  d924              BLS      |L14.236|
0000a2  6161              STR      r1,[r4,#0x14]         ;2923
0000a4  68a0              LDR      r0,[r4,#8]            ;2923
0000a6  1bad              SUBS     r5,r5,r6              ;2924
0000a8  4430              ADD      r0,r0,r6              ;2923
0000aa  60a0              STR      r0,[r4,#8]            ;2924
                  |L14.172|
0000ac  42b5              CMP      r5,r6                 ;2910
0000ae  d8e3              BHI      |L14.120|
                  |L14.176|
0000b0  68a0              LDR      r0,[r4,#8]            ;2926
0000b2  4428              ADD      r0,r0,r5              ;2926
0000b4  60a0              STR      r0,[r4,#8]            ;2927
0000b6  05e8              LSLS     r0,r5,#23             ;2927
0000b8  d005              BEQ      |L14.198|
0000ba  6820              LDR      r0,[r4,#0]            ;2928
0000bc  f7fffffe          BL       clust2sect
0000c0  b1a0              CBZ      r0,|L14.236|
0000c2  eb002755          ADD      r7,r0,r5,LSR #9       ;2930
                  |L14.198|
0000c6  8920              LDRH     r0,[r4,#8]            ;2934
0000c8  05c0              LSLS     r0,r0,#23             ;2934
0000ca  d027              BEQ      |L14.284|
0000cc  69a2              LDR      r2,[r4,#0x18]         ;2934
0000ce  42ba              CMP      r2,r7                 ;2934
0000d0  d024              BEQ      |L14.284|
0000d2  79a0              LDRB     r0,[r4,#6]            ;2937
0000d4  f1040524          ADD      r5,r4,#0x24           ;2938
0000d8  0640              LSLS     r0,r0,#25             ;2937
0000da  d510              BPL      |L14.254|
0000dc  6820              LDR      r0,[r4,#0]            ;2938
0000de  2301              MOVS     r3,#1                 ;2938
0000e0  4629              MOV      r1,r5                 ;2938
0000e2  7840              LDRB     r0,[r0,#1]            ;2938
0000e4  f7fffffe          BL       disk_write
0000e8  b988              CBNZ     r0,|L14.270|
0000ea  e004              B        |L14.246|
                  |L14.236|
0000ec  79a0              LDRB     r0,[r4,#6]            ;2929
0000ee  f0400080          ORR      r0,r0,#0x80           ;2929
0000f2  71a0              STRB     r0,[r4,#6]            ;2929
0000f4  e792              B        |L14.28|
                  |L14.246|
0000f6  79a0              LDRB     r0,[r4,#6]            ;2940
0000f8  f0200040          BIC      r0,r0,#0x40           ;2940
0000fc  71a0              STRB     r0,[r4,#6]            ;2940
                  |L14.254|
0000fe  6820              LDR      r0,[r4,#0]            ;2943
000100  2301              MOVS     r3,#1                 ;2943
000102  463a              MOV      r2,r7                 ;2943
000104  7840              LDRB     r0,[r0,#1]            ;2943
000106  4629              MOV      r1,r5                 ;2943
000108  f7fffffe          BL       disk_read
00010c  b128              CBZ      r0,|L14.282|
                  |L14.270|
00010e  79a0              LDRB     r0,[r4,#6]            ;2944
000110  f0400080          ORR      r0,r0,#0x80           ;2944
000114  71a0              STRB     r0,[r4,#6]            ;2944
000116  2001              MOVS     r0,#1                 ;2944
000118  e781              B        |L14.30|
                  |L14.282|
00011a  61a7              STR      r7,[r4,#0x18]         ;2946
                  |L14.284|
00011c  e9d40102          LDRD     r0,r1,[r4,#8]         ;2946
000120  4288              CMP      r0,r1                 ;2949
000122  d904              BLS      |L14.302|
000124  60e0              STR      r0,[r4,#0xc]          ;2951
000126  79a0              LDRB     r0,[r4,#6]            ;2951
000128  f0400020          ORR      r0,r0,#0x20           ;2951
00012c  71a0              STRB     r0,[r4,#6]            ;2951
                  |L14.302|
00012e  4640              MOV      r0,r8                 ;2956
000130  e775              B        |L14.30|
;;;2958   
                          ENDP


                          AREA ||i.f_mkdir||, CODE, READONLY, ALIGN=1

                  f_mkdir PROC
;;;3261   
;;;3262   FRESULT f_mkdir (
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;3263   	const TCHAR *path		/* Pointer to the directory path */
;;;3264   )
;;;3265   {
000004  b090              SUB      sp,sp,#0x40
;;;3266   	FRESULT res;
;;;3267   	DIR dj;
;;;3268   	BYTE *dir, n;
;;;3269   	DWORD dsc, dcl, pcl, tim = get_fattime();
000006  f7fffffe          BL       get_fattime
00000a  4607              MOV      r7,r0
;;;3270   	DEF_NAMEBUF;
;;;3271   
;;;3272   
;;;3273   	res = chk_mounted(&path, &dj.fs, 1);
00000c  2201              MOVS     r2,#1
00000e  4669              MOV      r1,sp
000010  a810              ADD      r0,sp,#0x40
000012  f7fffffe          BL       chk_mounted
000016  0004              MOVS     r4,r0
;;;3274   	if (res == FR_OK) {
000018  d109              BNE      |L15.46|
;;;3275   		INIT_BUF(dj);
00001a  a80d              ADD      r0,sp,#0x34
;;;3276   		res = follow_path(&dj, path);			/* Follow the file path */
00001c  9006              STR      r0,[sp,#0x18]
00001e  4668              MOV      r0,sp
000020  9910              LDR      r1,[sp,#0x40]
000022  f7fffffe          BL       follow_path
000026  0004              MOVS     r4,r0
;;;3277   		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
000028  d002              BEQ      |L15.48|
;;;3278   		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
;;;3279   			res = FR_INVALID_NAME;
;;;3280   		if (res == FR_NO_FILE) {				/* Can create a new directory */
00002a  2c04              CMP      r4,#4
00002c  d002              BEQ      |L15.52|
                  |L15.46|
00002e  e0ac              B        |L15.394|
                  |L15.48|
000030  2408              MOVS     r4,#8                 ;3277
000032  e0aa              B        |L15.394|
                  |L15.52|
;;;3281   			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
000034  2100              MOVS     r1,#0
000036  9800              LDR      r0,[sp,#0]
000038  f7fffffe          BL       create_chain
00003c  0006              MOVS     r6,r0
;;;3282   			res = FR_OK;
00003e  f04f0400          MOV      r4,#0
;;;3283   			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
000042  d002              BEQ      |L15.74|
;;;3284   			if (dcl == 1) res = FR_INT_ERR;
000044  2e01              CMP      r6,#1
000046  d002              BEQ      |L15.78|
000048  e002              B        |L15.80|
                  |L15.74|
00004a  2407              MOVS     r4,#7                 ;3283
00004c  e000              B        |L15.80|
                  |L15.78|
00004e  2402              MOVS     r4,#2
                  |L15.80|
;;;3285   			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
000050  1c70              ADDS     r0,r6,#1
000052  d001              BEQ      |L15.88|
;;;3286   			if (res == FR_OK)					/* Flush FAT */
000054  b114              CBZ      r4,|L15.92|
000056  e079              B        |L15.332|
                  |L15.88|
000058  2401              MOVS     r4,#1                 ;3285
00005a  e077              B        |L15.332|
                  |L15.92|
;;;3287   				res = move_window(dj.fs, 0);
00005c  2100              MOVS     r1,#0
00005e  9800              LDR      r0,[sp,#0]
000060  f7fffffe          BL       move_window
000064  0004              MOVS     r4,r0
000066  d171              BNE      |L15.332|
;;;3288   			if (res == FR_OK) {					/* Initialize the new directory table */
;;;3289   				dsc = clust2sect(dj.fs, dcl);
000068  4631              MOV      r1,r6
00006a  9800              LDR      r0,[sp,#0]
00006c  f7fffffe          BL       clust2sect
;;;3290   				dir = dj.fs->win;
;;;3291   				mem_set(dir, 0, SS(dj.fs));
000070  9d00              LDR      r5,[sp,#0]
000072  4680              MOV      r8,r0                 ;3289
000074  3530              ADDS     r5,r5,#0x30
000076  f44f7200          MOV      r2,#0x200
00007a  2100              MOVS     r1,#0
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       mem_set
;;;3292   				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
000082  220b              MOVS     r2,#0xb
000084  2120              MOVS     r1,#0x20
000086  4628              MOV      r0,r5
000088  f7fffffe          BL       mem_set
;;;3293   				dir[DIR_Name] = '.';
00008c  242e              MOVS     r4,#0x2e
00008e  702c              STRB     r4,[r5,#0]
;;;3294   				dir[DIR_Attr] = AM_DIR;
000090  2010              MOVS     r0,#0x10
000092  72e8              STRB     r0,[r5,#0xb]
;;;3295   				ST_DWORD(dir+DIR_WrtTime, tim);
000094  b2f8              UXTB     r0,r7
000096  900c              STR      r0,[sp,#0x30]
000098  75a8              STRB     r0,[r5,#0x16]
00009a  f3c72007          UBFX     r0,r7,#8,#8
00009e  900b              STR      r0,[sp,#0x2c]
0000a0  75e8              STRB     r0,[r5,#0x17]
0000a2  f3c74007          UBFX     r0,r7,#16,#8
0000a6  900a              STR      r0,[sp,#0x28]
0000a8  7628              STRB     r0,[r5,#0x18]
0000aa  0e38              LSRS     r0,r7,#24
0000ac  9009              STR      r0,[sp,#0x24]
0000ae  7668              STRB     r0,[r5,#0x19]
;;;3296   				ST_CLUST(dir, dcl);
0000b0  b2f0              UXTB     r0,r6
0000b2  9008              STR      r0,[sp,#0x20]
0000b4  76a8              STRB     r0,[r5,#0x1a]
0000b6  f3c62007          UBFX     r0,r6,#8,#8
0000ba  9007              STR      r0,[sp,#0x1c]
0000bc  76e8              STRB     r0,[r5,#0x1b]
0000be  f3c64b07          UBFX     r11,r6,#16,#8
0000c2  f885b014          STRB     r11,[r5,#0x14]
0000c6  ea4f6a16          LSR      r10,r6,#24
0000ca  f885a015          STRB     r10,[r5,#0x15]
;;;3297   				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
0000ce  2220              MOVS     r2,#0x20
0000d0  4629              MOV      r1,r5
0000d2  f1050020          ADD      r0,r5,#0x20
0000d6  f7fffffe          BL       mem_cpy
;;;3298   				dir[33] = '.'; pcl = dj.sclust;
0000da  f8854021          STRB     r4,[r5,#0x21]
;;;3299   				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
0000de  9900              LDR      r1,[sp,#0]
0000e0  9802              LDR      r0,[sp,#8]
0000e2  7809              LDRB     r1,[r1,#0]
0000e4  2903              CMP      r1,#3
0000e6  d104              BNE      |L15.242|
0000e8  9900              LDR      r1,[sp,#0]
0000ea  6a49              LDR      r1,[r1,#0x24]
0000ec  4281              CMP      r1,r0
0000ee  d100              BNE      |L15.242|
;;;3300   					pcl = 0;
0000f0  2000              MOVS     r0,#0
                  |L15.242|
;;;3301   				ST_CLUST(dir+SZ_DIR, pcl);
0000f2  f885003a          STRB     r0,[r5,#0x3a]
0000f6  0a01              LSRS     r1,r0,#8
0000f8  f885103b          STRB     r1,[r5,#0x3b]
0000fc  0c01              LSRS     r1,r0,#16
0000fe  f8851034          STRB     r1,[r5,#0x34]
000102  0e00              LSRS     r0,r0,#24
000104  f8850035          STRB     r0,[r5,#0x35]
;;;3302   				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
000108  9800              LDR      r0,[sp,#0]
00010a  f04f0901          MOV      r9,#1                 ;3273
00010e  7887              LDRB     r7,[r0,#2]
000110  e015              B        |L15.318|
                  |L15.274|
;;;3303   					dj.fs->winsect = dsc++;
000112  9900              LDR      r1,[sp,#0]
000114  f8c1802c          STR      r8,[r1,#0x2c]
;;;3304   					dj.fs->wflag = 1;
000118  9900              LDR      r1,[sp,#0]
00011a  f1080801          ADD      r8,r8,#1              ;3303
00011e  f8819004          STRB     r9,[r1,#4]
;;;3305   					res = move_window(dj.fs, 0);
000122  2100              MOVS     r1,#0
000124  9800              LDR      r0,[sp,#0]
000126  f7fffffe          BL       move_window
00012a  0004              MOVS     r4,r0
;;;3306   					if (res != FR_OK) break;
00012c  d10e              BNE      |L15.332|
;;;3307   					mem_set(dir, 0, SS(dj.fs));
00012e  f44f7200          MOV      r2,#0x200
000132  2100              MOVS     r1,#0
000134  4628              MOV      r0,r5
000136  f7fffffe          BL       mem_set
00013a  1e7f              SUBS     r7,r7,#1
00013c  b2ff              UXTB     r7,r7                 ;3302
                  |L15.318|
00013e  2f00              CMP      r7,#0                 ;3302
000140  d1e7              BNE      |L15.274|
;;;3308   				}
;;;3309   			}
;;;3310   			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
000142  4668              MOV      r0,sp
000144  f7fffffe          BL       dir_register
000148  0004              MOVS     r4,r0
00014a  d004              BEQ      |L15.342|
                  |L15.332|
;;;3311   			if (res != FR_OK) {
;;;3312   				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
00014c  4631              MOV      r1,r6
00014e  9800              LDR      r0,[sp,#0]
000150  f7fffffe          BL       remove_chain
000154  e019              B        |L15.394|
                  |L15.342|
;;;3313   			} else {
;;;3314   				dir = dj.dir;
;;;3315   				dir[DIR_Attr] = AM_DIR;				/* Attribute */
000156  9805              LDR      r0,[sp,#0x14]
000158  2110              MOVS     r1,#0x10
00015a  72c1              STRB     r1,[r0,#0xb]
;;;3316   				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
00015c  990c              LDR      r1,[sp,#0x30]
00015e  7581              STRB     r1,[r0,#0x16]
000160  990b              LDR      r1,[sp,#0x2c]
000162  75c1              STRB     r1,[r0,#0x17]
000164  990a              LDR      r1,[sp,#0x28]
000166  7601              STRB     r1,[r0,#0x18]
000168  9909              LDR      r1,[sp,#0x24]
00016a  7641              STRB     r1,[r0,#0x19]
;;;3317   				ST_CLUST(dir, dcl);					/* Table start cluster */
00016c  9908              LDR      r1,[sp,#0x20]
00016e  7681              STRB     r1,[r0,#0x1a]
000170  9907              LDR      r1,[sp,#0x1c]
000172  76c1              STRB     r1,[r0,#0x1b]
000174  f880b014          STRB     r11,[r0,#0x14]
000178  f880a015          STRB     r10,[r0,#0x15]
;;;3318   				dj.fs->wflag = 1;
00017c  9900              LDR      r1,[sp,#0]
00017e  f8819004          STRB     r9,[r1,#4]
;;;3319   				res = sync(dj.fs);
000182  9800              LDR      r0,[sp,#0]
000184  f7fffffe          BL       sync
000188  4604              MOV      r4,r0
                  |L15.394|
;;;3320   			}
;;;3321   		}
;;;3322   		FREE_BUF();
;;;3323   	}
;;;3324   
;;;3325   	LEAVE_FF(dj.fs, res);
;;;3326   }
00018a  b011              ADD      sp,sp,#0x44
00018c  4620              MOV      r0,r4                 ;3325
00018e  e8bd8ff0          POP      {r4-r11,pc}
;;;3327   
                          ENDP


                          AREA ||i.f_mkfs||, CODE, READONLY, ALIGN=2

                  f_mkfs PROC
;;;3559   //在驱动器创建一个文件系统（驱动器号，分区规则（0:FDISK, 1:SFD），分配的单元大小）
;;;3560   FRESULT f_mkfs (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3561   	BYTE drv,		/* Logical drive number */
;;;3562   	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
;;;3563   	UINT au			/* Allocation unit size [bytes] */
;;;3564   )
;;;3565   {
000004  b086              SUB      sp,sp,#0x18
000006  4615              MOV      r5,r2
000008  b118              CBZ      r0,|L16.18|
;;;3566   	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
;;;3567   	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
;;;3568   	BYTE fmt, md, sys, *tbl, pdrv, part;
;;;3569   	DWORD n_clst, vs, n, wsect;
;;;3570   	UINT i;
;;;3571   	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
;;;3572   	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
;;;3573   	FATFS *fs;
;;;3574   	DSTATUS stat;
;;;3575   
;;;3576   
;;;3577   	/* Check mounted drive and clear work area */
;;;3578   	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
00000a  200b              MOVS     r0,#0xb
                  |L16.12|
;;;3579   	if (sfd > 1) return FR_INVALID_PARAMETER;
;;;3580   	if (au & (au - 1)) return FR_INVALID_PARAMETER;
;;;3581   	fs = FatFs[drv];
;;;3582   	if (!fs) return FR_NOT_ENABLED;
;;;3583   	fs->fs_type = 0;
;;;3584   	pdrv = LD2PD(drv);	/* Physical drive */
;;;3585   	part = LD2PT(drv);	/* Partition (0:auto detect, 1-4:get from partition table)*/
;;;3586   
;;;3587   	/* Get disk statics */
;;;3588   	stat = disk_initialize(pdrv);
;;;3589   	if (stat & STA_NOINIT) return FR_NOT_READY;
;;;3590   	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
;;;3591   #if _MAX_SS != 512					/* Get disk sector size */
;;;3592   	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
;;;3593   		return FR_DISK_ERR;
;;;3594   #endif
;;;3595   	if (_MULTI_PARTITION && part) {
;;;3596   		/* Get partition information from partition table in the MBR */
;;;3597   		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
;;;3598   		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
;;;3599   		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
;;;3600   		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
;;;3601   		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
;;;3602   		n_vol = LD_DWORD(tbl+12);	/* Volume size */
;;;3603   	} else {
;;;3604   		/* Create a partition in this function */
;;;3605   		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
;;;3606   			return FR_DISK_ERR;
;;;3607   		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
;;;3608   		n_vol -= b_vol;				/* Volume size */
;;;3609   	}
;;;3610   
;;;3611   	if (!au) {				/* AU auto selection */
;;;3612   		vs = n_vol / (2000 / (SS(fs) / 512));
;;;3613   		for (i = 0; vs < vst[i]; i++) ;
;;;3614   		au = cst[i];
;;;3615   	}
;;;3616   	au /= SS(fs);		/* Number of sectors per cluster */
;;;3617   	if (au == 0) au = 1;
;;;3618   	if (au > 128) au = 128;
;;;3619   
;;;3620   	/* Pre-compute number of clusters and FAT syb-type */
;;;3621   	n_clst = n_vol / au;
;;;3622   	fmt = FS_FAT12;
;;;3623   	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
;;;3624   	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
;;;3625   
;;;3626   	/* Determine offset and size of FAT structure */
;;;3627   	if (fmt == FS_FAT32) {
;;;3628   		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
;;;3629   		n_rsv = 32;
;;;3630   		n_dir = 0;
;;;3631   	} else {
;;;3632   		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
;;;3633   		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
;;;3634   		n_rsv = 1;
;;;3635   		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
;;;3636   	}
;;;3637   	b_fat = b_vol + n_rsv;				/* FAT area start sector */
;;;3638   	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
;;;3639   	b_data = b_dir + n_dir;				/* Data area start sector */
;;;3640   	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
;;;3641   
;;;3642   	/* Align data start sector to erase block boundary (for flash memory media) */
;;;3643   	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
;;;3644   	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
;;;3645   	n = (n - b_data) / N_FATS;
;;;3646   	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
;;;3647   		n_rsv += n;
;;;3648   		b_fat += n;
;;;3649   	} else {					/* FAT12/16: Expand FAT size */
;;;3650   		n_fat += n;
;;;3651   	}
;;;3652   
;;;3653   	/* Determine number of clusters and final check of validity of the FAT sub-type */
;;;3654   	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
;;;3655   	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
;;;3656   		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
;;;3657   		return FR_MKFS_ABORTED;
;;;3658   
;;;3659   	switch (fmt) {	/* Determine system ID for partition table */
;;;3660   	case FS_FAT12:	sys = 0x01; break;
;;;3661   	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
;;;3662   	default: 		sys = 0x0C;
;;;3663   	}
;;;3664   
;;;3665   	if (_MULTI_PARTITION && part) {
;;;3666   		/* Update system ID in the partition table */
;;;3667   		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
;;;3668   		tbl[4] = sys;
;;;3669   		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
;;;3670   		md = 0xF8;
;;;3671   	} else {
;;;3672   		if (sfd) {	/* No patition table (SFD) */
;;;3673   			md = 0xF0;
;;;3674   		} else {	/* Create partition table (FDISK) */
;;;3675   			mem_set(fs->win, 0, SS(fs));
;;;3676   			tbl = fs->win+MBR_Table;	/* Create partiton table for single partition in the drive */
;;;3677   			tbl[1] = 1;						/* Partition start head */
;;;3678   			tbl[2] = 1;						/* Partition start sector */
;;;3679   			tbl[3] = 0;						/* Partition start cylinder */
;;;3680   			tbl[4] = sys;					/* System type */
;;;3681   			tbl[5] = 254;					/* Partition end head */
;;;3682   			n = (b_vol + n_vol) / 63 / 255;
;;;3683   			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partiiton end sector */
;;;3684   			tbl[7] = (BYTE)n;				/* End cylinder */
;;;3685   			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
;;;3686   			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
;;;3687   			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
;;;3688   			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
;;;3689   				return FR_DISK_ERR;
;;;3690   			md = 0xF8;
;;;3691   		}
;;;3692   	}
;;;3693   
;;;3694   	/* Create BPB in the VBR */
;;;3695   	tbl = fs->win;							/* Clear sector */
;;;3696   	mem_set(tbl, 0, SS(fs));
;;;3697   	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
;;;3698   	i = SS(fs);								/* Sector size */
;;;3699   	ST_WORD(tbl+BPB_BytsPerSec, i);
;;;3700   	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
;;;3701   	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
;;;3702   	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
;;;3703   	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
;;;3704   	ST_WORD(tbl+BPB_RootEntCnt, i);
;;;3705   	if (n_vol < 0x10000) {					/* Number of total sectors */
;;;3706   		ST_WORD(tbl+BPB_TotSec16, n_vol);
;;;3707   	} else {
;;;3708   		ST_DWORD(tbl+BPB_TotSec32, n_vol);
;;;3709   	}
;;;3710   	tbl[BPB_Media] = md;					/* Media descriptor */
;;;3711   	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
;;;3712   	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
;;;3713   	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
;;;3714   	n = get_fattime();						/* Use current time as VSN */
;;;3715   	if (fmt == FS_FAT32) {
;;;3716   		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
;;;3717   		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
;;;3718   		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
;;;3719   		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
;;;3720   		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
;;;3721   		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
;;;3722   		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
;;;3723   		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
;;;3724   	} else {
;;;3725   		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
;;;3726   		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
;;;3727   		tbl[BS_DrvNum] = 0x80;				/* Drive number */
;;;3728   		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
;;;3729   		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
;;;3730   	}
;;;3731   	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
;;;3732   	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
;;;3733   		return FR_DISK_ERR;
;;;3734   	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
;;;3735   		disk_write(pdrv, tbl, b_vol + 6, 1);
;;;3736   
;;;3737   	/* Initialize FAT area */
;;;3738   	wsect = b_fat;
;;;3739   	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
;;;3740   		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
;;;3741   		n = md;								/* Media descriptor byte */
;;;3742   		if (fmt != FS_FAT32) {
;;;3743   			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
;;;3744   			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
;;;3745   		} else {
;;;3746   			n |= 0xFFFFFF00;
;;;3747   			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
;;;3748   			ST_DWORD(tbl+4, 0xFFFFFFFF);
;;;3749   			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
;;;3750   		}
;;;3751   		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;3752   			return FR_DISK_ERR;
;;;3753   		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
;;;3754   		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
;;;3755   			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;3756   				return FR_DISK_ERR;
;;;3757   		}
;;;3758   	}
;;;3759   
;;;3760   	/* Initialize root directory */
;;;3761   	i = (fmt == FS_FAT32) ? au : n_dir;
;;;3762   	do {
;;;3763   		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;3764   			return FR_DISK_ERR;
;;;3765   	} while (--i);
;;;3766   
;;;3767   #if _USE_ERASE	/* Erase data area if needed */
;;;3768   	{
;;;3769   		DWORD eb[2];
;;;3770   
;;;3771   		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
;;;3772   		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
;;;3773   	}
;;;3774   #endif
;;;3775   
;;;3776   	/* Create FSInfo if needed */
;;;3777   	if (fmt == FS_FAT32) {
;;;3778   		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
;;;3779   		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
;;;3780   		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
;;;3781   		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
;;;3782   		ST_WORD(tbl+BS_55AA, 0xAA55);
;;;3783   		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
;;;3784   		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
;;;3785   	}
;;;3786   
;;;3787   	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
;;;3788   }
00000c  b009              ADD      sp,sp,#0x24
00000e  e8bd8ff0          POP      {r4-r11,pc}
                  |L16.18|
000012  9807              LDR      r0,[sp,#0x1c]         ;3579
000014  2801              CMP      r0,#1                 ;3579
000016  d802              BHI      |L16.30|
000018  1e68              SUBS     r0,r5,#1              ;3580
00001a  4205              TST      r5,r0                 ;3580
00001c  d001              BEQ      |L16.34|
                  |L16.30|
00001e  2013              MOVS     r0,#0x13              ;3580
                  |L16.32|
000020  e7f4              B        |L16.12|
                  |L16.34|
000022  48f8              LDR      r0,|L16.1028|
000024  6804              LDR      r4,[r0,#0]            ;3582
000026  b144              CBZ      r4,|L16.58|
000028  2000              MOVS     r0,#0                 ;3583
00002a  7020              STRB     r0,[r4,#0]            ;3583
00002c  9003              STR      r0,[sp,#0xc]          ;3588
00002e  f7fffffe          BL       disk_initialize
000032  07c1              LSLS     r1,r0,#31             ;3589
000034  d003              BEQ      |L16.62|
000036  2003              MOVS     r0,#3                 ;3589
000038  e7e8              B        |L16.12|
                  |L16.58|
00003a  200c              MOVS     r0,#0xc               ;3582
00003c  e7e6              B        |L16.12|
                  |L16.62|
00003e  0740              LSLS     r0,r0,#29             ;3590
000040  d501              BPL      |L16.70|
000042  200a              MOVS     r0,#0xa               ;3590
000044  e7e2              B        |L16.12|
                  |L16.70|
000046  aa04              ADD      r2,sp,#0x10           ;3605
000048  2101              MOVS     r1,#1                 ;3605
00004a  9803              LDR      r0,[sp,#0xc]          ;3605
00004c  f7fffffe          BL       disk_ioctl
000050  2800              CMP      r0,#0                 ;3605
000052  d17d              BNE      |L16.336|
000054  9904              LDR      r1,[sp,#0x10]         ;3605
000056  2980              CMP      r1,#0x80              ;3605
000058  d37a              BCC      |L16.336|
00005a  9807              LDR      r0,[sp,#0x1c]         ;3607
00005c  b108              CBZ      r0,|L16.98|
00005e  2000              MOVS     r0,#0                 ;3607
000060  e000              B        |L16.100|
                  |L16.98|
000062  203f              MOVS     r0,#0x3f              ;3607
                  |L16.100|
000064  4680              MOV      r8,r0                 ;3607
000066  eba10108          SUB      r1,r1,r8              ;3608
00006a  9104              STR      r1,[sp,#0x10]         ;3608
00006c  b97d              CBNZ     r5,|L16.142|
00006e  f44f60fa          MOV      r0,#0x7d0             ;3612
000072  fbb1f2f0          UDIV     r2,r1,r0              ;3612
000076  2000              MOVS     r0,#0                 ;3613
000078  4be3              LDR      r3,|L16.1032|
00007a  e000              B        |L16.126|
                  |L16.124|
00007c  1c40              ADDS     r0,r0,#1              ;3613
                  |L16.126|
00007e  f8335010          LDRH     r5,[r3,r0,LSL #1]     ;3613
000082  4295              CMP      r5,r2                 ;3613
000084  d8fa              BHI      |L16.124|
000086  4ae0              LDR      r2,|L16.1032|
000088  3216              ADDS     r2,r2,#0x16           ;3614
00008a  f8325010          LDRH     r5,[r2,r0,LSL #1]     ;3614
                  |L16.142|
00008e  0a68              LSRS     r0,r5,#9              ;3616
000090  ea5f0900          MOVS     r9,r0                 ;3616
000094  d012              BEQ      |L16.188|
000096  f1b90f80          CMP      r9,#0x80              ;3618
00009a  d901              BLS      |L16.160|
00009c  2080              MOVS     r0,#0x80              ;3618
                  |L16.158|
00009e  4681              MOV      r9,r0                 ;3617
                  |L16.160|
0000a0  fbb1f0f9          UDIV     r0,r1,r9              ;3621
0000a4  2601              MOVS     r6,#1                 ;3622
0000a6  f64072f6          MOV      r2,#0xff6             ;3623
0000aa  4290              CMP      r0,r2                 ;3623
0000ac  d300              BCC      |L16.176|
0000ae  2602              MOVS     r6,#2                 ;3623
                  |L16.176|
0000b0  f64f72f6          MOV      r2,#0xfff6            ;3624
0000b4  4290              CMP      r0,r2                 ;3624
0000b6  d303              BCC      |L16.192|
0000b8  2603              MOVS     r6,#3                 ;3624
0000ba  e020              B        |L16.254|
                  |L16.188|
0000bc  2001              MOVS     r0,#1                 ;3617
0000be  e7ee              B        |L16.158|
                  |L16.192|
0000c0  2e03              CMP      r6,#3                 ;3627
0000c2  d01c              BEQ      |L16.254|
0000c4  2e01              CMP      r6,#1                 ;3632
0000c6  d022              BEQ      |L16.270|
0000c8  0040              LSLS     r0,r0,#1              ;3632
0000ca  1d00              ADDS     r0,r0,#4              ;3632
                  |L16.204|
0000cc  f20010ff          ADD      r0,r0,#0x1ff          ;3632
0000d0  0a47              LSRS     r7,r0,#9              ;3633
0000d2  2501              MOVS     r5,#1                 ;3634
0000d4  2020              MOVS     r0,#0x20              ;3635
                  |L16.214|
0000d6  4683              MOV      r11,r0                ;3635
0000d8  eb080a05          ADD      r10,r8,r5             ;3637
0000dc  eb0a0007          ADD      r0,r10,r7             ;3638
0000e0  4458              ADD      r0,r0,r11             ;3639
0000e2  eb000209          ADD      r2,r0,r9              ;3640
0000e6  9000              STR      r0,[sp,#0]            ;3640
0000e8  eba20008          SUB      r0,r2,r8              ;3640
0000ec  4288              CMP      r0,r1                 ;3640
0000ee  d83f              BHI      |L16.368|
0000f0  aa01              ADD      r2,sp,#4              ;3643
0000f2  2103              MOVS     r1,#3                 ;3643
0000f4  9803              LDR      r0,[sp,#0xc]          ;3643
0000f6  f7fffffe          BL       disk_ioctl
0000fa  b998              CBNZ     r0,|L16.292|
0000fc  e00d              B        |L16.282|
                  |L16.254|
0000fe  f2402207          MOV      r2,#0x207             ;3628
000102  eb020080          ADD      r0,r2,r0,LSL #2       ;3628
000106  0a47              LSRS     r7,r0,#9              ;3628
000108  2520              MOVS     r5,#0x20              ;3629
00010a  2000              MOVS     r0,#0                 ;3630
00010c  e7e3              B        |L16.214|
                  |L16.270|
00010e  eb000040          ADD      r0,r0,r0,LSL #1       ;3632
000112  1c40              ADDS     r0,r0,#1              ;3632
000114  0840              LSRS     r0,r0,#1              ;3632
000116  1cc0              ADDS     r0,r0,#3              ;3632
000118  e7d8              B        |L16.204|
                  |L16.282|
00011a  9801              LDR      r0,[sp,#4]            ;3643
00011c  b110              CBZ      r0,|L16.292|
00011e  f5b04f00          CMP      r0,#0x8000            ;3643
000122  d901              BLS      |L16.296|
                  |L16.292|
000124  2001              MOVS     r0,#1                 ;3643
000126  9001              STR      r0,[sp,#4]            ;3643
                  |L16.296|
000128  9900              LDR      r1,[sp,#0]            ;3644
00012a  4401              ADD      r1,r1,r0              ;3644
00012c  1e40              SUBS     r0,r0,#1              ;3644
00012e  1e49              SUBS     r1,r1,#1              ;3644
000130  4381              BICS     r1,r1,r0              ;3644
000132  9800              LDR      r0,[sp,#0]            ;3645
000134  1a08              SUBS     r0,r1,r0              ;3645
000136  9001              STR      r0,[sp,#4]            ;3646
000138  2e03              CMP      r6,#3                 ;3646
00013a  d00f              BEQ      |L16.348|
00013c  4407              ADD      r7,r7,r0              ;3650
                  |L16.318|
00013e  9804              LDR      r0,[sp,#0x10]         ;3654
000140  1b41              SUBS     r1,r0,r5              ;3654
000142  1bca              SUBS     r2,r1,r7              ;3654
000144  eba2020b          SUB      r2,r2,r11             ;3654
000148  fbb2f1f9          UDIV     r1,r2,r9              ;3654
00014c  9100              STR      r1,[sp,#0]            ;3655
00014e  e000              B        |L16.338|
                  |L16.336|
000150  e0d4              B        |L16.764|
                  |L16.338|
000152  2e02              CMP      r6,#2                 ;3655
000154  d005              BEQ      |L16.354|
000156  2e03              CMP      r6,#3                 ;3656
000158  d006              BEQ      |L16.360|
00015a  e00b              B        |L16.372|
                  |L16.348|
00015c  4405              ADD      r5,r5,r0              ;3647
00015e  4482              ADD      r10,r10,r0            ;3648
000160  e7ed              B        |L16.318|
                  |L16.354|
000162  f64072f6          MOV      r2,#0xff6             ;3655
000166  e001              B        |L16.364|
                  |L16.360|
000168  f64f72f6          MOV      r2,#0xfff6            ;3656
                  |L16.364|
00016c  4291              CMP      r1,r2                 ;3656
00016e  d201              BCS      |L16.372|
                  |L16.368|
000170  200e              MOVS     r0,#0xe               ;3657
000172  e74b              B        |L16.12|
                  |L16.372|
000174  2e01              CMP      r6,#1                 ;3659
000176  d003              BEQ      |L16.384|
000178  2e02              CMP      r6,#2                 ;3659
00017a  d003              BEQ      |L16.388|
00017c  200c              MOVS     r0,#0xc               ;3662
00017e  e007              B        |L16.400|
                  |L16.384|
000180  2001              MOVS     r0,#1                 ;3660
000182  e005              B        |L16.400|
                  |L16.388|
000184  f5b03f80          CMP      r0,#0x10000           ;3661
000188  d201              BCS      |L16.398|
00018a  2004              MOVS     r0,#4                 ;3661
00018c  e000              B        |L16.400|
                  |L16.398|
00018e  2006              MOVS     r0,#6                 ;3661
                  |L16.400|
000190  9005              STR      r0,[sp,#0x14]         ;3672
000192  9807              LDR      r0,[sp,#0x1c]         ;3661
000194  b108              CBZ      r0,|L16.410|
000196  20f0              MOVS     r0,#0xf0              ;3673
000198  e03b              B        |L16.530|
                  |L16.410|
00019a  f1040030          ADD      r0,r4,#0x30           ;3675
00019e  f44f7200          MOV      r2,#0x200             ;3675
0001a2  2100              MOVS     r1,#0                 ;3675
0001a4  9002              STR      r0,[sp,#8]            ;3675
0001a6  f7fffffe          BL       mem_set
0001aa  f50470f7          ADD      r0,r4,#0x1ee          ;3676
0001ae  2101              MOVS     r1,#1                 ;3677
0001b0  7041              STRB     r1,[r0,#1]            ;3677
0001b2  7081              STRB     r1,[r0,#2]            ;3678
0001b4  2200              MOVS     r2,#0                 ;3679
0001b6  70c2              STRB     r2,[r0,#3]            ;3679
0001b8  9905              LDR      r1,[sp,#0x14]         ;3680
0001ba  7101              STRB     r1,[r0,#4]            ;3680
0001bc  21fe              MOVS     r1,#0xfe              ;3681
0001be  7141              STRB     r1,[r0,#5]            ;3681
0001c0  9b04              LDR      r3,[sp,#0x10]         ;3682
0001c2  eb080103          ADD      r1,r8,r3              ;3682
0001c6  f64363c1          MOV      r3,#0x3ec1            ;3682
0001ca  fbb1f1f3          UDIV     r1,r1,r3              ;3682
0001ce  233f              MOVS     r3,#0x3f              ;3683
0001d0  ea430c91          ORR      r12,r3,r1,LSR #2      ;3683
0001d4  9101              STR      r1,[sp,#4]            ;3683
0001d6  f880c006          STRB     r12,[r0,#6]           ;3683
0001da  71c1              STRB     r1,[r0,#7]            ;3684
0001dc  7203              STRB     r3,[r0,#8]            ;3685
0001de  7242              STRB     r2,[r0,#9]            ;3685
0001e0  7282              STRB     r2,[r0,#0xa]          ;3685
0001e2  72c2              STRB     r2,[r0,#0xb]          ;3685
0001e4  9904              LDR      r1,[sp,#0x10]         ;3686
0001e6  7301              STRB     r1,[r0,#0xc]          ;3686
0001e8  0a0a              LSRS     r2,r1,#8              ;3686
0001ea  7342              STRB     r2,[r0,#0xd]          ;3686
0001ec  0c0a              LSRS     r2,r1,#16             ;3686
0001ee  7382              STRB     r2,[r0,#0xe]          ;3686
0001f0  0e09              LSRS     r1,r1,#24             ;3686
0001f2  73c1              STRB     r1,[r0,#0xf]          ;3686
0001f4  2055              MOVS     r0,#0x55              ;3687
0001f6  f884022e          STRB     r0,[r4,#0x22e]        ;3687
0001fa  20aa              MOVS     r0,#0xaa              ;3687
0001fc  f884022f          STRB     r0,[r4,#0x22f]        ;3687
000200  e9dd1002          LDRD     r1,r0,[sp,#8]         ;3688
000204  2301              MOVS     r3,#1                 ;3688
000206  2200              MOVS     r2,#0                 ;3688
000208  f7fffffe          BL       disk_write
00020c  2800              CMP      r0,#0                 ;3688
                  |L16.526|
00020e  d175              BNE      |L16.764|
000210  20f8              MOVS     r0,#0xf8              ;3690
                  |L16.530|
000212  3430              ADDS     r4,r4,#0x30           ;3696
000214  9002              STR      r0,[sp,#8]            ;3696
000216  f44f7200          MOV      r2,#0x200             ;3696
00021a  2100              MOVS     r1,#0                 ;3696
00021c  4620              MOV      r0,r4                 ;3696
00021e  f7fffffe          BL       mem_set
000222  220b              MOVS     r2,#0xb               ;3697
000224  a179              ADR      r1,|L16.1036|
000226  4620              MOV      r0,r4                 ;3697
000228  f7fffffe          BL       mem_cpy
00022c  2100              MOVS     r1,#0                 ;3699
00022e  72e1              STRB     r1,[r4,#0xb]          ;3699
000230  2002              MOVS     r0,#2                 ;3699
000232  7320              STRB     r0,[r4,#0xc]          ;3699
000234  f884900d          STRB     r9,[r4,#0xd]          ;3700
000238  73a5              STRB     r5,[r4,#0xe]          ;3701
00023a  0a28              LSRS     r0,r5,#8              ;3701
00023c  73e0              STRB     r0,[r4,#0xf]          ;3701
00023e  2001              MOVS     r0,#1                 ;3702
000240  7420              STRB     r0,[r4,#0x10]         ;3702
000242  2e03              CMP      r6,#3                 ;3703
000244  d00b              BEQ      |L16.606|
000246  0240              LSLS     r0,r0,#9              ;3703
                  |L16.584|
000248  7460              STRB     r0,[r4,#0x11]         ;3704
00024a  0a00              LSRS     r0,r0,#8              ;3704
00024c  74a0              STRB     r0,[r4,#0x12]         ;3704
00024e  9804              LDR      r0,[sp,#0x10]         ;3705
000250  f5b03f80          CMP      r0,#0x10000           ;3705
000254  d205              BCS      |L16.610|
000256  74e0              STRB     r0,[r4,#0x13]         ;3706
000258  0a00              LSRS     r0,r0,#8              ;3706
00025a  7520              STRB     r0,[r4,#0x14]         ;3706
00025c  e00c              B        |L16.632|
                  |L16.606|
00025e  2000              MOVS     r0,#0                 ;3703
000260  e7f2              B        |L16.584|
                  |L16.610|
000262  f8840020          STRB     r0,[r4,#0x20]         ;3708
000266  0a02              LSRS     r2,r0,#8              ;3708
000268  f8842021          STRB     r2,[r4,#0x21]         ;3708
00026c  0c02              LSRS     r2,r0,#16             ;3708
00026e  f8842022          STRB     r2,[r4,#0x22]         ;3708
000272  0e00              LSRS     r0,r0,#24             ;3708
000274  f8840023          STRB     r0,[r4,#0x23]         ;3708
                  |L16.632|
000278  9802              LDR      r0,[sp,#8]            ;3710
00027a  7560              STRB     r0,[r4,#0x15]         ;3710
00027c  203f              MOVS     r0,#0x3f              ;3711
00027e  7620              STRB     r0,[r4,#0x18]         ;3711
000280  2000              MOVS     r0,#0                 ;3711
000282  7660              STRB     r0,[r4,#0x19]         ;3711
000284  21ff              MOVS     r1,#0xff              ;3712
000286  76a1              STRB     r1,[r4,#0x1a]         ;3712
000288  76e0              STRB     r0,[r4,#0x1b]         ;3712
00028a  f884801c          STRB     r8,[r4,#0x1c]         ;3713
00028e  ea4f2018          LSR      r0,r8,#8              ;3713
000292  7760              STRB     r0,[r4,#0x1d]         ;3713
000294  ea4f4018          LSR      r0,r8,#16             ;3713
000298  77a0              STRB     r0,[r4,#0x1e]         ;3713
00029a  ea4f6018          LSR      r0,r8,#24             ;3713
00029e  77e0              STRB     r0,[r4,#0x1f]         ;3713
0002a0  f7fffffe          BL       get_fattime
0002a4  2180              MOVS     r1,#0x80              ;3618
0002a6  2229              MOVS     r2,#0x29              ;3722
0002a8  9001              STR      r0,[sp,#4]            ;3715
0002aa  2e03              CMP      r6,#3                 ;3715
0002ac  d027              BEQ      |L16.766|
0002ae  f8840027          STRB     r0,[r4,#0x27]         ;3725
0002b2  0a03              LSRS     r3,r0,#8              ;3725
0002b4  f8843028          STRB     r3,[r4,#0x28]         ;3725
0002b8  0c03              LSRS     r3,r0,#16             ;3725
0002ba  f8843029          STRB     r3,[r4,#0x29]         ;3725
0002be  0e00              LSRS     r0,r0,#24             ;3725
0002c0  f884002a          STRB     r0,[r4,#0x2a]         ;3725
0002c4  75a7              STRB     r7,[r4,#0x16]         ;3726
0002c6  0a38              LSRS     r0,r7,#8              ;3726
0002c8  75e0              STRB     r0,[r4,#0x17]         ;3726
0002ca  f8841024          STRB     r1,[r4,#0x24]         ;3727
0002ce  f8842026          STRB     r2,[r4,#0x26]         ;3728
0002d2  2213              MOVS     r2,#0x13              ;3729
0002d4  a150              ADR      r1,|L16.1048|
0002d6  f104002b          ADD      r0,r4,#0x2b           ;3729
                  |L16.730|
0002da  f7fffffe          BL       mem_cpy
0002de  2055              MOVS     r0,#0x55              ;3731
0002e0  f88401fe          STRB     r0,[r4,#0x1fe]        ;3731
0002e4  20aa              MOVS     r0,#0xaa              ;3731
0002e6  f88401ff          STRB     r0,[r4,#0x1ff]        ;3731
0002ea  2301              MOVS     r3,#1                 ;3732
0002ec  4642              MOV      r2,r8                 ;3732
0002ee  4621              MOV      r1,r4                 ;3732
0002f0  9803              LDR      r0,[sp,#0xc]          ;3732
0002f2  f7fffffe          BL       disk_write
0002f6  2800              CMP      r0,#0                 ;3732
0002f8  d189              BNE      |L16.526|
0002fa  e033              B        |L16.868|
                  |L16.764|
0002fc  e0a2              B        |L16.1092|
                  |L16.766|
0002fe  f8840043          STRB     r0,[r4,#0x43]         ;3716
000302  0a03              LSRS     r3,r0,#8              ;3716
000304  f8843044          STRB     r3,[r4,#0x44]         ;3716
000308  0c03              LSRS     r3,r0,#16             ;3716
00030a  f8843045          STRB     r3,[r4,#0x45]         ;3716
00030e  0e00              LSRS     r0,r0,#24             ;3716
000310  f8840046          STRB     r0,[r4,#0x46]         ;3716
000314  f8847024          STRB     r7,[r4,#0x24]         ;3717
000318  0a38              LSRS     r0,r7,#8              ;3717
00031a  f8840025          STRB     r0,[r4,#0x25]         ;3717
00031e  0c38              LSRS     r0,r7,#16             ;3717
000320  f8840026          STRB     r0,[r4,#0x26]         ;3717
000324  0e38              LSRS     r0,r7,#24             ;3717
000326  f8840027          STRB     r0,[r4,#0x27]         ;3717
00032a  2002              MOVS     r0,#2                 ;3718
00032c  f884002c          STRB     r0,[r4,#0x2c]         ;3718
000330  2000              MOVS     r0,#0                 ;3718
000332  f884002d          STRB     r0,[r4,#0x2d]         ;3718
000336  f884002e          STRB     r0,[r4,#0x2e]         ;3718
00033a  f884002f          STRB     r0,[r4,#0x2f]         ;3718
00033e  2301              MOVS     r3,#1                 ;3719
000340  f8843030          STRB     r3,[r4,#0x30]         ;3719
000344  f8840031          STRB     r0,[r4,#0x31]         ;3719
000348  2306              MOVS     r3,#6                 ;3720
00034a  f8843032          STRB     r3,[r4,#0x32]         ;3720
00034e  f8840033          STRB     r0,[r4,#0x33]         ;3720
000352  f8841040          STRB     r1,[r4,#0x40]         ;3721
000356  f8842042          STRB     r2,[r4,#0x42]         ;3722
00035a  2213              MOVS     r2,#0x13              ;3723
00035c  a133              ADR      r1,|L16.1068|
00035e  f1040047          ADD      r0,r4,#0x47           ;3723
000362  e7ba              B        |L16.730|
                  |L16.868|
000364  2e03              CMP      r6,#3                 ;3734
000366  d106              BNE      |L16.886|
000368  2301              MOVS     r3,#1                 ;3735
00036a  f1080206          ADD      r2,r8,#6              ;3735
00036e  4621              MOV      r1,r4                 ;3735
000370  9803              LDR      r0,[sp,#0xc]          ;3735
000372  f7fffffe          BL       disk_write
                  |L16.886|
000376  4655              MOV      r5,r10                ;3738
000378  f04f0a00          MOV      r10,#0                ;3739
                  |L16.892|
00037c  f44f7200          MOV      r2,#0x200             ;3740
000380  2100              MOVS     r1,#0                 ;3740
000382  4620              MOV      r0,r4                 ;3740
000384  f7fffffe          BL       mem_set
000388  9802              LDR      r0,[sp,#8]            ;3741
00038a  9001              STR      r0,[sp,#4]            ;3742
00038c  2e03              CMP      r6,#3                 ;3742
00038e  d012              BEQ      |L16.950|
000390  2e01              CMP      r6,#1                 ;3743
000392  d00e              BEQ      |L16.946|
000394  f06f01ff          MVN      r1,#0xff              ;3743
                  |L16.920|
000398  4301              ORRS     r1,r1,r0              ;3743
00039a  9101              STR      r1,[sp,#4]            ;3744
00039c  7021              STRB     r1,[r4,#0]            ;3744
00039e  9801              LDR      r0,[sp,#4]            ;3744
0003a0  0a00              LSRS     r0,r0,#8              ;3744
0003a2  7060              STRB     r0,[r4,#1]            ;3744
0003a4  9801              LDR      r0,[sp,#4]            ;3744
0003a6  0c00              LSRS     r0,r0,#16             ;3744
0003a8  70a0              STRB     r0,[r4,#2]            ;3744
0003aa  9801              LDR      r0,[sp,#4]            ;3744
0003ac  0e00              LSRS     r0,r0,#24             ;3744
0003ae  70e0              STRB     r0,[r4,#3]            ;3744
0003b0  e018              B        |L16.996|
                  |L16.946|
0003b2  4923              LDR      r1,|L16.1088|
0003b4  e7f0              B        |L16.920|
                  |L16.950|
0003b6  f06000ff          ORN      r0,r0,#0xff           ;3746
0003ba  9001              STR      r0,[sp,#4]            ;3747
0003bc  7020              STRB     r0,[r4,#0]            ;3747
0003be  9801              LDR      r0,[sp,#4]            ;3747
0003c0  0a00              LSRS     r0,r0,#8              ;3747
0003c2  7060              STRB     r0,[r4,#1]            ;3747
0003c4  9801              LDR      r0,[sp,#4]            ;3747
0003c6  0c00              LSRS     r0,r0,#16             ;3747
0003c8  70a0              STRB     r0,[r4,#2]            ;3747
0003ca  9801              LDR      r0,[sp,#4]            ;3747
0003cc  0e00              LSRS     r0,r0,#24             ;3747
0003ce  70e0              STRB     r0,[r4,#3]            ;3747
0003d0  20ff              MOVS     r0,#0xff              ;3748
0003d2  7120              STRB     r0,[r4,#4]            ;3748
0003d4  7160              STRB     r0,[r4,#5]            ;3748
0003d6  71a0              STRB     r0,[r4,#6]            ;3748
0003d8  71e0              STRB     r0,[r4,#7]            ;3748
0003da  7220              STRB     r0,[r4,#8]            ;3749
0003dc  7260              STRB     r0,[r4,#9]            ;3749
0003de  72a0              STRB     r0,[r4,#0xa]          ;3749
0003e0  200f              MOVS     r0,#0xf               ;3749
0003e2  72e0              STRB     r0,[r4,#0xb]          ;3749
                  |L16.996|
0003e4  462a              MOV      r2,r5                 ;3751
0003e6  1c6d              ADDS     r5,r5,#1              ;3751
0003e8  2301              MOVS     r3,#1                 ;3751
0003ea  4621              MOV      r1,r4                 ;3751
0003ec  9803              LDR      r0,[sp,#0xc]          ;3751
0003ee  f7fffffe          BL       disk_write
0003f2  bb38              CBNZ     r0,|L16.1092|
0003f4  f44f7200          MOV      r2,#0x200             ;3753
0003f8  2100              MOVS     r1,#0                 ;3753
0003fa  4620              MOV      r0,r4                 ;3753
0003fc  f7fffffe          BL       mem_set
000400  2001              MOVS     r0,#1                 ;3754
000402  e02a              B        |L16.1114|
                  |L16.1028|
                          DCD      ||.data||+0x4
                  |L16.1032|
                          DCD      ||.constdata||
                  |L16.1036|
00040c  ebfe904d          DCB      235,254,144,"MSDOS5.0",0
000410  53444f53
000414  352e3000
                  |L16.1048|
000418  4e4f204e          DCB      "NO NAME    FAT     ",0
00041c  414d4520
000420  20202046
000424  41542020
000428  20202000
                  |L16.1068|
00042c  4e4f204e          DCB      "NO NAME    FAT32   ",0
000430  414d4520
000434  20202046
000438  41543332
00043c  20202000
                  |L16.1088|
                          DCD      0x00ffff00
                  |L16.1092|
000444  e045              B        |L16.1234|
                  |L16.1094|
000446  462a              MOV      r2,r5                 ;3755
000448  1c6d              ADDS     r5,r5,#1              ;3755
00044a  2301              MOVS     r3,#1                 ;3755
00044c  4621              MOV      r1,r4                 ;3755
00044e  9803              LDR      r0,[sp,#0xc]          ;3755
000450  f7fffffe          BL       disk_write
000454  bbe8              CBNZ     r0,|L16.1234|
000456  9801              LDR      r0,[sp,#4]            ;3754
000458  1c40              ADDS     r0,r0,#1              ;3754
                  |L16.1114|
00045a  9001              STR      r0,[sp,#4]            ;3754
00045c  42b8              CMP      r0,r7                 ;3754
00045e  d3f2              BCC      |L16.1094|
000460  f10a0001          ADD      r0,r10,#1             ;3739
000464  ea5f0a00          MOVS     r10,r0                ;3739
000468  d088              BEQ      |L16.892|
00046a  2e03              CMP      r6,#3                 ;3761
00046c  d009              BEQ      |L16.1154|
00046e  465f              MOV      r7,r11                ;3761
                  |L16.1136|
000470  462a              MOV      r2,r5                 ;3763
000472  1c6d              ADDS     r5,r5,#1              ;3763
000474  2301              MOVS     r3,#1                 ;3763
000476  4621              MOV      r1,r4                 ;3763
000478  9803              LDR      r0,[sp,#0xc]          ;3763
00047a  f7fffffe          BL       disk_write
00047e  bb40              CBNZ     r0,|L16.1234|
000480  e001              B        |L16.1158|
                  |L16.1154|
000482  464f              MOV      r7,r9                 ;3761
000484  e7f4              B        |L16.1136|
                  |L16.1158|
000486  1e7f              SUBS     r7,r7,#1              ;3761
000488  d1f2              BNE      |L16.1136|
00048a  2e03              CMP      r6,#3                 ;3777
00048c  d13c              BNE      |L16.1288|
00048e  2052              MOVS     r0,#0x52              ;3778
000490  7020              STRB     r0,[r4,#0]            ;3778
000492  7060              STRB     r0,[r4,#1]            ;3778
000494  2261              MOVS     r2,#0x61              ;3778
000496  70a2              STRB     r2,[r4,#2]            ;3778
000498  2141              MOVS     r1,#0x41              ;3778
00049a  70e1              STRB     r1,[r4,#3]            ;3778
00049c  2072              MOVS     r0,#0x72              ;3779
00049e  f88401e4          STRB     r0,[r4,#0x1e4]        ;3779
0004a2  f88401e5          STRB     r0,[r4,#0x1e5]        ;3779
0004a6  f88411e6          STRB     r1,[r4,#0x1e6]        ;3779
0004aa  f88421e7          STRB     r2,[r4,#0x1e7]        ;3779
0004ae  9800              LDR      r0,[sp,#0]            ;3780
0004b0  1e40              SUBS     r0,r0,#1              ;3780
0004b2  f88401e8          STRB     r0,[r4,#0x1e8]        ;3780
0004b6  0a01              LSRS     r1,r0,#8              ;3780
0004b8  f88411e9          STRB     r1,[r4,#0x1e9]        ;3780
0004bc  0c01              LSRS     r1,r0,#16             ;3780
0004be  f88411ea          STRB     r1,[r4,#0x1ea]        ;3780
0004c2  0e00              LSRS     r0,r0,#24             ;3780
0004c4  f88401eb          STRB     r0,[r4,#0x1eb]        ;3780
0004c8  2002              MOVS     r0,#2                 ;3781
0004ca  f88401ec          STRB     r0,[r4,#0x1ec]        ;3781
0004ce  2000              MOVS     r0,#0                 ;3781
0004d0  e000              B        |L16.1236|
                  |L16.1234|
0004d2  e021              B        |L16.1304|
                  |L16.1236|
0004d4  f88401ed          STRB     r0,[r4,#0x1ed]        ;3781
0004d8  f88401ee          STRB     r0,[r4,#0x1ee]        ;3781
0004dc  f88401ef          STRB     r0,[r4,#0x1ef]        ;3781
0004e0  2055              MOVS     r0,#0x55              ;3782
0004e2  f88401fe          STRB     r0,[r4,#0x1fe]        ;3782
0004e6  20aa              MOVS     r0,#0xaa              ;3782
0004e8  f88401ff          STRB     r0,[r4,#0x1ff]        ;3782
0004ec  2301              MOVS     r3,#1                 ;3783
0004ee  f1080201          ADD      r2,r8,#1              ;3783
0004f2  4621              MOV      r1,r4                 ;3783
0004f4  9803              LDR      r0,[sp,#0xc]          ;3783
0004f6  f7fffffe          BL       disk_write
0004fa  2301              MOVS     r3,#1                 ;3784
0004fc  f1080207          ADD      r2,r8,#7              ;3784
000500  4621              MOV      r1,r4                 ;3784
000502  9803              LDR      r0,[sp,#0xc]          ;3784
000504  f7fffffe          BL       disk_write
                  |L16.1288|
000508  2200              MOVS     r2,#0                 ;3787
00050a  4611              MOV      r1,r2                 ;3787
00050c  9803              LDR      r0,[sp,#0xc]          ;3787
00050e  f7fffffe          BL       disk_ioctl
000512  2800              CMP      r0,#0                 ;3787
000514  f43fad84          BEQ      |L16.32|
                  |L16.1304|
000518  2001              MOVS     r0,#1                 ;3787
00051a  e577              B        |L16.12|
;;;3789   
                          ENDP


                          AREA ||i.f_mount||, CODE, READONLY, ALIGN=2

                  f_mount PROC
;;;2206   //返回的FR_OK=0。
;;;2207   FRESULT f_mount (
000000  b108              CBZ      r0,|L17.6|
;;;2208   	BYTE vol,		/* Logical drive number to be mounted/unmounted 被安装或卸载的逻辑驱动器号*/
;;;2209   	FATFS *fs		/* Pointer to new file system object (NULL for unmount)指向一个新的文件系统对象*/
;;;2210   )
;;;2211   {
;;;2212   	FATFS *rfs;
;;;2213   
;;;2214   
;;;2215   	if (vol >= _VOLUMES)		/* Check if the drive number is valid 检测是否为有效的驱动器号，与设置的允许加载的驱动器个数有关 */
;;;2216   		return FR_INVALID_DRIVE;
000002  200b              MOVS     r0,#0xb
;;;2217   	rfs = FatFs[vol];			/* Get current fs object FatFs[vol]是一个static FATFS型的全局变量，获取当前的文件系统结构体*/
;;;2218   
;;;2219   	if (rfs) {
;;;2220   #if _FS_SHARE//如果共享则解锁
;;;2221   		clear_lock(rfs);
;;;2222   #endif
;;;2223   #if _FS_REENTRANT				/* Discard sync object of the current volume */
;;;2224   		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;//用于是否重入对象的
;;;2225   #endif
;;;2226   		rfs->fs_type = 0;		/* Clear old fs object 把文件系统类型定义为0，也就是没有文件系统*/
;;;2227   	}
;;;2228   
;;;2229   	if (fs) {
;;;2230   		fs->fs_type = 0;		/* Clear new fs object 把文件系统类型定义为0，也就是没有文件系统*/
;;;2231   #if _FS_REENTRANT				/* Create sync object for the new volume */
;;;2232   		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
;;;2233   #endif
;;;2234   	}
;;;2235   	FatFs[vol] = fs;			/* Register new fs object  ，让全局变量的FATFS指向新建的FATFS信息结构体，也就是对FatFs[vol]的操作就像是对fs的操作*/
;;;2236   
;;;2237   	return FR_OK;
;;;2238   }
000004  4770              BX       lr
                  |L17.6|
000006  4b05              LDR      r3,|L17.28|
000008  2200              MOVS     r2,#0                 ;2217
00000a  6818              LDR      r0,[r3,#0]            ;2219
00000c  b100              CBZ      r0,|L17.16|
00000e  7002              STRB     r2,[r0,#0]            ;2226
                  |L17.16|
000010  b101              CBZ      r1,|L17.20|
000012  700a              STRB     r2,[r1,#0]            ;2230
                  |L17.20|
000014  2000              MOVS     r0,#0                 ;2237
000016  6019              STR      r1,[r3,#0]            ;2237
000018  4770              BX       lr
;;;2239   
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      ||.data||+0x4

                          AREA ||i.f_open||, CODE, READONLY, ALIGN=1

                  f_open PROC
;;;2246   
;;;2247   FRESULT f_open (
000000  e92d47f7          PUSH     {r0-r2,r4-r10,lr}
;;;2248   	FIL *fp,			/* Pointer to the blank file object 指向一个空白的文件指针*/
;;;2249   	const TCHAR *path,	/* Pointer to the file name 指向文件名*/
;;;2250   	BYTE mode			/* Access mode and file open mode flags */
;;;2251   )
;;;2252   {
000004  b08b              SUB      sp,sp,#0x2c
;;;2253   	FRESULT res;
;;;2254   	DIR dj;
;;;2255   	BYTE *dir;
;;;2256   	DEF_NAMEBUF;
;;;2257   
;;;2258   
;;;2259   	fp->fs = 0;			/* Clear file object */
000006  f04f0900          MOV      r9,#0
00000a  4607              MOV      r7,r0                 ;2252
;;;2260   
;;;2261   #if !_FS_READONLY  //非只读模式下
;;;2262   	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
00000c  f002061f          AND      r6,r2,#0x1f
;;;2263   	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));//以上的几种模式和读模式
000010  f8c09000          STR      r9,[r0,#0]
000014  f0260201          BIC      r2,r6,#1
000018  4669              MOV      r1,sp
00001a  a80c              ADD      r0,sp,#0x30
00001c  f7fffffe          BL       chk_mounted
000020  0005              MOVS     r5,r0
;;;2264   #else
;;;2265   	mode &= FA_READ;
;;;2266   	res = chk_mounted(&path, &dj.fs, 0);//
;;;2267   #endif
;;;2268   	INIT_BUF(dj);
000022  a807              ADD      r0,sp,#0x1c
;;;2269   	if (res == FR_OK)
000024  9006              STR      r0,[sp,#0x18]
000026  d104              BNE      |L18.50|
;;;2270   		res = follow_path(&dj, path);	/* Follow the file path */
000028  4668              MOV      r0,sp
00002a  990c              LDR      r1,[sp,#0x30]
00002c  f7fffffe          BL       follow_path
000030  4605              MOV      r5,r0
                  |L18.50|
;;;2271   	dir = dj.dir;
;;;2272   
;;;2273   #if !_FS_READONLY	/* R/W configuration */
;;;2274   	if (res == FR_OK) {
000032  9c05              LDR      r4,[sp,#0x14]
000034  b90d              CBNZ     r5,|L18.58|
;;;2275   		if (!dir)	/* Current dir itself */
000036  b904              CBNZ     r4,|L18.58|
;;;2276   			res = FR_INVALID_NAME;
000038  2506              MOVS     r5,#6
                  |L18.58|
;;;2277   #if _FS_SHARE
;;;2278   		else
;;;2279   			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2280   #endif
;;;2281   	}
;;;2282   	/* Create or Open a file */
;;;2283   	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
00003a  f0160f1c          TST      r6,#0x1c
00003e  d04e              BEQ      |L18.222|
;;;2284   		DWORD dw, cl;
;;;2285   
;;;2286   		if (res != FR_OK) {					/* No file, create new */
000040  b155              CBZ      r5,|L18.88|
;;;2287   			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
000042  2d04              CMP      r5,#4
000044  d103              BNE      |L18.78|
;;;2288   #if _FS_SHARE
;;;2289   				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
;;;2290   #else
;;;2291   				res = dir_register(&dj);
000046  4668              MOV      r0,sp
000048  f7fffffe          BL       dir_register
00004c  4605              MOV      r5,r0
                  |L18.78|
;;;2292   #endif
;;;2293   			mode |= FA_CREATE_ALWAYS;		/* File is created */
;;;2294   			dir = dj.dir;					/* New entry */
00004e  9c05              LDR      r4,[sp,#0x14]
000050  f0460608          ORR      r6,r6,#8              ;2293
000054  b145              CBZ      r5,|L18.104|
000056  e06a              B        |L18.302|
                  |L18.88|
;;;2295   		}
;;;2296   		else {								/* Any object is already existing */
;;;2297   			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
000058  7ae0              LDRB     r0,[r4,#0xb]
00005a  f0100f11          TST      r0,#0x11
00005e  d148              BNE      |L18.242|
;;;2298   				res = FR_DENIED;
;;;2299   			} else {
;;;2300   				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
000060  0770              LSLS     r0,r6,#29
000062  d501              BPL      |L18.104|
;;;2301   					res = FR_EXIST;
000064  2508              MOVS     r5,#8
000066  e062              B        |L18.302|
                  |L18.104|
;;;2302   			}
;;;2303   		}
;;;2304   		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
000068  0730              LSLS     r0,r6,#28
00006a  d548              BPL      |L18.254|
;;;2305   			dw = get_fattime();					/* Created time */
00006c  f7fffffe          BL       get_fattime
;;;2306   			ST_DWORD(dir+DIR_CrtTime, dw);
000070  73a0              STRB     r0,[r4,#0xe]
000072  0a01              LSRS     r1,r0,#8
000074  73e1              STRB     r1,[r4,#0xf]
000076  0c01              LSRS     r1,r0,#16
000078  7421              STRB     r1,[r4,#0x10]
00007a  0e00              LSRS     r0,r0,#24
00007c  7460              STRB     r0,[r4,#0x11]
;;;2307   			dir[DIR_Attr] = 0;					/* Reset attribute */
00007e  f884900b          STRB     r9,[r4,#0xb]
;;;2308   			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
000082  f884901c          STRB     r9,[r4,#0x1c]
000086  f884901d          STRB     r9,[r4,#0x1d]
00008a  f884901e          STRB     r9,[r4,#0x1e]
00008e  f884901f          STRB     r9,[r4,#0x1f]
;;;2309   			cl = LD_CLUST(dir);					/* Get start cluster */
000092  8aa2              LDRH     r2,[r4,#0x14]
000094  8b61              LDRH     r1,[r4,#0x1a]
;;;2310   			ST_CLUST(dir, 0);					/* cluster = 0 */
000096  f884901a          STRB     r9,[r4,#0x1a]
00009a  f884901b          STRB     r9,[r4,#0x1b]
00009e  f362411f          BFI      r1,r2,#16,#16         ;2309
0000a2  f8849014          STRB     r9,[r4,#0x14]
0000a6  ea5f0801          MOVS     r8,r1                 ;2309
0000aa  f8849015          STRB     r9,[r4,#0x15]
;;;2311   			dj.fs->wflag = 1;
0000ae  9900              LDR      r1,[sp,#0]
0000b0  f04f0001          MOV      r0,#1
0000b4  7108              STRB     r0,[r1,#4]
;;;2312   			if (cl) {							/* Remove the cluster chain if exist */
0000b6  4641              MOV      r1,r8
0000b8  d01f              BEQ      |L18.250|
;;;2313   				dw = dj.fs->winsect;
0000ba  9800              LDR      r0,[sp,#0]
;;;2314   				res = remove_chain(dj.fs, cl);
0000bc  f8d0a02c          LDR      r10,[r0,#0x2c]
0000c0  f7fffffe          BL       remove_chain
0000c4  0005              MOVS     r5,r0
;;;2315   				if (res == FR_OK) {
0000c6  d132              BNE      |L18.302|
;;;2316   					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
0000c8  9900              LDR      r1,[sp,#0]
0000ca  f1a80001          SUB      r0,r8,#1
;;;2317   					res = move_window(dj.fs, dw);
0000ce  60c8              STR      r0,[r1,#0xc]
0000d0  4651              MOV      r1,r10
0000d2  9800              LDR      r0,[sp,#0]
0000d4  f7fffffe          BL       move_window
0000d8  1e05              SUBS     r5,r0,#0
;;;2318   				}
;;;2319   			}
;;;2320   		}
;;;2321   	}
;;;2322   	else {	/* Open an existing file */
;;;2323   		if (res == FR_OK) {						/* Follow succeeded */
;;;2324   			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
;;;2325   				res = FR_NO_FILE;
;;;2326   			} else {
;;;2327   				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
;;;2328   					res = FR_DENIED;
;;;2329   			}
;;;2330   		}
;;;2331   	}
;;;2332   	if (res == FR_OK) {
0000da  d00c              BEQ      |L18.246|
0000dc  e027              B        |L18.302|
                  |L18.222|
0000de  bb35              CBNZ     r5,|L18.302|
0000e0  7ae0              LDRB     r0,[r4,#0xb]          ;2324
0000e2  06c1              LSLS     r1,r0,#27             ;2324
0000e4  d501              BPL      |L18.234|
0000e6  2504              MOVS     r5,#4                 ;2325
0000e8  e021              B        |L18.302|
                  |L18.234|
0000ea  07b1              LSLS     r1,r6,#30             ;2327
0000ec  d503              BPL      |L18.246|
0000ee  07c0              LSLS     r0,r0,#31             ;2327
0000f0  d001              BEQ      |L18.246|
                  |L18.242|
0000f2  2507              MOVS     r5,#7                 ;2328
0000f4  e01b              B        |L18.302|
                  |L18.246|
;;;2333   		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
0000f6  0730              LSLS     r0,r6,#28
0000f8  d501              BPL      |L18.254|
                  |L18.250|
;;;2334   			mode |= FA__WRITTEN;
0000fa  f0460620          ORR      r6,r6,#0x20
                  |L18.254|
;;;2335   		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
0000fe  9800              LDR      r0,[sp,#0]
000100  6ac0              LDR      r0,[r0,#0x2c]
000102  e9c70407          STRD     r0,r4,[r7,#0x1c]
;;;2336   		fp->dir_ptr = dir;
;;;2337   #if _FS_SHARE
;;;2338   		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2339   		if (!fp->lockid) res = FR_INT_ERR;
;;;2340   #endif
;;;2341   	}
;;;2342   
;;;2343   #else				/* R/O configuration */
;;;2344   	if (res == FR_OK) {					/* Follow succeeded */
;;;2345   		if (!dir) {						/* Current dir itself */
;;;2346   			res = FR_INVALID_NAME;
;;;2347   		} else {
;;;2348   			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
;;;2349   				res = FR_NO_FILE;
;;;2350   		}
;;;2351   	}
;;;2352   #endif
;;;2353   	FREE_BUF();
;;;2354   
;;;2355   	if (res == FR_OK) {
;;;2356   		fp->flag = mode;					/* File access mode */
000106  71be              STRB     r6,[r7,#6]
;;;2357   		fp->sclust = LD_CLUST(dir);			/* File start cluster */
000108  8aa1              LDRH     r1,[r4,#0x14]
00010a  8b60              LDRH     r0,[r4,#0x1a]
00010c  f361401f          BFI      r0,r1,#16,#16
;;;2358   		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
000110  6138              STR      r0,[r7,#0x10]
000112  7f20              LDRB     r0,[r4,#0x1c]
000114  f8d4101d          LDR      r1,[r4,#0x1d]
000118  ea402001          ORR      r0,r0,r1,LSL #8
;;;2359   		fp->fptr = 0;						/* File pointer */
;;;2360   		fp->dsect = 0;
00011c  e9c79002          STRD     r9,r0,[r7,#8]
;;;2361   #if _USE_FASTSEEK
;;;2362   		fp->cltbl = 0;						/* Normal seek mode */
;;;2363   #endif
;;;2364   		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
000120  f8c79018          STR      r9,[r7,#0x18]
000124  9800              LDR      r0,[sp,#0]
000126  6038              STR      r0,[r7,#0]
000128  9800              LDR      r0,[sp,#0]
00012a  88c0              LDRH     r0,[r0,#6]
00012c  80b8              STRH     r0,[r7,#4]
                  |L18.302|
;;;2365   	}
;;;2366   
;;;2367   	LEAVE_FF(dj.fs, res);
;;;2368   }
00012e  b00e              ADD      sp,sp,#0x38
000130  4628              MOV      r0,r5                 ;2367
000132  e8bd87f0          POP      {r4-r10,pc}
;;;2369   
                          ENDP


                          AREA ||i.f_opendir||, CODE, READONLY, ALIGN=1

                  f_opendir PROC
;;;2965   
;;;2966   FRESULT f_opendir (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;2967   	DIR *dj,			/* Pointer to directory object to create */
;;;2968   	const TCHAR *path	/* Pointer to the directory path */
;;;2969   )
;;;2970   {
000002  b084              SUB      sp,sp,#0x10
000004  4604              MOV      r4,r0
;;;2971   	FRESULT res;
;;;2972   	DEF_NAMEBUF;
;;;2973   
;;;2974   
;;;2975   	res = chk_mounted(&path, &dj->fs, 0);
000006  4601              MOV      r1,r0
000008  2200              MOVS     r2,#0
00000a  a805              ADD      r0,sp,#0x14
00000c  f7fffffe          BL       chk_mounted
;;;2976   	if (res == FR_OK) {
000010  2800              CMP      r0,#0
000012  d11a              BNE      |L19.74|
;;;2977   		INIT_BUF(*dj);
000014  f8c4d018          STR      sp,[r4,#0x18]
;;;2978   		res = follow_path(dj, path);			/* Follow the path to the directory */
000018  4620              MOV      r0,r4
00001a  9905              LDR      r1,[sp,#0x14]
00001c  f7fffffe          BL       follow_path
;;;2979   		FREE_BUF();
;;;2980   		if (res == FR_OK) {						/* Follow completed */
000020  b980              CBNZ     r0,|L19.68|
;;;2981   			if (dj->dir) {						/* It is not the root dir */
000022  6960              LDR      r0,[r4,#0x14]
000024  b138              CBZ      r0,|L19.54|
;;;2982   				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
000026  7ac1              LDRB     r1,[r0,#0xb]
000028  06c9              LSLS     r1,r1,#27
00002a  d50d              BPL      |L19.72|
;;;2983   					dj->sclust = LD_CLUST(dj->dir);
00002c  8a81              LDRH     r1,[r0,#0x14]
00002e  8b40              LDRH     r0,[r0,#0x1a]
000030  f361401f          BFI      r0,r1,#16,#16
000034  60a0              STR      r0,[r4,#8]
                  |L19.54|
;;;2984   				} else {						/* The object is not a directory */
;;;2985   					res = FR_NO_PATH;
;;;2986   				}
;;;2987   			}
;;;2988   			if (res == FR_OK) {
;;;2989   				dj->id = dj->fs->id;
000036  6820              LDR      r0,[r4,#0]
;;;2990   				res = dir_sdi(dj, 0);			/* Rewind dir */
000038  2100              MOVS     r1,#0
00003a  88c0              LDRH     r0,[r0,#6]            ;2989
00003c  80a0              STRH     r0,[r4,#4]            ;2989
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       dir_sdi
                  |L19.68|
;;;2991   			}
;;;2992   		}
;;;2993   		if (res == FR_NO_FILE) res = FR_NO_PATH;
000044  2804              CMP      r0,#4
000046  d100              BNE      |L19.74|
                  |L19.72|
000048  2005              MOVS     r0,#5
                  |L19.74|
;;;2994   	}
;;;2995   
;;;2996   	LEAVE_FF(dj->fs, res);
;;;2997   }
00004a  b006              ADD      sp,sp,#0x18
00004c  bd10              POP      {r4,pc}
;;;2998   
                          ENDP


                          AREA ||i.f_read||, CODE, READONLY, ALIGN=1

                  f_read PROC
;;;2376   
;;;2377   FRESULT f_read (
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2378   	FIL *fp, 		/* Pointer to the file object */
;;;2379   	void *buff,		/* Pointer to data buffer */
;;;2380   	UINT btr,		/* Number of bytes to read */
;;;2381   	UINT *br		/* Pointer to number of bytes read */
;;;2382   )
;;;2383   {
;;;2384   	FRESULT res;
;;;2385   	DWORD clst, sect, remain;
;;;2386   	UINT rcnt, cc;
;;;2387   	BYTE csect, *rbuff = buff;
000004  4689              MOV      r9,r1
;;;2388   
;;;2389   
;;;2390   	*br = 0;	/* Initialize byte counter */
000006  2100              MOVS     r1,#0
;;;2391   
;;;2392   	res = validate(fp->fs, fp->id);				/* Check validity */
000008  6019              STR      r1,[r3,#0]
00000a  4604              MOV      r4,r0                 ;2383
00000c  8881              LDRH     r1,[r0,#4]
00000e  469a              MOV      r10,r3                ;2383
000010  4616              MOV      r6,r2                 ;2383
000012  6800              LDR      r0,[r0,#0]
000014  f7fffffe          BL       validate
;;;2393   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000018  2800              CMP      r0,#0
00001a  d103              BNE      |L20.36|
;;;2394   	if (fp->flag & FA__ERROR)					/* Aborted file? */
00001c  79a0              LDRB     r0,[r4,#6]
00001e  0601              LSLS     r1,r0,#24
000020  d502              BPL      |L20.40|
                  |L20.34|
;;;2395   		LEAVE_FF(fp->fs, FR_INT_ERR);
000022  2002              MOVS     r0,#2
                  |L20.36|
;;;2396   	if (!(fp->flag & FA_READ)) 					/* Check access mode */
;;;2397   		LEAVE_FF(fp->fs, FR_DENIED);
;;;2398   	remain = fp->fsize - fp->fptr;
;;;2399   	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
;;;2400   
;;;2401   	for ( ;  btr;								/* Repeat until all data read */
;;;2402   		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
;;;2403   		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
;;;2404   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2405   			if (!csect) {						/* On the cluster boundary? */
;;;2406   				if (fp->fptr == 0) {			/* On the top of the file? */
;;;2407   					clst = fp->sclust;			/* Follow from the origin */
;;;2408   				} else {						/* Middle or end of the file */
;;;2409   #if _USE_FASTSEEK
;;;2410   					if (fp->cltbl)
;;;2411   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2412   					else
;;;2413   #endif
;;;2414   						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
;;;2415   				}
;;;2416   				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
;;;2417   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2418   				fp->clust = clst;				/* Update current cluster */
;;;2419   			}
;;;2420   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2421   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2422   			sect += csect;
;;;2423   			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
;;;2424   			if (cc) {							/* Read maximum contiguous sectors directly */
;;;2425   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2426   					cc = fp->fs->csize - csect;
;;;2427   				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
;;;2428   					ABORT(fp->fs, FR_DISK_ERR);
;;;2429   #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;2430   #if _FS_TINY
;;;2431   				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
;;;2432   					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
;;;2433   #else
;;;2434   				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
;;;2435   					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
;;;2436   #endif
;;;2437   #endif
;;;2438   				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
;;;2439   				continue;
;;;2440   			}
;;;2441   #if !_FS_TINY
;;;2442   			if (fp->dsect != sect) {			/* Load data sector if not in cache */
;;;2443   #if !_FS_READONLY
;;;2444   				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;2445   					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2446   						ABORT(fp->fs, FR_DISK_ERR);
;;;2447   					fp->flag &= ~FA__DIRTY;
;;;2448   				}
;;;2449   #endif
;;;2450   				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
;;;2451   					ABORT(fp->fs, FR_DISK_ERR);
;;;2452   			}
;;;2453   #endif
;;;2454   			fp->dsect = sect;
;;;2455   		}
;;;2456   		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
;;;2457   		if (rcnt > btr) rcnt = btr;
;;;2458   #if _FS_TINY
;;;2459   		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
;;;2460   			ABORT(fp->fs, FR_DISK_ERR);
;;;2461   		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2462   #else
;;;2463   		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2464   #endif
;;;2465   	}
;;;2466   
;;;2467   	LEAVE_FF(fp->fs, FR_OK);
;;;2468   }
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L20.40|
000028  07c0              LSLS     r0,r0,#31             ;2396
00002a  d008              BEQ      |L20.62|
00002c  e9d41002          LDRD     r1,r0,[r4,#8]         ;2396
000030  1a40              SUBS     r0,r0,r1              ;2398
000032  f1040b24          ADD      r11,r4,#0x24          ;2435
000036  4286              CMP      r6,r0                 ;2399
000038  d900              BLS      |L20.60|
00003a  4606              MOV      r6,r0                 ;2399
                  |L20.60|
00003c  e07e              B        |L20.316|
                  |L20.62|
00003e  2007              MOVS     r0,#7                 ;2397
000040  e7f0              B        |L20.36|
                  |L20.66|
000042  68a0              LDR      r0,[r4,#8]            ;2403
000044  05c1              LSLS     r1,r0,#23             ;2403
000046  d161              BNE      |L20.268|
000048  6822              LDR      r2,[r4,#0]            ;2404
00004a  7891              LDRB     r1,[r2,#2]            ;2404
00004c  1e49              SUBS     r1,r1,#1              ;2404
00004e  ea012150          AND      r1,r1,r0,LSR #9       ;2404
000052  f01107ff          ANDS     r7,r1,#0xff           ;2404
000056  d109              BNE      |L20.108|
000058  b1f8              CBZ      r0,|L20.154|
00005a  4610              MOV      r0,r2                 ;2414
00005c  6961              LDR      r1,[r4,#0x14]         ;2414
00005e  f7fffffe          BL       get_fat
                  |L20.98|
000062  2802              CMP      r0,#2                 ;2416
000064  d31b              BCC      |L20.158|
000066  1c41              ADDS     r1,r0,#1              ;2417
000068  d048              BEQ      |L20.252|
00006a  6160              STR      r0,[r4,#0x14]         ;2418
                  |L20.108|
00006c  6961              LDR      r1,[r4,#0x14]         ;2420
00006e  6820              LDR      r0,[r4,#0]            ;2420
000070  f7fffffe          BL       clust2sect
000074  b198              CBZ      r0,|L20.158|
000076  eb000807          ADD      r8,r0,r7              ;2422
00007a  0a75              LSRS     r5,r6,#9              ;2423
00007c  d025              BEQ      |L20.202|
00007e  6820              LDR      r0,[r4,#0]            ;2425
000080  197a              ADDS     r2,r7,r5              ;2425
000082  7881              LDRB     r1,[r0,#2]            ;2425
000084  428a              CMP      r2,r1                 ;2425
000086  d900              BLS      |L20.138|
000088  1bcd              SUBS     r5,r1,r7              ;2426
                  |L20.138|
00008a  b2eb              UXTB     r3,r5                 ;2427
00008c  7840              LDRB     r0,[r0,#1]            ;2427
00008e  4642              MOV      r2,r8                 ;2427
000090  4649              MOV      r1,r9                 ;2427
000092  f7fffffe          BL       disk_read
000096  bb88              CBNZ     r0,|L20.252|
000098  e006              B        |L20.168|
                  |L20.154|
00009a  6920              LDR      r0,[r4,#0x10]         ;2407
00009c  e7e1              B        |L20.98|
                  |L20.158|
00009e  79a0              LDRB     r0,[r4,#6]            ;2421
0000a0  f0400080          ORR      r0,r0,#0x80           ;2421
0000a4  71a0              STRB     r0,[r4,#6]            ;2421
0000a6  e7bc              B        |L20.34|
                  |L20.168|
0000a8  79a0              LDRB     r0,[r4,#6]            ;2434
0000aa  0640              LSLS     r0,r0,#25             ;2434
0000ac  d50b              BPL      |L20.198|
0000ae  69a1              LDR      r1,[r4,#0x18]         ;2434
0000b0  eba10008          SUB      r0,r1,r8              ;2434
0000b4  42a8              CMP      r0,r5                 ;2434
0000b6  d206              BCS      |L20.198|
0000b8  eb092040          ADD      r0,r9,r0,LSL #9       ;2435
0000bc  f44f7200          MOV      r2,#0x200             ;2435
0000c0  4659              MOV      r1,r11                ;2435
0000c2  f7fffffe          BL       mem_cpy
                  |L20.198|
0000c6  026d              LSLS     r5,r5,#9              ;2438
0000c8  e02e              B        |L20.296|
                  |L20.202|
0000ca  69a2              LDR      r2,[r4,#0x18]         ;2442
0000cc  4542              CMP      r2,r8                 ;2442
0000ce  d01b              BEQ      |L20.264|
0000d0  79a0              LDRB     r0,[r4,#6]            ;2444
0000d2  0640              LSLS     r0,r0,#25             ;2444
0000d4  d50a              BPL      |L20.236|
0000d6  6820              LDR      r0,[r4,#0]            ;2445
0000d8  2301              MOVS     r3,#1                 ;2445
0000da  4659              MOV      r1,r11                ;2445
0000dc  7840              LDRB     r0,[r0,#1]            ;2445
0000de  f7fffffe          BL       disk_write
0000e2  b958              CBNZ     r0,|L20.252|
0000e4  79a0              LDRB     r0,[r4,#6]            ;2447
0000e6  f0200040          BIC      r0,r0,#0x40           ;2447
0000ea  71a0              STRB     r0,[r4,#6]            ;2447
                  |L20.236|
0000ec  6820              LDR      r0,[r4,#0]            ;2450
0000ee  2301              MOVS     r3,#1                 ;2450
0000f0  4642              MOV      r2,r8                 ;2450
0000f2  7840              LDRB     r0,[r0,#1]            ;2450
0000f4  4659              MOV      r1,r11                ;2450
0000f6  f7fffffe          BL       disk_read
0000fa  b128              CBZ      r0,|L20.264|
                  |L20.252|
0000fc  79a0              LDRB     r0,[r4,#6]            ;2451
0000fe  f0400080          ORR      r0,r0,#0x80           ;2451
000102  71a0              STRB     r0,[r4,#6]            ;2451
000104  2001              MOVS     r0,#1                 ;2451
000106  e78d              B        |L20.36|
                  |L20.264|
000108  f8c48018          STR      r8,[r4,#0x18]         ;2454
                  |L20.268|
00010c  8920              LDRH     r0,[r4,#8]            ;2456
00010e  f3c00008          UBFX     r0,r0,#0,#9           ;2456
000112  f5c07500          RSB      r5,r0,#0x200          ;2456
000116  42b5              CMP      r5,r6                 ;2457
000118  d900              BLS      |L20.284|
00011a  4635              MOV      r5,r6                 ;2457
                  |L20.284|
00011c  1901              ADDS     r1,r0,r4              ;2463
00011e  462a              MOV      r2,r5                 ;2463
000120  4648              MOV      r0,r9                 ;2463
000122  3124              ADDS     r1,r1,#0x24           ;2463
000124  f7fffffe          BL       mem_cpy
                  |L20.296|
000128  68a0              LDR      r0,[r4,#8]            ;2402
00012a  44a9              ADD      r9,r9,r5              ;2402
00012c  4428              ADD      r0,r0,r5              ;2402
00012e  60a0              STR      r0,[r4,#8]            ;2402
000130  f8da0000          LDR      r0,[r10,#0]           ;2402
000134  1941              ADDS     r1,r0,r5              ;2402
000136  1b76              SUBS     r6,r6,r5              ;2402
000138  f8ca1000          STR      r1,[r10,#0]           ;2402
                  |L20.316|
00013c  2e00              CMP      r6,#0                 ;2401
00013e  d180              BNE      |L20.66|
000140  2000              MOVS     r0,#0                 ;2467
000142  e76f              B        |L20.36|
;;;2469   
                          ENDP


                          AREA ||i.f_readdir||, CODE, READONLY, ALIGN=1

                  f_readdir PROC
;;;3005   
;;;3006   FRESULT f_readdir (
000000  b5fe              PUSH     {r1-r7,lr}
;;;3007   	DIR *dj,			/* Pointer to the open directory object */
;;;3008   	FILINFO *fno		/* Pointer to file information to return */
;;;3009   )
;;;3010   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;3011   	FRESULT res;
;;;3012   	DEF_NAMEBUF;
;;;3013   
;;;3014   
;;;3015   	res = validate(dj->fs, dj->id);			/* Check validity of the object */
000006  8881              LDRH     r1,[r0,#4]
000008  6800              LDR      r0,[r0,#0]
00000a  f7fffffe          BL       validate
;;;3016   	if (res == FR_OK) {
00000e  2800              CMP      r0,#0
000010  d116              BNE      |L21.64|
;;;3017   		if (!fno) {
000012  b1b5              CBZ      r5,|L21.66|
;;;3018   			res = dir_sdi(dj, 0);			/* Rewind the directory object */
;;;3019   		} else {
;;;3020   			INIT_BUF(*dj);
000014  f8c4d018          STR      sp,[r4,#0x18]
;;;3021   			res = dir_read(dj);				/* Read an directory item */
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       dir_read
00001e  2600              MOVS     r6,#0
;;;3022   			if (res == FR_NO_FILE) {		/* Reached end of dir */
000020  2804              CMP      r0,#4
000022  d013              BEQ      |L21.76|
;;;3023   				dj->sect = 0;
;;;3024   				res = FR_OK;
;;;3025   			}
;;;3026   			if (res == FR_OK) {				/* A valid entry is found */
000024  2800              CMP      r0,#0
000026  d10b              BNE      |L21.64|
                  |L21.40|
;;;3027   				get_fileinfo(dj, fno);		/* Get the object information */
000028  4629              MOV      r1,r5
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       get_fileinfo
;;;3028   				res = dir_next(dj, 0);		/* Increment index for next */
000030  2100              MOVS     r1,#0
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       dir_next
;;;3029   				if (res == FR_NO_FILE) {
000038  2804              CMP      r0,#4
00003a  d101              BNE      |L21.64|
;;;3030   					dj->sect = 0;
;;;3031   					res = FR_OK;
00003c  2000              MOVS     r0,#0
00003e  6126              STR      r6,[r4,#0x10]
                  |L21.64|
;;;3032   				}
;;;3033   			}
;;;3034   			FREE_BUF();
;;;3035   		}
;;;3036   	}
;;;3037   
;;;3038   	LEAVE_FF(dj->fs, res);
;;;3039   }
000040  bdfe              POP      {r1-r7,pc}
                  |L21.66|
000042  2100              MOVS     r1,#0                 ;3018
000044  4620              MOV      r0,r4                 ;3018
000046  f7fffffe          BL       dir_sdi
00004a  bdfe              POP      {r1-r7,pc}
                  |L21.76|
00004c  6126              STR      r6,[r4,#0x10]         ;3024
00004e  e7eb              B        |L21.40|
;;;3040   
                          ENDP


                          AREA ||i.f_rename||, CODE, READONLY, ALIGN=1

                  f_rename PROC
;;;3417   
;;;3418   FRESULT f_rename (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3419   	const TCHAR *path_old,	/* Pointer to the old name */
;;;3420   	const TCHAR *path_new	/* Pointer to the new name */
;;;3421   )
;;;3422   {
000002  b099              SUB      sp,sp,#0x64
000004  460c              MOV      r4,r1
;;;3423   	FRESULT res;
;;;3424   	DIR djo, djn;
;;;3425   	BYTE buf[21], *dir;
;;;3426   	DWORD dw;
;;;3427   	DEF_NAMEBUF;
;;;3428   
;;;3429   
;;;3430   	res = chk_mounted(&path_old, &djo.fs, 1);
000006  2201              MOVS     r2,#1
000008  a908              ADD      r1,sp,#0x20
00000a  a819              ADD      r0,sp,#0x64
00000c  f7fffffe          BL       chk_mounted
;;;3431   	if (res == FR_OK) {
000010  2800              CMP      r0,#0
000012  d151              BNE      |L22.184|
;;;3432   		djn.fs = djo.fs;
000014  9808              LDR      r0,[sp,#0x20]
;;;3433   		INIT_BUF(djo);
000016  9001              STR      r0,[sp,#4]
000018  a815              ADD      r0,sp,#0x54
;;;3434   		res = follow_path(&djo, path_old);		/* Check old object */
00001a  900e              STR      r0,[sp,#0x38]
00001c  a808              ADD      r0,sp,#0x20
00001e  9919              LDR      r1,[sp,#0x64]
000020  f7fffffe          BL       follow_path
;;;3435   		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
;;;3436   			res = FR_INVALID_NAME;
;;;3437   #if _FS_SHARE
;;;3438   		if (res == FR_OK) res = chk_lock(&djo, 2);
;;;3439   #endif
;;;3440   		if (res == FR_OK) {						/* Old object is found */
000024  2800              CMP      r0,#0
000026  d147              BNE      |L22.184|
;;;3441   			if (!djo.dir) {						/* Is root dir? */
000028  980d              LDR      r0,[sp,#0x34]
00002a  b3e8              CBZ      r0,|L22.168|
;;;3442   				res = FR_NO_FILE;
;;;3443   			} else {
;;;3444   				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
00002c  f100010b          ADD      r1,r0,#0xb
000030  2215              MOVS     r2,#0x15
000032  a80f              ADD      r0,sp,#0x3c
000034  f7fffffe          BL       mem_cpy
;;;3445   				mem_cpy(&djn, &djo, sizeof(DIR));		/* Check new object */
000038  221c              MOVS     r2,#0x1c
00003a  a908              ADD      r1,sp,#0x20
00003c  a801              ADD      r0,sp,#4
00003e  f7fffffe          BL       mem_cpy
;;;3446   				res = follow_path(&djn, path_new);
000042  4621              MOV      r1,r4
000044  a801              ADD      r0,sp,#4
000046  f7fffffe          BL       follow_path
;;;3447   				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
00004a  b370              CBZ      r0,|L22.170|
;;;3448   				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
00004c  2804              CMP      r0,#4
00004e  d133              BNE      |L22.184|
;;;3449   /* Start critical section that any interruption or error can cause cross-link */
;;;3450   					res = dir_register(&djn);			/* Register the new entry */
000050  a801              ADD      r0,sp,#4
000052  f7fffffe          BL       dir_register
;;;3451   					if (res == FR_OK) {
000056  2800              CMP      r0,#0
000058  d12e              BNE      |L22.184|
;;;3452   						dir = djn.dir;					/* Copy object information except for name */
;;;3453   						mem_cpy(dir+13, buf+2, 19);
00005a  9c06              LDR      r4,[sp,#0x18]
00005c  2213              MOVS     r2,#0x13
00005e  f10d013e          ADD      r1,sp,#0x3e
000062  f104000d          ADD      r0,r4,#0xd
000066  f7fffffe          BL       mem_cpy
;;;3454   						dir[DIR_Attr] = buf[0] | AM_ARC;
00006a  f89d003c          LDRB     r0,[sp,#0x3c]
;;;3455   						djo.fs->wflag = 1;
00006e  2501              MOVS     r5,#1
000070  f0400020          ORR      r0,r0,#0x20           ;3454
000074  72e0              STRB     r0,[r4,#0xb]          ;3454
000076  9808              LDR      r0,[sp,#0x20]
000078  7105              STRB     r5,[r0,#4]
;;;3456   						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
00007a  9903              LDR      r1,[sp,#0xc]
00007c  980a              LDR      r0,[sp,#0x28]
00007e  4288              CMP      r0,r1
000080  d035              BEQ      |L22.238|
000082  7ae0              LDRB     r0,[r4,#0xb]
000084  06c0              LSLS     r0,r0,#27
000086  d532              BPL      |L22.238|
;;;3457   							dw = clust2sect(djn.fs, LD_CLUST(dir));
000088  8aa0              LDRH     r0,[r4,#0x14]
00008a  8b61              LDRH     r1,[r4,#0x1a]
00008c  f360411f          BFI      r1,r0,#16,#16
000090  9801              LDR      r0,[sp,#4]
000092  f7fffffe          BL       clust2sect
000096  0001              MOVS     r1,r0
;;;3458   							if (!dw) {
000098  d012              BEQ      |L22.192|
;;;3459   								res = FR_INT_ERR;
;;;3460   							} else {
;;;3461   								res = move_window(djn.fs, dw);
00009a  9801              LDR      r0,[sp,#4]
00009c  f7fffffe          BL       move_window
;;;3462   								dir = djn.fs->win+SZ_DIR;	/* .. entry */
0000a0  9901              LDR      r1,[sp,#4]
0000a2  3150              ADDS     r1,r1,#0x50
;;;3463   								if (res == FR_OK && dir[1] == '.') {
0000a4  2800              CMP      r0,#0
0000a6  e001              B        |L22.172|
                  |L22.168|
0000a8  e005              B        |L22.182|
                  |L22.170|
0000aa  e007              B        |L22.188|
                  |L22.172|
0000ac  d104              BNE      |L22.184|
0000ae  7848              LDRB     r0,[r1,#1]
0000b0  282e              CMP      r0,#0x2e
0000b2  d007              BEQ      |L22.196|
0000b4  e01b              B        |L22.238|
                  |L22.182|
0000b6  2004              MOVS     r0,#4                 ;3442
                  |L22.184|
;;;3464   									dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
;;;3465   									ST_CLUST(dir, dw);
;;;3466   									djn.fs->wflag = 1;
;;;3467   								}
;;;3468   							}
;;;3469   						}
;;;3470   						if (res == FR_OK) {
;;;3471   							res = dir_remove(&djo);		/* Remove old entry */
;;;3472   							if (res == FR_OK)
;;;3473   								res = sync(djo.fs);
;;;3474   						}
;;;3475   					}
;;;3476   /* End critical section */
;;;3477   				}
;;;3478   			}
;;;3479   		}
;;;3480   		FREE_BUF();
;;;3481   	}
;;;3482   	LEAVE_FF(djo.fs, res);
;;;3483   }
0000b8  b01b              ADD      sp,sp,#0x6c
0000ba  bd30              POP      {r4,r5,pc}
                  |L22.188|
0000bc  2008              MOVS     r0,#8                 ;3447
0000be  e7fb              B        |L22.184|
                  |L22.192|
0000c0  2002              MOVS     r0,#2                 ;3459
0000c2  e7f9              B        |L22.184|
                  |L22.196|
0000c4  9801              LDR      r0,[sp,#4]            ;3464
0000c6  7800              LDRB     r0,[r0,#0]            ;3464
0000c8  2803              CMP      r0,#3                 ;3464
0000ca  d106              BNE      |L22.218|
0000cc  9a01              LDR      r2,[sp,#4]            ;3464
0000ce  9803              LDR      r0,[sp,#0xc]          ;3464
0000d0  6a52              LDR      r2,[r2,#0x24]         ;3464
0000d2  4290              CMP      r0,r2                 ;3464
0000d4  d101              BNE      |L22.218|
0000d6  2000              MOVS     r0,#0                 ;3464
0000d8  e000              B        |L22.220|
                  |L22.218|
0000da  9803              LDR      r0,[sp,#0xc]          ;3464
                  |L22.220|
0000dc  7688              STRB     r0,[r1,#0x1a]         ;3465
0000de  0a02              LSRS     r2,r0,#8              ;3465
0000e0  76ca              STRB     r2,[r1,#0x1b]         ;3465
0000e2  0c02              LSRS     r2,r0,#16             ;3465
0000e4  750a              STRB     r2,[r1,#0x14]         ;3465
0000e6  0e00              LSRS     r0,r0,#24             ;3465
0000e8  7548              STRB     r0,[r1,#0x15]         ;3465
0000ea  9801              LDR      r0,[sp,#4]            ;3466
0000ec  7105              STRB     r5,[r0,#4]            ;3466
                  |L22.238|
0000ee  a808              ADD      r0,sp,#0x20           ;3471
0000f0  f7fffffe          BL       dir_remove
0000f4  2800              CMP      r0,#0                 ;3472
0000f6  d1df              BNE      |L22.184|
0000f8  9808              LDR      r0,[sp,#0x20]         ;3473
0000fa  f7fffffe          BL       sync
0000fe  e7db              B        |L22.184|
;;;3484   
                          ENDP


                          AREA ||i.f_stat||, CODE, READONLY, ALIGN=1

                  f_stat PROC
;;;3047   
;;;3048   FRESULT f_stat (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3049   	const TCHAR *path,	/* Pointer to the file path */
;;;3050   	FILINFO *fno		/* Pointer to file information to return */
;;;3051   )
;;;3052   {
000002  b08b              SUB      sp,sp,#0x2c
000004  460d              MOV      r5,r1
;;;3053   	FRESULT res;
;;;3054   	DIR dj;
;;;3055   	DEF_NAMEBUF;
;;;3056   
;;;3057   
;;;3058   	res = chk_mounted(&path, &dj.fs, 0);
000006  2200              MOVS     r2,#0
000008  4669              MOV      r1,sp
00000a  a80b              ADD      r0,sp,#0x2c
00000c  f7fffffe          BL       chk_mounted
000010  0004              MOVS     r4,r0
;;;3059   	if (res == FR_OK) {
000012  d10f              BNE      |L23.52|
;;;3060   		INIT_BUF(dj);
000014  a807              ADD      r0,sp,#0x1c
;;;3061   		res = follow_path(&dj, path);	/* Follow the file path */
000016  9006              STR      r0,[sp,#0x18]
000018  4668              MOV      r0,sp
00001a  990b              LDR      r1,[sp,#0x2c]
00001c  f7fffffe          BL       follow_path
000020  0004              MOVS     r4,r0
;;;3062   		if (res == FR_OK) {				/* Follow completed */
000022  d107              BNE      |L23.52|
;;;3063   			if (dj.dir)		/* Found an object */
000024  9805              LDR      r0,[sp,#0x14]
000026  b120              CBZ      r0,|L23.50|
;;;3064   				get_fileinfo(&dj, fno);
000028  4629              MOV      r1,r5
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       get_fileinfo
000030  e000              B        |L23.52|
                  |L23.50|
;;;3065   			else			/* It is root dir */
;;;3066   				res = FR_INVALID_NAME;
000032  2406              MOVS     r4,#6
                  |L23.52|
;;;3067   		}
;;;3068   		FREE_BUF();
;;;3069   	}
;;;3070   
;;;3071   	LEAVE_FF(dj.fs, res);
;;;3072   }
000034  b00d              ADD      sp,sp,#0x34
000036  4620              MOV      r0,r4                 ;3071
000038  bd30              POP      {r4,r5,pc}
;;;3073   
                          ENDP


                          AREA ||i.f_sync||, CODE, READONLY, ALIGN=1

                  f_sync PROC
;;;2596   
;;;2597   FRESULT f_sync (
000000  b570              PUSH     {r4-r6,lr}
;;;2598   	FIL *fp		/* Pointer to the file object */
;;;2599   )
;;;2600   {
000002  4604              MOV      r4,r0
;;;2601   	FRESULT res;
;;;2602   	DWORD tim;
;;;2603   	BYTE *dir;
;;;2604   
;;;2605   
;;;2606   	res = validate(fp->fs, fp->id);		/* Check validity of the object */
000004  8881              LDRH     r1,[r0,#4]
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       validate
;;;2607   	if (res == FR_OK) {
00000c  2800              CMP      r0,#0
00000e  d10e              BNE      |L24.46|
;;;2608   		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
000010  79a1              LDRB     r1,[r4,#6]
000012  068a              LSLS     r2,r1,#26
000014  d50b              BPL      |L24.46|
;;;2609   #if !_FS_TINY	/* Write-back dirty buffer */
;;;2610   			if (fp->flag & FA__DIRTY) {
000016  0648              LSLS     r0,r1,#25
000018  d50e              BPL      |L24.56|
;;;2611   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
00001a  6820              LDR      r0,[r4,#0]
00001c  2301              MOVS     r3,#1
00001e  f1040124          ADD      r1,r4,#0x24
000022  7840              LDRB     r0,[r0,#1]
000024  69a2              LDR      r2,[r4,#0x18]
000026  f7fffffe          BL       disk_write
00002a  b108              CBZ      r0,|L24.48|
;;;2612   					LEAVE_FF(fp->fs, FR_DISK_ERR);
00002c  2001              MOVS     r0,#1
                  |L24.46|
;;;2613   				fp->flag &= ~FA__DIRTY;
;;;2614   			}
;;;2615   #endif
;;;2616   			/* Update the directory entry */
;;;2617   			res = move_window(fp->fs, fp->dir_sect);
;;;2618   			if (res == FR_OK) {
;;;2619   				dir = fp->dir_ptr;
;;;2620   				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
;;;2621   				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
;;;2622   				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
;;;2623   				tim = get_fattime();						/* Update updated time */
;;;2624   				ST_DWORD(dir+DIR_WrtTime, tim);
;;;2625   				fp->flag &= ~FA__WRITTEN;
;;;2626   				fp->fs->wflag = 1;
;;;2627   				res = sync(fp->fs);
;;;2628   			}
;;;2629   		}
;;;2630   	}
;;;2631   
;;;2632   	LEAVE_FF(fp->fs, res);
;;;2633   }
00002e  bd70              POP      {r4-r6,pc}
                  |L24.48|
000030  79a0              LDRB     r0,[r4,#6]            ;2613
000032  f0200040          BIC      r0,r0,#0x40           ;2613
000036  71a0              STRB     r0,[r4,#6]            ;2613
                  |L24.56|
000038  69e1              LDR      r1,[r4,#0x1c]         ;2617
00003a  6820              LDR      r0,[r4,#0]            ;2617
00003c  f7fffffe          BL       move_window
000040  2800              CMP      r0,#0                 ;2618
000042  d1f4              BNE      |L24.46|
000044  6a25              LDR      r5,[r4,#0x20]         ;2620
000046  7ae8              LDRB     r0,[r5,#0xb]          ;2620
000048  f0400020          ORR      r0,r0,#0x20           ;2620
00004c  72e8              STRB     r0,[r5,#0xb]          ;2620
00004e  7b20              LDRB     r0,[r4,#0xc]          ;2621
000050  7728              STRB     r0,[r5,#0x1c]         ;2621
000052  89a0              LDRH     r0,[r4,#0xc]          ;2621
000054  0a00              LSRS     r0,r0,#8              ;2621
000056  7768              STRB     r0,[r5,#0x1d]         ;2621
000058  68e0              LDR      r0,[r4,#0xc]          ;2621
00005a  0c00              LSRS     r0,r0,#16             ;2621
00005c  77a8              STRB     r0,[r5,#0x1e]         ;2621
00005e  68e0              LDR      r0,[r4,#0xc]          ;2621
000060  0e00              LSRS     r0,r0,#24             ;2621
000062  77e8              STRB     r0,[r5,#0x1f]         ;2621
000064  7c20              LDRB     r0,[r4,#0x10]         ;2622
000066  76a8              STRB     r0,[r5,#0x1a]         ;2622
000068  8a20              LDRH     r0,[r4,#0x10]         ;2622
00006a  0a00              LSRS     r0,r0,#8              ;2622
00006c  76e8              STRB     r0,[r5,#0x1b]         ;2622
00006e  6920              LDR      r0,[r4,#0x10]         ;2622
000070  0c00              LSRS     r0,r0,#16             ;2622
000072  7528              STRB     r0,[r5,#0x14]         ;2622
000074  6920              LDR      r0,[r4,#0x10]         ;2622
000076  0e00              LSRS     r0,r0,#24             ;2622
000078  7568              STRB     r0,[r5,#0x15]         ;2622
00007a  f7fffffe          BL       get_fattime
00007e  75a8              STRB     r0,[r5,#0x16]         ;2624
000080  0a01              LSRS     r1,r0,#8              ;2624
000082  75e9              STRB     r1,[r5,#0x17]         ;2624
000084  0c01              LSRS     r1,r0,#16             ;2624
000086  7629              STRB     r1,[r5,#0x18]         ;2624
000088  0e00              LSRS     r0,r0,#24             ;2624
00008a  7668              STRB     r0,[r5,#0x19]         ;2624
00008c  79a0              LDRB     r0,[r4,#6]            ;2625
00008e  f0200020          BIC      r0,r0,#0x20           ;2625
000092  71a0              STRB     r0,[r4,#6]            ;2625
000094  6821              LDR      r1,[r4,#0]            ;2626
000096  2001              MOVS     r0,#1                 ;2626
000098  7108              STRB     r0,[r1,#4]            ;2626
00009a  6820              LDR      r0,[r4,#0]            ;2627
00009c  e8bd4070          POP      {r4-r6,lr}            ;2627
0000a0  f7ffbffe          B.W      sync
;;;2634   
                          ENDP


                          AREA ||i.f_truncate||, CODE, READONLY, ALIGN=1

                  f_truncate PROC
;;;3145   
;;;3146   FRESULT f_truncate (
000000  b570              PUSH     {r4-r6,lr}
;;;3147   	FIL *fp		/* Pointer to the file object */
;;;3148   )
;;;3149   {
000002  4604              MOV      r4,r0
;;;3150   	FRESULT res;
;;;3151   	DWORD ncl;
;;;3152   
;;;3153   
;;;3154   	res = validate(fp->fs, fp->id);		/* Check validity of the object */
000004  8881              LDRH     r1,[r0,#4]
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       validate
00000c  0005              MOVS     r5,r0
;;;3155   	if (res == FR_OK) {
00000e  d13d              BNE      |L25.140|
;;;3156   		if (fp->flag & FA__ERROR) {			/* Check abort flag */
000010  79a1              LDRB     r1,[r4,#6]
000012  0608              LSLS     r0,r1,#24
000014  d501              BPL      |L25.26|
;;;3157   			res = FR_INT_ERR;
000016  2502              MOVS     r5,#2
000018  e038              B        |L25.140|
                  |L25.26|
;;;3158   		} else {
;;;3159   			if (!(fp->flag & FA_WRITE))		/* Check access mode */
00001a  0788              LSLS     r0,r1,#30
00001c  d401              BMI      |L25.34|
;;;3160   				res = FR_DENIED;
00001e  2507              MOVS     r5,#7
000020  e034              B        |L25.140|
                  |L25.34|
000022  e9d40202          LDRD     r0,r2,[r4,#8]
;;;3161   		}
;;;3162   	}
;;;3163   	if (res == FR_OK) {
;;;3164   		if (fp->fsize > fp->fptr) {
000026  4282              CMP      r2,r0
000028  d930              BLS      |L25.140|
;;;3165   			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
;;;3166   			fp->flag |= FA__WRITTEN;
00002a  f0410120          ORR      r1,r1,#0x20
00002e  60e0              STR      r0,[r4,#0xc]
000030  71a1              STRB     r1,[r4,#6]
;;;3167   			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
000032  b150              CBZ      r0,|L25.74|
;;;3168   				res = remove_chain(fp->fs, fp->sclust);
;;;3169   				fp->sclust = 0;
;;;3170   			} else {				/* When truncate a part of the file, remove remaining clusters */
;;;3171   				ncl = get_fat(fp->fs, fp->clust);
000034  6961              LDR      r1,[r4,#0x14]
000036  6820              LDR      r0,[r4,#0]
000038  f7fffffe          BL       get_fat
00003c  4606              MOV      r6,r0
;;;3172   				res = FR_OK;
;;;3173   				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
00003e  1c40              ADDS     r0,r0,#1
000040  d00b              BEQ      |L25.90|
;;;3174   				if (ncl == 1) res = FR_INT_ERR;
000042  2e01              CMP      r6,#1
000044  d00b              BEQ      |L25.94|
;;;3175   				if (res == FR_OK && ncl < fp->fs->n_fatent) {
000046  b165              CBZ      r5,|L25.98|
000048  e01c              B        |L25.132|
                  |L25.74|
00004a  6921              LDR      r1,[r4,#0x10]         ;3168
00004c  6820              LDR      r0,[r4,#0]            ;3168
00004e  f7fffffe          BL       remove_chain
000052  4605              MOV      r5,r0                 ;3168
000054  2000              MOVS     r0,#0                 ;3169
000056  6120              STR      r0,[r4,#0x10]         ;3169
000058  e013              B        |L25.130|
                  |L25.90|
00005a  2501              MOVS     r5,#1                 ;3173
00005c  e012              B        |L25.132|
                  |L25.94|
00005e  2502              MOVS     r5,#2                 ;3174
000060  e010              B        |L25.132|
                  |L25.98|
000062  6820              LDR      r0,[r4,#0]
000064  6981              LDR      r1,[r0,#0x18]
000066  42b1              CMP      r1,r6
000068  d910              BLS      |L25.140|
;;;3176   					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
00006a  f06f4270          MVN      r2,#0xf0000000
00006e  6961              LDR      r1,[r4,#0x14]
000070  f7fffffe          BL       put_fat
000074  0005              MOVS     r5,r0
;;;3177   					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
000076  d105              BNE      |L25.132|
000078  4631              MOV      r1,r6
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       remove_chain
000080  4605              MOV      r5,r0
                  |L25.130|
;;;3178   				}
;;;3179   			}
;;;3180   		}
;;;3181   		if (res != FR_OK) fp->flag |= FA__ERROR;
000082  b11d              CBZ      r5,|L25.140|
                  |L25.132|
000084  79a0              LDRB     r0,[r4,#6]
000086  f0400080          ORR      r0,r0,#0x80
00008a  71a0              STRB     r0,[r4,#6]
                  |L25.140|
;;;3182   	}
;;;3183   
;;;3184   	LEAVE_FF(fp->fs, res);
00008c  4628              MOV      r0,r5
;;;3185   }
00008e  bd70              POP      {r4-r6,pc}
;;;3186   
                          ENDP


                          AREA ||i.f_unlink||, CODE, READONLY, ALIGN=1

                  f_unlink PROC
;;;3193   
;;;3194   FRESULT f_unlink (
000000  b511              PUSH     {r0,r4,lr}
;;;3195   	const TCHAR *path		/* Pointer to the file or directory path */
;;;3196   )
;;;3197   {
000002  b091              SUB      sp,sp,#0x44
;;;3198   	FRESULT res;
;;;3199   	DIR dj, sdj;
;;;3200   	BYTE *dir;
;;;3201   	DWORD dclst;
;;;3202   	DEF_NAMEBUF;
;;;3203   
;;;3204   
;;;3205   	res = chk_mounted(&path, &dj.fs, 1);
000004  2201              MOVS     r2,#1
000006  4669              MOV      r1,sp
000008  a811              ADD      r0,sp,#0x44
00000a  f7fffffe          BL       chk_mounted
;;;3206   	if (res == FR_OK) {
00000e  2800              CMP      r0,#0
000010  d119              BNE      |L26.70|
;;;3207   		INIT_BUF(dj);
000012  a80e              ADD      r0,sp,#0x38
;;;3208   		res = follow_path(&dj, path);		/* Follow the file path */
000014  9006              STR      r0,[sp,#0x18]
000016  4668              MOV      r0,sp
000018  9911              LDR      r1,[sp,#0x44]
00001a  f7fffffe          BL       follow_path
;;;3209   		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
;;;3210   			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
;;;3211   #if _FS_SHARE
;;;3212   		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
;;;3213   #endif
;;;3214   		if (res == FR_OK) {					/* The object is accessible */
00001e  2800              CMP      r0,#0
000020  d111              BNE      |L26.70|
;;;3215   			dir = dj.dir;
;;;3216   			if (!dir) {
000022  9a05              LDR      r2,[sp,#0x14]
000024  b18a              CBZ      r2,|L26.74|
;;;3217   				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
;;;3218   			} else {
;;;3219   				if (dir[DIR_Attr] & AM_RDO)
000026  7ad1              LDRB     r1,[r2,#0xb]
000028  07c9              LSLS     r1,r1,#31
00002a  d000              BEQ      |L26.46|
;;;3220   					res = FR_DENIED;		/* Cannot remove R/O object */
00002c  2007              MOVS     r0,#7
                  |L26.46|
;;;3221   			}
;;;3222   			dclst = LD_CLUST(dir);
00002e  8a91              LDRH     r1,[r2,#0x14]
000030  8b54              LDRH     r4,[r2,#0x1a]
;;;3223   			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
000032  2800              CMP      r0,#0
000034  f361441f          BFI      r4,r1,#16,#16         ;3222
000038  d105              BNE      |L26.70|
00003a  7ad0              LDRB     r0,[r2,#0xb]
00003c  06c0              LSLS     r0,r0,#27
00003e  d51a              BPL      |L26.118|
;;;3224   				if (dclst < 2) {
000040  2c02              CMP      r4,#2
000042  d204              BCS      |L26.78|
;;;3225   					res = FR_INT_ERR;
000044  2002              MOVS     r0,#2
                  |L26.70|
;;;3226   				} else {
;;;3227   					mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
;;;3228   					sdj.sclust = dclst;
;;;3229   					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
;;;3230   					if (res == FR_OK) {
;;;3231   						res = dir_read(&sdj);
;;;3232   						if (res == FR_OK			/* Not empty dir */
;;;3233   #if _FS_RPATH
;;;3234   						|| dclst == sdj.fs->cdir	/* Current dir */
;;;3235   #endif
;;;3236   						) res = FR_DENIED;
;;;3237   						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
;;;3238   					}
;;;3239   				}
;;;3240   			}
;;;3241   			if (res == FR_OK) {
;;;3242   				res = dir_remove(&dj);		/* Remove the directory entry */
;;;3243   				if (res == FR_OK) {
;;;3244   					if (dclst)				/* Remove the cluster chain if exist */
;;;3245   						res = remove_chain(dj.fs, dclst);
;;;3246   					if (res == FR_OK) res = sync(dj.fs);
;;;3247   				}
;;;3248   			}
;;;3249   		}
;;;3250   		FREE_BUF();
;;;3251   	}
;;;3252   	LEAVE_FF(dj.fs, res);
;;;3253   }
000046  b012              ADD      sp,sp,#0x48
000048  bd10              POP      {r4,pc}
                  |L26.74|
00004a  2006              MOVS     r0,#6                 ;3217
00004c  e7ef              B        |L26.46|
                  |L26.78|
00004e  221c              MOVS     r2,#0x1c              ;3227
000050  4669              MOV      r1,sp                 ;3227
000052  a807              ADD      r0,sp,#0x1c           ;3227
000054  f7fffffe          BL       mem_cpy
000058  2102              MOVS     r1,#2                 ;3229
00005a  a807              ADD      r0,sp,#0x1c           ;3229
00005c  9409              STR      r4,[sp,#0x24]         ;3229
00005e  f7fffffe          BL       dir_sdi
000062  2800              CMP      r0,#0                 ;3230
000064  d1ef              BNE      |L26.70|
000066  a807              ADD      r0,sp,#0x1c           ;3231
000068  f7fffffe          BL       dir_read
00006c  b198              CBZ      r0,|L26.150|
00006e  2804              CMP      r0,#4                 ;3237
000070  d001              BEQ      |L26.118|
000072  2800              CMP      r0,#0                 ;3241
000074  d1e7              BNE      |L26.70|
                  |L26.118|
000076  4668              MOV      r0,sp                 ;3242
000078  f7fffffe          BL       dir_remove
00007c  2800              CMP      r0,#0                 ;3243
00007e  d1e2              BNE      |L26.70|
000080  b12c              CBZ      r4,|L26.142|
000082  4621              MOV      r1,r4                 ;3245
000084  9800              LDR      r0,[sp,#0]            ;3245
000086  f7fffffe          BL       remove_chain
00008a  2800              CMP      r0,#0                 ;3245
00008c  d1db              BNE      |L26.70|
                  |L26.142|
00008e  9800              LDR      r0,[sp,#0]            ;3246
000090  f7fffffe          BL       sync
000094  e7d7              B        |L26.70|
                  |L26.150|
000096  2007              MOVS     r0,#7                 ;3236
000098  e7d5              B        |L26.70|
;;;3254   
                          ENDP


                          AREA ||i.f_utime||, CODE, READONLY, ALIGN=1

                  f_utime PROC
;;;3376   
;;;3377   FRESULT f_utime (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;3378   	const TCHAR *path,	/* Pointer to the file/directory name */
;;;3379   	const FILINFO *fno	/* Pointer to the time stamp to be set */
;;;3380   )
;;;3381   {
000002  b08a              SUB      sp,sp,#0x28
000004  460c              MOV      r4,r1
;;;3382   	FRESULT res;
;;;3383   	DIR dj;
;;;3384   	BYTE *dir;
;;;3385   	DEF_NAMEBUF;
;;;3386   
;;;3387   
;;;3388   	res = chk_mounted(&path, &dj.fs, 1);
000006  2201              MOVS     r2,#1
000008  4669              MOV      r1,sp
00000a  a80a              ADD      r0,sp,#0x28
00000c  f7fffffe          BL       chk_mounted
;;;3389   	if (res == FR_OK) {
000010  2800              CMP      r0,#0
000012  d119              BNE      |L27.72|
;;;3390   		INIT_BUF(dj);
000014  a807              ADD      r0,sp,#0x1c
;;;3391   		res = follow_path(&dj, path);	/* Follow the file path */
000016  9006              STR      r0,[sp,#0x18]
000018  4668              MOV      r0,sp
00001a  990a              LDR      r1,[sp,#0x28]
00001c  f7fffffe          BL       follow_path
;;;3392   		FREE_BUF();
;;;3393   		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
;;;3394   			res = FR_INVALID_NAME;
;;;3395   		if (res == FR_OK) {
000020  2800              CMP      r0,#0
000022  d111              BNE      |L27.72|
;;;3396   			dir = dj.dir;
;;;3397   			if (!dir) {					/* Root directory */
000024  9805              LDR      r0,[sp,#0x14]
000026  b188              CBZ      r0,|L27.76|
;;;3398   				res = FR_INVALID_NAME;
;;;3399   			} else {					/* File or sub-directory */
;;;3400   				ST_WORD(dir+DIR_WrtTime, fno->ftime);
000028  79a1              LDRB     r1,[r4,#6]
00002a  7581              STRB     r1,[r0,#0x16]
00002c  88e1              LDRH     r1,[r4,#6]
00002e  0a09              LSRS     r1,r1,#8
000030  75c1              STRB     r1,[r0,#0x17]
;;;3401   				ST_WORD(dir+DIR_WrtDate, fno->fdate);
000032  7921              LDRB     r1,[r4,#4]
000034  7601              STRB     r1,[r0,#0x18]
000036  88a1              LDRH     r1,[r4,#4]
000038  0a09              LSRS     r1,r1,#8
00003a  7641              STRB     r1,[r0,#0x19]
;;;3402   				dj.fs->wflag = 1;
00003c  9900              LDR      r1,[sp,#0]
00003e  2001              MOVS     r0,#1
000040  7108              STRB     r0,[r1,#4]
;;;3403   				res = sync(dj.fs);
000042  9800              LDR      r0,[sp,#0]
000044  f7fffffe          BL       sync
                  |L27.72|
;;;3404   			}
;;;3405   		}
;;;3406   	}
;;;3407   
;;;3408   	LEAVE_FF(dj.fs, res);
;;;3409   }
000048  b00c              ADD      sp,sp,#0x30
00004a  bd10              POP      {r4,pc}
                  |L27.76|
00004c  2006              MOVS     r0,#6                 ;3398
00004e  e7fb              B        |L27.72|
;;;3410   
                          ENDP


                          AREA ||i.f_write||, CODE, READONLY, ALIGN=1

                  f_write PROC
;;;2477   
;;;2478   FRESULT f_write (
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2479   	FIL *fp,			/* Pointer to the file object */
;;;2480       const void *buff,	/* Pointer to the data to be written */
;;;2481   	UINT btw,			/* Number of bytes to write */
;;;2482   	UINT *bw			/* Pointer to number of bytes written */
;;;2483   )
;;;2484   {
;;;2485   	FRESULT res;
;;;2486   	DWORD clst, sect;
;;;2487   	UINT wcnt, cc;
;;;2488   	const BYTE *wbuff = buff;
000004  4689              MOV      r9,r1
;;;2489   	BYTE csect;
;;;2490   
;;;2491   
;;;2492   	*bw = 0;	/* Initialize byte counter */
000006  2100              MOVS     r1,#0
;;;2493   
;;;2494   	res = validate(fp->fs, fp->id);			/* Check validity */
000008  6019              STR      r1,[r3,#0]
00000a  4604              MOV      r4,r0                 ;2484
00000c  8881              LDRH     r1,[r0,#4]
00000e  469a              MOV      r10,r3                ;2484
000010  4616              MOV      r6,r2                 ;2484
000012  6800              LDR      r0,[r0,#0]
000014  f7fffffe          BL       validate
;;;2495   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000018  2800              CMP      r0,#0
00001a  d103              BNE      |L28.36|
;;;2496   	if (fp->flag & FA__ERROR)				/* Aborted file? */
00001c  79a0              LDRB     r0,[r4,#6]
00001e  0601              LSLS     r1,r0,#24
000020  d502              BPL      |L28.40|
                  |L28.34|
;;;2497   		LEAVE_FF(fp->fs, FR_INT_ERR);
000022  2002              MOVS     r0,#2
                  |L28.36|
;;;2498   	if (!(fp->flag & FA_WRITE))				/* Check access mode */
;;;2499   		LEAVE_FF(fp->fs, FR_DENIED);
;;;2500   	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
;;;2501   
;;;2502   	for ( ;  btw;							/* Repeat until all data written */
;;;2503   		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
;;;2504   		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
;;;2505   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2506   			if (!csect) {					/* On the cluster boundary? */
;;;2507   				if (fp->fptr == 0) {		/* On the top of the file? */
;;;2508   					clst = fp->sclust;		/* Follow from the origin */
;;;2509   					if (clst == 0)			/* When no cluster is allocated, */
;;;2510   						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
;;;2511   				} else {					/* Middle or end of the file */
;;;2512   #if _USE_FASTSEEK
;;;2513   					if (fp->cltbl)
;;;2514   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2515   					else
;;;2516   #endif
;;;2517   						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
;;;2518   				}
;;;2519   				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
;;;2520   				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;2521   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2522   				fp->clust = clst;			/* Update current cluster */
;;;2523   			}
;;;2524   #if _FS_TINY
;;;2525   			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
;;;2526   				ABORT(fp->fs, FR_DISK_ERR);
;;;2527   #else
;;;2528   			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
;;;2529   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2530   					ABORT(fp->fs, FR_DISK_ERR);
;;;2531   				fp->flag &= ~FA__DIRTY;
;;;2532   			}
;;;2533   #endif
;;;2534   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2535   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2536   			sect += csect;
;;;2537   			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
;;;2538   			if (cc) {						/* Write maximum contiguous sectors directly */
;;;2539   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2540   					cc = fp->fs->csize - csect;
;;;2541   				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
;;;2542   					ABORT(fp->fs, FR_DISK_ERR);
;;;2543   #if _FS_TINY
;;;2544   				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
;;;2545   					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2546   					fp->fs->wflag = 0;
;;;2547   				}
;;;2548   #else
;;;2549   				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
;;;2550   					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2551   					fp->flag &= ~FA__DIRTY;
;;;2552   				}
;;;2553   #endif
;;;2554   				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
;;;2555   				continue;
;;;2556   			}
;;;2557   #if _FS_TINY
;;;2558   			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
;;;2559   				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
;;;2560   				fp->fs->winsect = sect;
;;;2561   			}
;;;2562   #else
;;;2563   			if (fp->dsect != sect) {		/* Fill sector cache with file data */
;;;2564   				if (fp->fptr < fp->fsize &&
;;;2565   					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
;;;2566   						ABORT(fp->fs, FR_DISK_ERR);
;;;2567   			}
;;;2568   #endif
;;;2569   			fp->dsect = sect;
;;;2570   		}
;;;2571   		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
;;;2572   		if (wcnt > btw) wcnt = btw;
;;;2573   #if _FS_TINY
;;;2574   		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
;;;2575   			ABORT(fp->fs, FR_DISK_ERR);
;;;2576   		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2577   		fp->fs->wflag = 1;
;;;2578   #else
;;;2579   		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2580   		fp->flag |= FA__DIRTY;
;;;2581   #endif
;;;2582   	}
;;;2583   
;;;2584   	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
;;;2585   	fp->flag |= FA__WRITTEN;						/* Set file change flag */
;;;2586   
;;;2587   	LEAVE_FF(fp->fs, FR_OK);
;;;2588   }
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L28.40|
000028  0780              LSLS     r0,r0,#30             ;2498
00002a  d401              BMI      |L28.48|
00002c  2007              MOVS     r0,#7                 ;2499
00002e  e7f9              B        |L28.36|
                  |L28.48|
000030  68e0              LDR      r0,[r4,#0xc]          ;2500
000032  f1040b24          ADD      r11,r4,#0x24          ;2529
000036  1982              ADDS     r2,r0,r6              ;2500
000038  4282              CMP      r2,r0                 ;2500
00003a  d374              BCC      |L28.294|
00003c  e093              B        |L28.358|
                  |L28.62|
00003e  68a0              LDR      r0,[r4,#8]            ;2504
000040  05c1              LSLS     r1,r0,#23             ;2504
000042  d174              BNE      |L28.302|
000044  6822              LDR      r2,[r4,#0]            ;2505
000046  7891              LDRB     r1,[r2,#2]            ;2505
000048  1e49              SUBS     r1,r1,#1              ;2505
00004a  ea012150          AND      r1,r1,r0,LSR #9       ;2505
00004e  f01105ff          ANDS     r5,r1,#0xff           ;2505
000052  d10b              BNE      |L28.108|
000054  b1b0              CBZ      r0,|L28.132|
000056  4610              MOV      r0,r2                 ;2517
000058  6961              LDR      r1,[r4,#0x14]         ;2517
00005a  f7fffffe          BL       create_chain
                  |L28.94|
00005e  2800              CMP      r0,#0                 ;2519
000060  d061              BEQ      |L28.294|
                  |L28.98|
000062  2801              CMP      r0,#1                 ;2520
000064  d032              BEQ      |L28.204|
000066  1c41              ADDS     r1,r0,#1              ;2521
000068  d057              BEQ      |L28.282|
00006a  6160              STR      r0,[r4,#0x14]         ;2522
                  |L28.108|
00006c  79a0              LDRB     r0,[r4,#6]            ;2528
00006e  0640              LSLS     r0,r0,#25             ;2528
000070  d515              BPL      |L28.158|
000072  6820              LDR      r0,[r4,#0]            ;2529
000074  2301              MOVS     r3,#1                 ;2529
000076  4659              MOV      r1,r11                ;2529
000078  7840              LDRB     r0,[r0,#1]            ;2529
00007a  69a2              LDR      r2,[r4,#0x18]         ;2529
00007c  f7fffffe          BL       disk_write
000080  bbd8              CBNZ     r0,|L28.250|
000082  e008              B        |L28.150|
                  |L28.132|
000084  6920              LDR      r0,[r4,#0x10]         ;2509
000086  2800              CMP      r0,#0                 ;2509
000088  d1eb              BNE      |L28.98|
00008a  2100              MOVS     r1,#0                 ;2510
00008c  4610              MOV      r0,r2                 ;2510
00008e  f7fffffe          BL       create_chain
000092  6120              STR      r0,[r4,#0x10]         ;2510
000094  e7e3              B        |L28.94|
                  |L28.150|
000096  79a0              LDRB     r0,[r4,#6]            ;2531
000098  f0200040          BIC      r0,r0,#0x40           ;2531
00009c  71a0              STRB     r0,[r4,#6]            ;2531
                  |L28.158|
00009e  6961              LDR      r1,[r4,#0x14]         ;2534
0000a0  6820              LDR      r0,[r4,#0]            ;2534
0000a2  f7fffffe          BL       clust2sect
0000a6  b188              CBZ      r0,|L28.204|
0000a8  eb000805          ADD      r8,r0,r5              ;2536
0000ac  0a77              LSRS     r7,r6,#9              ;2537
0000ae  d025              BEQ      |L28.252|
0000b0  6820              LDR      r0,[r4,#0]            ;2539
0000b2  19ea              ADDS     r2,r5,r7              ;2539
0000b4  7881              LDRB     r1,[r0,#2]            ;2539
0000b6  428a              CMP      r2,r1                 ;2539
0000b8  d900              BLS      |L28.188|
0000ba  1b4f              SUBS     r7,r1,r5              ;2540
                  |L28.188|
0000bc  b2fb              UXTB     r3,r7                 ;2541
0000be  7840              LDRB     r0,[r0,#1]            ;2541
0000c0  4642              MOV      r2,r8                 ;2541
0000c2  4649              MOV      r1,r9                 ;2541
0000c4  f7fffffe          BL       disk_write
0000c8  b9b8              CBNZ     r0,|L28.250|
0000ca  e004              B        |L28.214|
                  |L28.204|
0000cc  79a0              LDRB     r0,[r4,#6]            ;2535
0000ce  f0400080          ORR      r0,r0,#0x80           ;2535
0000d2  71a0              STRB     r0,[r4,#6]            ;2535
0000d4  e7a5              B        |L28.34|
                  |L28.214|
0000d6  69a1              LDR      r1,[r4,#0x18]         ;2549
0000d8  eba10008          SUB      r0,r1,r8              ;2549
0000dc  42b8              CMP      r0,r7                 ;2549
0000de  d20a              BCS      |L28.246|
0000e0  eb092140          ADD      r1,r9,r0,LSL #9       ;2550
0000e4  f44f7200          MOV      r2,#0x200             ;2550
0000e8  4658              MOV      r0,r11                ;2550
0000ea  f7fffffe          BL       mem_cpy
0000ee  79a0              LDRB     r0,[r4,#6]            ;2551
0000f0  f0200040          BIC      r0,r0,#0x40           ;2551
0000f4  71a0              STRB     r0,[r4,#6]            ;2551
                  |L28.246|
0000f6  027d              LSLS     r5,r7,#9              ;2554
0000f8  e02b              B        |L28.338|
                  |L28.250|
0000fa  e00e              B        |L28.282|
                  |L28.252|
0000fc  69a1              LDR      r1,[r4,#0x18]         ;2563
0000fe  4541              CMP      r1,r8                 ;2563
000100  d013              BEQ      |L28.298|
000102  e9d40102          LDRD     r0,r1,[r4,#8]         ;2563
000106  4288              CMP      r0,r1                 ;2564
000108  d20f              BCS      |L28.298|
00010a  6820              LDR      r0,[r4,#0]            ;2565
00010c  2301              MOVS     r3,#1                 ;2565
00010e  4642              MOV      r2,r8                 ;2565
000110  7840              LDRB     r0,[r0,#1]            ;2565
000112  4659              MOV      r1,r11                ;2565
000114  f7fffffe          BL       disk_read
000118  b138              CBZ      r0,|L28.298|
                  |L28.282|
00011a  79a0              LDRB     r0,[r4,#6]            ;2566
00011c  f0400080          ORR      r0,r0,#0x80           ;2566
000120  71a0              STRB     r0,[r4,#6]            ;2566
000122  2001              MOVS     r0,#1                 ;2566
000124  e77e              B        |L28.36|
                  |L28.294|
000126  e021              B        |L28.364|
000128  e001              B        |L28.302|
                  |L28.298|
00012a  f8c48018          STR      r8,[r4,#0x18]         ;2569
                  |L28.302|
00012e  8920              LDRH     r0,[r4,#8]            ;2571
000130  f3c00008          UBFX     r0,r0,#0,#9           ;2571
000134  f5c07500          RSB      r5,r0,#0x200          ;2571
000138  42b5              CMP      r5,r6                 ;2572
00013a  d900              BLS      |L28.318|
00013c  4635              MOV      r5,r6                 ;2572
                  |L28.318|
00013e  4420              ADD      r0,r0,r4              ;2579
000140  462a              MOV      r2,r5                 ;2579
000142  4649              MOV      r1,r9                 ;2579
000144  3024              ADDS     r0,r0,#0x24           ;2579
000146  f7fffffe          BL       mem_cpy
00014a  79a0              LDRB     r0,[r4,#6]            ;2580
00014c  f0400040          ORR      r0,r0,#0x40           ;2580
000150  71a0              STRB     r0,[r4,#6]            ;2580
                  |L28.338|
000152  68a0              LDR      r0,[r4,#8]            ;2503
000154  44a9              ADD      r9,r9,r5              ;2503
000156  4428              ADD      r0,r0,r5              ;2503
000158  60a0              STR      r0,[r4,#8]            ;2503
00015a  f8da0000          LDR      r0,[r10,#0]           ;2503
00015e  1941              ADDS     r1,r0,r5              ;2503
000160  1b76              SUBS     r6,r6,r5              ;2503
000162  f8ca1000          STR      r1,[r10,#0]           ;2503
                  |L28.358|
000166  2e00              CMP      r6,#0                 ;2502
000168  f47faf69          BNE      |L28.62|
                  |L28.364|
00016c  e9d40102          LDRD     r0,r1,[r4,#8]         ;2502
000170  4288              CMP      r0,r1                 ;2584
000172  d900              BLS      |L28.374|
000174  60e0              STR      r0,[r4,#0xc]          ;2584
                  |L28.374|
000176  79a0              LDRB     r0,[r4,#6]            ;2585
000178  f0400020          ORR      r0,r0,#0x20           ;2585
00017c  71a0              STRB     r0,[r4,#6]            ;2585
00017e  2000              MOVS     r0,#0                 ;2587
000180  e750              B        |L28.36|
;;;2589   
                          ENDP


                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;1918   static
;;;1919   FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;1920   	DIR *dj,			/* Directory object to return last directory and found object */
;;;1921   	const TCHAR *path	/* Full-path string to find a file or directory */
;;;1922   )
;;;1923   {
000002  4604              MOV      r4,r0
;;;1924   	FRESULT res;
;;;1925   	BYTE *dir, ns;
;;;1926   
;;;1927   
;;;1928   #if _FS_RPATH //配置了相对路径
;;;1929   	if (*path == '/' || *path == '\\') { /* There is a heading separator 如果路径中第一个为/或者\*/
;;;1930   		path++;	dj->sclust = 0;		/* Strip it and start from the root dir 为根目录*/
;;;1931   	} else {							/* No heading separator */
;;;1932   		dj->sclust = dj->fs->cdir;	/* Start from the current dir 否者从当前目录开始*/
;;;1933   	}
;;;1934   #else
;;;1935   	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
000004  9901              LDR      r1,[sp,#4]
000006  7808              LDRB     r0,[r1,#0]
000008  282f              CMP      r0,#0x2f
00000a  d001              BEQ      |L29.16|
00000c  285c              CMP      r0,#0x5c
00000e  d101              BNE      |L29.20|
                  |L29.16|
000010  1c49              ADDS     r1,r1,#1
;;;1936   		path++;
000012  9101              STR      r1,[sp,#4]
                  |L29.20|
;;;1937   	dj->sclust = 0;						/* Start from the root dir */
000014  2500              MOVS     r5,#0
;;;1938   #endif
;;;1939   
;;;1940   	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
000016  60a5              STR      r5,[r4,#8]
000018  9801              LDR      r0,[sp,#4]
00001a  7800              LDRB     r0,[r0,#0]
00001c  2820              CMP      r0,#0x20
00001e  d205              BCS      |L29.44|
;;;1941   		res = dir_sdi(dj, 0);
000020  2100              MOVS     r1,#0
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       dir_sdi
;;;1942   		dj->dir = 0;
000028  6165              STR      r5,[r4,#0x14]
                  |L29.42|
;;;1943   
;;;1944   	} else {							/* Follow path */
;;;1945   		for (;;) {
;;;1946   			res = create_name(dj, &path);	/* Get a segment */
;;;1947   			if (res != FR_OK) break;
;;;1948   			res = dir_find(dj);				/* Find it */
;;;1949   			ns = *(dj->fn+NS);
;;;1950   			if (res != FR_OK) {				/* Failed to find the object */
;;;1951   				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
;;;1952   				/* Object not found */
;;;1953   				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
;;;1954   					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
;;;1955   					res = FR_OK;
;;;1956   					if (!(ns & NS_LAST)) continue;
;;;1957   				} else {							/* Could not find the object */
;;;1958   					if (!(ns & NS_LAST)) res = FR_NO_PATH;
;;;1959   				}
;;;1960   				break;
;;;1961   			}
;;;1962   			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
;;;1963   			dir = dj->dir;						/* There is next segment. Follow the sub directory */
;;;1964   			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
;;;1965   				res = FR_NO_PATH; break;
;;;1966   			}
;;;1967   			dj->sclust = LD_CLUST(dir);
;;;1968   		}
;;;1969   	}
;;;1970   
;;;1971   	return res;
;;;1972   }
00002a  bd7c              POP      {r2-r6,pc}
                  |L29.44|
00002c  a901              ADD      r1,sp,#4              ;1946
00002e  4620              MOV      r0,r4                 ;1946
000030  f7fffffe          BL       create_name
000034  2800              CMP      r0,#0                 ;1947
000036  d1f8              BNE      |L29.42|
000038  2100              MOVS     r1,#0                 ;1947
00003a  4620              MOV      r0,r4                 ;1947
00003c  f7fffffe          BL       dir_sdi
000040  b9f8              CBNZ     r0,|L29.130|
                  |L29.66|
000042  6921              LDR      r1,[r4,#0x10]         ;1947
000044  6820              LDR      r0,[r4,#0]            ;1947
000046  f7fffffe          BL       move_window
00004a  b9d0              CBNZ     r0,|L29.130|
00004c  6961              LDR      r1,[r4,#0x14]         ;1947
00004e  780a              LDRB     r2,[r1,#0]            ;1947
000050  b172              CBZ      r2,|L29.112|
000052  7aca              LDRB     r2,[r1,#0xb]          ;1947
000054  0712              LSLS     r2,r2,#28             ;1947
000056  d40e              BMI      |L29.118|
000058  230b              MOVS     r3,#0xb               ;1947
00005a  69a2              LDR      r2,[r4,#0x18]         ;1947
00005c  2500              MOVS     r5,#0                 ;1947
                  |L29.94|
00005e  1e5b              SUBS     r3,r3,#1              ;1947
000060  d308              BCC      |L29.116|
000062  f8115b01          LDRB     r5,[r1],#1            ;1947
000066  f8126b01          LDRB     r6,[r2],#1            ;1947
00006a  1bad              SUBS     r5,r5,r6              ;1947
00006c  d0f7              BEQ      |L29.94|
00006e  e002              B        |L29.118|
                  |L29.112|
000070  2004              MOVS     r0,#4                 ;1947
000072  e006              B        |L29.130|
                  |L29.116|
000074  b12d              CBZ      r5,|L29.130|
                  |L29.118|
000076  2100              MOVS     r1,#0                 ;1947
000078  4620              MOV      r0,r4                 ;1947
00007a  f7fffffe          BL       dir_next
00007e  2800              CMP      r0,#0                 ;1947
000080  d0df              BEQ      |L29.66|
                  |L29.130|
000082  69a1              LDR      r1,[r4,#0x18]         ;1949
000084  7ac9              LDRB     r1,[r1,#0xb]          ;1949
000086  b128              CBZ      r0,|L29.148|
000088  2804              CMP      r0,#4                 ;1951
00008a  d1ce              BNE      |L29.42|
00008c  0749              LSLS     r1,r1,#29             ;1958
00008e  d4cc              BMI      |L29.42|
                  |L29.144|
000090  2005              MOVS     r0,#5                 ;1958
                  |L29.146|
000092  bd7c              POP      {r2-r6,pc}
                  |L29.148|
000094  0749              LSLS     r1,r1,#29             ;1962
000096  d4fc              BMI      |L29.146|
000098  6960              LDR      r0,[r4,#0x14]         ;1964
00009a  7ac1              LDRB     r1,[r0,#0xb]          ;1964
00009c  06c9              LSLS     r1,r1,#27             ;1964
00009e  d5f7              BPL      |L29.144|
0000a0  8a81              LDRH     r1,[r0,#0x14]         ;1967
0000a2  8b40              LDRH     r0,[r0,#0x1a]         ;1967
0000a4  f361401f          BFI      r0,r1,#16,#16         ;1967
0000a8  60a0              STR      r0,[r4,#8]            ;1956
0000aa  e7bf              B        |L29.44|
;;;1973   
                          ENDP


                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=1

                  get_fat PROC
;;;818    
;;;819    DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;820    	FATFS *fs,	/* File system object */
;;;821    	DWORD clst	/* Cluster# to get the link information */
;;;822    )
;;;823    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;824    	UINT wc, bc;
;;;825    	BYTE *p;
;;;826    
;;;827    
;;;828    	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
000008  2902              CMP      r1,#2
00000a  d302              BCC      |L30.18|
00000c  69a0              LDR      r0,[r4,#0x18]
00000e  42a8              CMP      r0,r5
000010  d802              BHI      |L30.24|
                  |L30.18|
;;;829    		return 1;
000012  2001              MOVS     r0,#1
                  |L30.20|
;;;830    
;;;831    	switch (fs->fs_type) {
;;;832    	case FS_FAT12 :
;;;833    		bc = (UINT)clst; bc += bc / 2;
;;;834    		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
;;;835    		wc = fs->win[bc % SS(fs)]; bc++;
;;;836    		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
;;;837    		wc |= fs->win[bc % SS(fs)] << 8;
;;;838    		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
;;;839    
;;;840    	case FS_FAT16 :
;;;841    		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
;;;842    		p = &fs->win[clst * 2 % SS(fs)];
;;;843    		return LD_WORD(p);
;;;844    
;;;845    	case FS_FAT32 :
;;;846    		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
;;;847    		p = &fs->win[clst * 4 % SS(fs)];
;;;848    		return LD_DWORD(p) & 0x0FFFFFFF;
;;;849    	}
;;;850    
;;;851    	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
;;;852    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L30.24|
000018  7820              LDRB     r0,[r4,#0]            ;831
00001a  2801              CMP      r0,#1                 ;831
00001c  d004              BEQ      |L30.40|
00001e  2802              CMP      r0,#2                 ;831
000020  d026              BEQ      |L30.112|
000022  2803              CMP      r0,#3                 ;831
000024  d137              BNE      |L30.150|
000026  e02f              B        |L30.136|
                  |L30.40|
000028  6a20              LDR      r0,[r4,#0x20]         ;834
00002a  eb050655          ADD      r6,r5,r5,LSR #1       ;833
00002e  eb002156          ADD      r1,r0,r6,LSR #9       ;834
000032  4620              MOV      r0,r4                 ;834
000034  f7fffffe          BL       move_window
000038  bb68              CBNZ     r0,|L30.150|
00003a  f3c60008          UBFX     r0,r6,#0,#9           ;835
00003e  4420              ADD      r0,r0,r4              ;835
000040  1c76              ADDS     r6,r6,#1              ;836
000042  f8907030          LDRB     r7,[r0,#0x30]         ;835
000046  6a20              LDR      r0,[r4,#0x20]         ;836
000048  eb002156          ADD      r1,r0,r6,LSR #9       ;836
00004c  4620              MOV      r0,r4                 ;836
00004e  f7fffffe          BL       move_window
000052  bb00              CBNZ     r0,|L30.150|
000054  f3c60008          UBFX     r0,r6,#0,#9           ;837
000058  4420              ADD      r0,r0,r4              ;837
00005a  07e9              LSLS     r1,r5,#31             ;838
00005c  f8900030          LDRB     r0,[r0,#0x30]         ;837
000060  ea472000          ORR      r0,r7,r0,LSL #8       ;837
000064  d001              BEQ      |L30.106|
000066  0900              LSRS     r0,r0,#4              ;838
000068  e7d4              B        |L30.20|
                  |L30.106|
00006a  f3c0000b          UBFX     r0,r0,#0,#12          ;838
00006e  e7d1              B        |L30.20|
                  |L30.112|
000070  6a20              LDR      r0,[r4,#0x20]         ;841
000072  eb002115          ADD      r1,r0,r5,LSR #8       ;841
000076  4620              MOV      r0,r4                 ;841
000078  f7fffffe          BL       move_window
00007c  b958              CBNZ     r0,|L30.150|
00007e  b2e8              UXTB     r0,r5                 ;842
000080  eb040040          ADD      r0,r4,r0,LSL #1       ;842
000084  8e00              LDRH     r0,[r0,#0x30]         ;843
000086  e7c5              B        |L30.20|
                  |L30.136|
000088  6a20              LDR      r0,[r4,#0x20]         ;846
00008a  eb0011d5          ADD      r1,r0,r5,LSR #7       ;846
00008e  4620              MOV      r0,r4                 ;846
000090  f7fffffe          BL       move_window
000094  b110              CBZ      r0,|L30.156|
                  |L30.150|
000096  f04f30ff          MOV      r0,#0xffffffff        ;851
00009a  e7bb              B        |L30.20|
                  |L30.156|
00009c  f24010ff          MOV      r0,#0x1ff             ;847
0000a0  ea000085          AND      r0,r0,r5,LSL #2       ;847
0000a4  4420              ADD      r0,r0,r4              ;847
0000a6  f8901030          LDRB     r1,[r0,#0x30]         ;848
0000aa  f8d00031          LDR      r0,[r0,#0x31]         ;848
0000ae  ea412000          ORR      r0,r1,r0,LSL #8       ;848
0000b2  f0204070          BIC      r0,r0,#0xf0000000     ;848
0000b6  e7ad              B        |L30.20|
;;;853    
                          ENDP


                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;1836   static
;;;1837   void get_fileinfo (		/* No return code */
000000  b510              PUSH     {r4,lr}
;;;1838   	DIR *dj,			/* Pointer to the directory object */
;;;1839   	FILINFO *fno	 	/* Pointer to the file information to be filled */
;;;1840   )
;;;1841   {
000002  6903              LDR      r3,[r0,#0x10]
;;;1842   	UINT i;
;;;1843   	BYTE nt, *dir;
;;;1844   	TCHAR *p, c;
;;;1845   
;;;1846   
;;;1847   	p = fno->fname;
000004  f1010209          ADD      r2,r1,#9
000008  b33b              CBZ      r3,|L31.90|
;;;1848   	if (dj->sect) {
;;;1849   		dir = dj->dir;
00000a  6940              LDR      r0,[r0,#0x14]
;;;1850   		nt = dir[DIR_NTres];		/* NT flag */
;;;1851   		for (i = 0; i < 8; i++) {	/* Copy name body */
00000c  2400              MOVS     r4,#0
                  |L31.14|
;;;1852   			c = dir[i];
00000e  5d03              LDRB     r3,[r0,r4]
;;;1853   			if (c == ' ') break;
000010  2b20              CMP      r3,#0x20
000012  d007              BEQ      |L31.36|
;;;1854   			if (c == NDDE) c = (TCHAR)DDE;
000014  2b05              CMP      r3,#5
000016  d100              BNE      |L31.26|
000018  23e5              MOVS     r3,#0xe5
                  |L31.26|
;;;1855   			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
;;;1856   #if _LFN_UNICODE
;;;1857   			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
;;;1858   				c = (c << 8) | dir[++i];
;;;1859   			c = ff_convert(c, 1);
;;;1860   			if (!c) c = '?';
;;;1861   #endif
;;;1862   			*p++ = c;
00001a  1c64              ADDS     r4,r4,#1
00001c  f8023b01          STRB     r3,[r2],#1
000020  2c08              CMP      r4,#8                 ;1851
000022  d3f4              BCC      |L31.14|
                  |L31.36|
;;;1863   		}
;;;1864   		if (dir[8] != ' ') {		/* Copy name extension */
000024  7a03              LDRB     r3,[r0,#8]
000026  2b20              CMP      r3,#0x20
000028  d00b              BEQ      |L31.66|
;;;1865   			*p++ = '.';
00002a  232e              MOVS     r3,#0x2e
00002c  f8023b01          STRB     r3,[r2],#1
;;;1866   			for (i = 8; i < 11; i++) {
000030  2308              MOVS     r3,#8
                  |L31.50|
;;;1867   				c = dir[i];
000032  5cc4              LDRB     r4,[r0,r3]
;;;1868   				if (c == ' ') break;
000034  2c20              CMP      r4,#0x20
000036  d004              BEQ      |L31.66|
;;;1869   				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
;;;1870   #if _LFN_UNICODE
;;;1871   				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
;;;1872   					c = (c << 8) | dir[++i];
;;;1873   				c = ff_convert(c, 1);
;;;1874   				if (!c) c = '?';
;;;1875   #endif
;;;1876   				*p++ = c;
000038  1c5b              ADDS     r3,r3,#1
00003a  f8024b01          STRB     r4,[r2],#1
00003e  2b0b              CMP      r3,#0xb               ;1866
000040  d3f7              BCC      |L31.50|
                  |L31.66|
;;;1877   			}
;;;1878   		}
;;;1879   		fno->fattrib = dir[DIR_Attr];				/* Attribute */
000042  7ac3              LDRB     r3,[r0,#0xb]
000044  720b              STRB     r3,[r1,#8]
;;;1880   		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
000046  7f03              LDRB     r3,[r0,#0x1c]
000048  f8d0401d          LDR      r4,[r0,#0x1d]
00004c  ea432304          ORR      r3,r3,r4,LSL #8
;;;1881   		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
000050  600b              STR      r3,[r1,#0]
000052  8b03              LDRH     r3,[r0,#0x18]
000054  808b              STRH     r3,[r1,#4]
;;;1882   		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
000056  8ac0              LDRH     r0,[r0,#0x16]
000058  80c8              STRH     r0,[r1,#6]
                  |L31.90|
;;;1883   	}
;;;1884   	*p = 0;		/* Terminate SFN str by a \0 */
00005a  2000              MOVS     r0,#0
00005c  7010              STRB     r0,[r2,#0]
;;;1885   
;;;1886   #if _USE_LFN
;;;1887   	if (fno->lfname && fno->lfsize) {
;;;1888   		TCHAR *tp = fno->lfname;
;;;1889   		WCHAR w, *lfn;
;;;1890   
;;;1891   		i = 0;
;;;1892   		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
;;;1893   			lfn = dj->lfn;
;;;1894   			while ((w = *lfn++) != 0) {			/* Get an LFN char */
;;;1895   #if !_LFN_UNICODE
;;;1896   				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
;;;1897   				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
;;;1898   				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
;;;1899   					tp[i++] = (TCHAR)(w >> 8);
;;;1900   #endif
;;;1901   				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
;;;1902   				tp[i++] = (TCHAR)w;
;;;1903   			}
;;;1904   		}
;;;1905   		tp[i] = 0;	/* Terminate the LFN str by a \0 */
;;;1906   	}
;;;1907   #endif
;;;1908   }
00005e  bd10              POP      {r4,pc}
;;;1909   #endif /* _FS_MINIMIZE <= 1 */
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=1

                  mem_cpy PROC
;;;528    static
;;;529    void mem_cpy (void* dst, const void* src, UINT cnt) {
000000  e003              B        |L32.10|
                  |L32.2|
;;;530    	BYTE *d = (BYTE*)dst;
;;;531    	const BYTE *s = (const BYTE*)src;
;;;532    
;;;533    #if _WORD_ACCESS == 1
;;;534    	while (cnt >= sizeof(int)) {
;;;535    		*(int*)d = *(int*)s;
;;;536    		d += sizeof(int); s += sizeof(int);
;;;537    		cnt -= sizeof(int);
;;;538    	}
;;;539    #endif
;;;540    	while (cnt--)
;;;541    		*d++ = *s++;
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
                  |L32.10|
00000a  1e52              SUBS     r2,r2,#1
00000c  d2f9              BCS      |L32.2|
;;;542    }
00000e  4770              BX       lr
;;;543    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;545    static
;;;546    void mem_set (void* dst, int val, UINT cnt) {
000000  b2c9              UXTB     r1,r1
000002  e001              B        |L33.8|
                  |L33.4|
;;;547    	BYTE *d = (BYTE*)dst;
;;;548    
;;;549    	while (cnt--)
;;;550    		*d++ = (BYTE)val;
000004  f8001b01          STRB     r1,[r0],#1
                  |L33.8|
000008  1e52              SUBS     r2,r2,#1
00000a  d2fb              BCS      |L33.4|
;;;551    }
00000c  4770              BX       lr
;;;552    
                          ENDP


                          AREA ||i.move_window||, CODE, READONLY, ALIGN=1

                  move_window PROC
;;;718    static
;;;719    FRESULT move_window (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;720    	FATFS *fs,		/* File system object */
;;;721    	DWORD sector	/* Sector number to make appearance in the fs->win[] */
;;;722    )					/* Move to zero only writes back dirty window */
;;;723    {
;;;724    	DWORD wsect;
;;;725    
;;;726    
;;;727    	wsect = fs->winsect;
;;;728    	if (wsect != sector) {	/* Changed current window */
000004  6ac5              LDR      r5,[r0,#0x2c]
000006  460f              MOV      r7,r1                 ;723
000008  4604              MOV      r4,r0                 ;723
00000a  42bd              CMP      r5,r7
00000c  d02b              BEQ      |L34.102|
;;;729    #if !_FS_READONLY
;;;730    		if (fs->wflag) {	/* Write back dirty window if needed */
00000e  7921              LDRB     r1,[r4,#4]
;;;731    			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
000010  f1040830          ADD      r8,r4,#0x30
000014  b1d9              CBZ      r1,|L34.78|
000016  7860              LDRB     r0,[r4,#1]
000018  2301              MOVS     r3,#1
00001a  462a              MOV      r2,r5
00001c  4641              MOV      r1,r8
00001e  f7fffffe          BL       disk_write
000022  b9e0              CBNZ     r0,|L34.94|
;;;732    				return FR_DISK_ERR;
;;;733    			fs->wflag = 0;
000024  2000              MOVS     r0,#0
000026  7120              STRB     r0,[r4,#4]
000028  e9d41007          LDRD     r1,r0,[r4,#0x1c]
;;;734    			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
00002c  4408              ADD      r0,r0,r1
00002e  42a8              CMP      r0,r5
000030  d90d              BLS      |L34.78|
;;;735    				BYTE nf;
;;;736    				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
000032  78e6              LDRB     r6,[r4,#3]
000034  e009              B        |L34.74|
                  |L34.54|
;;;737    					wsect += fs->fsize;
000036  69e0              LDR      r0,[r4,#0x1c]
;;;738    					disk_write(fs->drv, fs->win, wsect, 1);
000038  2301              MOVS     r3,#1
00003a  4405              ADD      r5,r5,r0              ;737
00003c  7860              LDRB     r0,[r4,#1]
00003e  462a              MOV      r2,r5
000040  4641              MOV      r1,r8
000042  f7fffffe          BL       disk_write
000046  1e76              SUBS     r6,r6,#1
000048  b2f6              UXTB     r6,r6                 ;736
                  |L34.74|
00004a  2e01              CMP      r6,#1                 ;736
00004c  d8f3              BHI      |L34.54|
                  |L34.78|
;;;739    				}
;;;740    			}
;;;741    		}
;;;742    #endif
;;;743    		if (sector) {
00004e  b157              CBZ      r7,|L34.102|
;;;744    			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
000050  7860              LDRB     r0,[r4,#1]
000052  2301              MOVS     r3,#1
000054  463a              MOV      r2,r7
000056  4641              MOV      r1,r8
000058  f7fffffe          BL       disk_read
00005c  b110              CBZ      r0,|L34.100|
                  |L34.94|
;;;745    				return FR_DISK_ERR;
00005e  2001              MOVS     r0,#1
                  |L34.96|
;;;746    			fs->winsect = sector;
;;;747    		}
;;;748    	}
;;;749    
;;;750    	return FR_OK;
;;;751    }
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L34.100|
000064  62e7              STR      r7,[r4,#0x2c]         ;746
                  |L34.102|
000066  2000              MOVS     r0,#0                 ;750
000068  e7fa              B        |L34.96|
;;;752    
                          ENDP


                          AREA ||i.put_fat||, CODE, READONLY, ALIGN=1

                  put_fat PROC
;;;861    
;;;862    FRESULT put_fat (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;863    	FATFS *fs,	/* File system object */
;;;864    	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
;;;865    	DWORD val	/* New value to mark the cluster */
;;;866    )
;;;867    {
000004  4616              MOV      r6,r2
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
;;;868    	UINT bc;
;;;869    	BYTE *p;
;;;870    	FRESULT res;
;;;871    
;;;872    
;;;873    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
00000a  2902              CMP      r1,#2
00000c  d302              BCC      |L35.20|
00000e  69a0              LDR      r0,[r4,#0x18]
000010  42a8              CMP      r0,r5
000012  d802              BHI      |L35.26|
                  |L35.20|
;;;874    		res = FR_INT_ERR;
000014  2002              MOVS     r0,#2
                  |L35.22|
;;;875    
;;;876    	} else {
;;;877    		switch (fs->fs_type) {
;;;878    		case FS_FAT12 :
;;;879    			bc = clst; bc += bc / 2;
;;;880    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;881    			if (res != FR_OK) break;
;;;882    			p = &fs->win[bc % SS(fs)];
;;;883    			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
;;;884    			bc++;
;;;885    			fs->wflag = 1;
;;;886    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;887    			if (res != FR_OK) break;
;;;888    			p = &fs->win[bc % SS(fs)];
;;;889    			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
;;;890    			break;
;;;891    
;;;892    		case FS_FAT16 :
;;;893    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
;;;894    			if (res != FR_OK) break;
;;;895    			p = &fs->win[clst * 2 % SS(fs)];
;;;896    			ST_WORD(p, (WORD)val);
;;;897    			break;
;;;898    
;;;899    		case FS_FAT32 :
;;;900    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
;;;901    			if (res != FR_OK) break;
;;;902    			p = &fs->win[clst * 4 % SS(fs)];
;;;903    			val |= LD_DWORD(p) & 0xF0000000;
;;;904    			ST_DWORD(p, val);
;;;905    			break;
;;;906    
;;;907    		default :
;;;908    			res = FR_INT_ERR;
;;;909    		}
;;;910    		fs->wflag = 1;
;;;911    	}
;;;912    
;;;913    	return res;
;;;914    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L35.26|
00001a  7820              LDRB     r0,[r4,#0]            ;877
00001c  f00608ff          AND      r8,r6,#0xff           ;883
000020  f04f0901          MOV      r9,#1                 ;877
000024  2801              CMP      r0,#1                 ;877
000026  d007              BEQ      |L35.56|
000028  2802              CMP      r0,#2                 ;877
00002a  d037              BEQ      |L35.156|
00002c  2803              CMP      r0,#3                 ;877
00002e  d046              BEQ      |L35.190|
000030  2002              MOVS     r0,#2                 ;908
                  |L35.50|
000032  f8849004          STRB     r9,[r4,#4]            ;910
000036  e7ee              B        |L35.22|
                  |L35.56|
000038  6a20              LDR      r0,[r4,#0x20]         ;880
00003a  eb050755          ADD      r7,r5,r5,LSR #1       ;879
00003e  eb002157          ADD      r1,r0,r7,LSR #9       ;880
000042  4620              MOV      r0,r4                 ;880
000044  f7fffffe          BL       move_window
000048  2800              CMP      r0,#0                 ;881
00004a  d1f2              BNE      |L35.50|
00004c  f3c70008          UBFX     r0,r7,#0,#9           ;882
000050  4420              ADD      r0,r0,r4              ;882
000052  3030              ADDS     r0,r0,#0x30           ;882
000054  07e9              LSLS     r1,r5,#31             ;883
000056  d003              BEQ      |L35.96|
000058  7801              LDRB     r1,[r0,#0]            ;883
00005a  f368111f          BFI      r1,r8,#4,#28          ;883
00005e  e000              B        |L35.98|
                  |L35.96|
000060  4631              MOV      r1,r6                 ;883
                  |L35.98|
000062  7001              STRB     r1,[r0,#0]            ;883
000064  f8849004          STRB     r9,[r4,#4]            ;885
000068  6a20              LDR      r0,[r4,#0x20]         ;886
00006a  1c7f              ADDS     r7,r7,#1              ;886
00006c  eb002157          ADD      r1,r0,r7,LSR #9       ;886
000070  4620              MOV      r0,r4                 ;886
000072  f7fffffe          BL       move_window
000076  2800              CMP      r0,#0                 ;887
000078  d1db              BNE      |L35.50|
00007a  f3c70108          UBFX     r1,r7,#0,#9           ;888
00007e  4421              ADD      r1,r1,r4              ;888
000080  3130              ADDS     r1,r1,#0x30           ;888
000082  07ea              LSLS     r2,r5,#31             ;889
000084  d002              BEQ      |L35.140|
000086  f3c61207          UBFX     r2,r6,#4,#8           ;889
00008a  e005              B        |L35.152|
                  |L35.140|
00008c  780a              LDRB     r2,[r1,#0]            ;889
00008e  f3c62303          UBFX     r3,r6,#8,#4           ;889
000092  f00202f0          AND      r2,r2,#0xf0           ;889
000096  431a              ORRS     r2,r2,r3              ;889
                  |L35.152|
000098  700a              STRB     r2,[r1,#0]            ;889
00009a  e7ca              B        |L35.50|
                  |L35.156|
00009c  6a20              LDR      r0,[r4,#0x20]         ;893
00009e  eb002115          ADD      r1,r0,r5,LSR #8       ;893
0000a2  4620              MOV      r0,r4                 ;893
0000a4  f7fffffe          BL       move_window
0000a8  2800              CMP      r0,#0                 ;894
0000aa  d1c2              BNE      |L35.50|
0000ac  b2e9              UXTB     r1,r5                 ;895
0000ae  eb040141          ADD      r1,r4,r1,LSL #1       ;895
0000b2  0a32              LSRS     r2,r6,#8              ;896
0000b4  f8818030          STRB     r8,[r1,#0x30]         ;896
0000b8  f8812031          STRB     r2,[r1,#0x31]         ;896
0000bc  e7b9              B        |L35.50|
                  |L35.190|
0000be  6a20              LDR      r0,[r4,#0x20]         ;900
0000c0  eb0011d5          ADD      r1,r0,r5,LSR #7       ;900
0000c4  4620              MOV      r0,r4                 ;900
0000c6  f7fffffe          BL       move_window
0000ca  2800              CMP      r0,#0                 ;901
0000cc  d1b1              BNE      |L35.50|
0000ce  f24011ff          MOV      r1,#0x1ff             ;902
0000d2  ea010185          AND      r1,r1,r5,LSL #2       ;902
0000d6  4421              ADD      r1,r1,r4              ;902
0000d8  f04f4370          MOV      r3,#0xf0000000        ;903
0000dc  f8d12031          LDR      r2,[r1,#0x31]         ;903
0000e0  ea032202          AND      r2,r3,r2,LSL #8       ;903
0000e4  4332              ORRS     r2,r2,r6              ;903
0000e6  f8012f30          STRB     r2,[r1,#0x30]!        ;904
0000ea  0a13              LSRS     r3,r2,#8              ;904
0000ec  704b              STRB     r3,[r1,#1]            ;904
0000ee  0c13              LSRS     r3,r2,#16             ;904
0000f0  708b              STRB     r3,[r1,#2]            ;904
0000f2  0e12              LSRS     r2,r2,#24             ;904
0000f4  70ca              STRB     r2,[r1,#3]            ;904
0000f6  e79c              B        |L35.50|
;;;915    #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.remove_chain||, CODE, READONLY, ALIGN=1

                  remove_chain PROC
;;;924    static
;;;925    FRESULT remove_chain (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;926    	FATFS *fs,			/* File system object */
;;;927    	DWORD clst			/* Cluster# to remove a chain from */
;;;928    )
;;;929    {
000004  460f              MOV      r7,r1
000006  4605              MOV      r5,r0
;;;930    	FRESULT res;
;;;931    	DWORD nxt;
;;;932    #if _USE_ERASE
;;;933    	DWORD scl = clst, ecl = clst, resion[2];
;;;934    #endif
;;;935    
;;;936    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
000008  2902              CMP      r1,#2
00000a  d318              BCC      |L36.62|
00000c  69a8              LDR      r0,[r5,#0x18]
00000e  42b8              CMP      r0,r7
000010  d915              BLS      |L36.62|
;;;937    		res = FR_INT_ERR;
;;;938    
;;;939    	} else {
;;;940    		res = FR_OK;
000012  2600              MOVS     r6,#0
000014  f04f0801          MOV      r8,#1                 ;931
;;;941    		while (clst < fs->n_fatent) {			/* Not a last link? */
000018  e01d              B        |L36.86|
                  |L36.26|
;;;942    			nxt = get_fat(fs, clst);			/* Get cluster status */
00001a  4639              MOV      r1,r7
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       get_fat
000022  0004              MOVS     r4,r0
;;;943    			if (nxt == 0) break;				/* Empty cluster? */
000024  d01a              BEQ      |L36.92|
;;;944    			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
000026  2c01              CMP      r4,#1
000028  d009              BEQ      |L36.62|
;;;945    			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
00002a  1c60              ADDS     r0,r4,#1
00002c  d009              BEQ      |L36.66|
;;;946    			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
00002e  2200              MOVS     r2,#0
000030  4639              MOV      r1,r7
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       put_fat
000038  0006              MOVS     r6,r0
;;;947    			if (res != FR_OK) break;
00003a  d10f              BNE      |L36.92|
00003c  e003              B        |L36.70|
                  |L36.62|
00003e  2602              MOVS     r6,#2                 ;944
000040  e00c              B        |L36.92|
                  |L36.66|
000042  2601              MOVS     r6,#1                 ;945
000044  e00a              B        |L36.92|
                  |L36.70|
;;;948    			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
000046  6928              LDR      r0,[r5,#0x10]
000048  1c41              ADDS     r1,r0,#1
00004a  d003              BEQ      |L36.84|
00004c  1c40              ADDS     r0,r0,#1
;;;949    				fs->free_clust++;
;;;950    				fs->fsi_flag = 1;
00004e  6128              STR      r0,[r5,#0x10]
000050  f8858005          STRB     r8,[r5,#5]
                  |L36.84|
;;;951    			}
;;;952    #if _USE_ERASE
;;;953    			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
;;;954    				ecl = nxt;
;;;955    			} else {				/* End of contiguous clusters */ 
;;;956    				resion[0] = clust2sect(fs, scl);					/* Start sector */
;;;957    				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
;;;958    				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
;;;959    				scl = ecl = nxt;
;;;960    			}
;;;961    #endif
;;;962    			clst = nxt;	/* Next cluster */
000054  4627              MOV      r7,r4
                  |L36.86|
000056  69a8              LDR      r0,[r5,#0x18]         ;941
000058  42b8              CMP      r0,r7                 ;941
00005a  d8de              BHI      |L36.26|
                  |L36.92|
;;;963    		}
;;;964    	}
;;;965    
;;;966    	return res;
00005c  4630              MOV      r0,r6
;;;967    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;968    #endif
                          ENDP


                          AREA ||i.sync||, CODE, READONLY, ALIGN=1

                  sync PROC
;;;760    static
;;;761    FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;762    	FATFS *fs	/* File system object */
;;;763    )
;;;764    {
000004  4604              MOV      r4,r0
;;;765    	FRESULT res;
;;;766    
;;;767    
;;;768    	res = move_window(fs, 0);
000006  2100              MOVS     r1,#0
000008  f7fffffe          BL       move_window
00000c  0005              MOVS     r5,r0
;;;769    	if (res == FR_OK) {
00000e  d150              BNE      |L37.178|
;;;770    		/* Update FSInfo sector if needed */
;;;771    		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
000010  7820              LDRB     r0,[r4,#0]
000012  2803              CMP      r0,#3
000014  d146              BNE      |L37.164|
000016  7960              LDRB     r0,[r4,#5]
000018  b3f0              CBZ      r0,|L37.152|
;;;772    			fs->winsect = 0;
00001a  2600              MOVS     r6,#0
;;;773    			/* Create FSInfo structure */
;;;774    			mem_set(fs->win, 0, 512);
00001c  f1040030          ADD      r0,r4,#0x30
000020  f44f7200          MOV      r2,#0x200
000024  4631              MOV      r1,r6
000026  4607              MOV      r7,r0
000028  62e6              STR      r6,[r4,#0x2c]
00002a  f7fffffe          BL       mem_set
;;;775    			ST_WORD(fs->win+BS_55AA, 0xAA55);
00002e  2055              MOVS     r0,#0x55
000030  f884022e          STRB     r0,[r4,#0x22e]
000034  20aa              MOVS     r0,#0xaa
000036  f884022f          STRB     r0,[r4,#0x22f]
;;;776    			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
00003a  2052              MOVS     r0,#0x52
00003c  f8840030          STRB     r0,[r4,#0x30]
000040  f8840031          STRB     r0,[r4,#0x31]
000044  2261              MOVS     r2,#0x61
000046  f8842032          STRB     r2,[r4,#0x32]
00004a  2041              MOVS     r0,#0x41
00004c  f8840033          STRB     r0,[r4,#0x33]
;;;777    			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
000050  2172              MOVS     r1,#0x72
000052  f8841214          STRB     r1,[r4,#0x214]
000056  f8841215          STRB     r1,[r4,#0x215]
00005a  f8840216          STRB     r0,[r4,#0x216]
00005e  f8842217          STRB     r2,[r4,#0x217]
;;;778    			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
000062  6920              LDR      r0,[r4,#0x10]
000064  f8840218          STRB     r0,[r4,#0x218]
000068  0a01              LSRS     r1,r0,#8
00006a  f8841219          STRB     r1,[r4,#0x219]
00006e  0c01              LSRS     r1,r0,#16
000070  f884121a          STRB     r1,[r4,#0x21a]
000074  0e00              LSRS     r0,r0,#24
000076  f884021b          STRB     r0,[r4,#0x21b]
;;;779    			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
00007a  68e0              LDR      r0,[r4,#0xc]
00007c  f884021c          STRB     r0,[r4,#0x21c]
000080  0a01              LSRS     r1,r0,#8
000082  f884121d          STRB     r1,[r4,#0x21d]
000086  0c01              LSRS     r1,r0,#16
000088  0e00              LSRS     r0,r0,#24
00008a  f884121e          STRB     r1,[r4,#0x21e]
00008e  f884021f          STRB     r0,[r4,#0x21f]
;;;780    			/* Write it into the FSInfo sector */
;;;781    			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
000092  7860              LDRB     r0,[r4,#1]
000094  2301              MOVS     r3,#1
000096  e000              B        |L37.154|
                  |L37.152|
000098  e004              B        |L37.164|
                  |L37.154|
00009a  4639              MOV      r1,r7
00009c  6962              LDR      r2,[r4,#0x14]
00009e  f7fffffe          BL       disk_write
;;;782    			fs->fsi_flag = 0;
0000a2  7166              STRB     r6,[r4,#5]
                  |L37.164|
;;;783    		}
;;;784    		/* Make sure that no pending write process in the physical drive */
;;;785    		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
0000a4  2200              MOVS     r2,#0
0000a6  7860              LDRB     r0,[r4,#1]
0000a8  4611              MOV      r1,r2
0000aa  f7fffffe          BL       disk_ioctl
0000ae  b100              CBZ      r0,|L37.178|
;;;786    			res = FR_DISK_ERR;
0000b0  2501              MOVS     r5,#1
                  |L37.178|
;;;787    	}
;;;788    
;;;789    	return res;
0000b2  4628              MOV      r0,r5
;;;790    }
0000b4  e8bd81f0          POP      {r4-r8,pc}
;;;791    #endif
                          ENDP


                          AREA ||i.validate||, CODE, READONLY, ALIGN=1

                  validate PROC
;;;2171   static
;;;2172   FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
000000  b510              PUSH     {r4,lr}
;;;2173   	FATFS *fs,		/* Pointer to the file system object */
;;;2174   	WORD id			/* Member id of the target object to be checked */
;;;2175   )
;;;2176   {
000002  b120              CBZ      r0,|L38.14|
;;;2177   	if (!fs || !fs->fs_type || fs->id != id)
000004  7802              LDRB     r2,[r0,#0]
000006  b112              CBZ      r2,|L38.14|
000008  88c2              LDRH     r2,[r0,#6]
00000a  428a              CMP      r2,r1
00000c  d001              BEQ      |L38.18|
                  |L38.14|
;;;2178   		return FR_INVALID_OBJECT;
00000e  2009              MOVS     r0,#9
                  |L38.16|
;;;2179   
;;;2180   	ENTER_FF(fs);		/* Lock file system */
;;;2181   
;;;2182   	if (disk_status(fs->drv) & STA_NOINIT)
;;;2183   		return FR_NOT_READY;
;;;2184   
;;;2185   	return FR_OK;
;;;2186   }
000010  bd10              POP      {r4,pc}
                  |L38.18|
000012  7840              LDRB     r0,[r0,#1]            ;2182
000014  f7fffffe          BL       disk_status
000018  07c0              LSLS     r0,r0,#31             ;2182
00001a  d0f9              BEQ      |L38.16|
00001c  2003              MOVS     r0,#3                 ;2183
00001e  bd10              POP      {r4,pc}
;;;2187   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  vst
000000  04000200          DCW      0x0400,0x0200
000004  01000080          DCW      0x0100,0x0080
000008  00400020          DCW      0x0040,0x0020
00000c  00100008          DCW      0x0010,0x0008
000010  00040002          DCW      0x0004,0x0002
000014  0000              DCW      0x0000
                  ||cst||
000016  8000              DCW      0x8000
000018  40002000          DCW      0x4000,0x2000
00001c  10000800          DCW      0x1000,0x0800
000020  40002000          DCW      0x4000,0x2000
000024  10000800          DCW      0x1000,0x0800
000028  04000200          DCW      0x0400,0x0200

                          AREA ||.data||, DATA, ALIGN=2

                  Fsid
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  FatFs
                          DCD      0x00000000
