; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\test_fatfs.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\test_fatfs.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\HARDWARE\LED -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\STM32F10x_FWLib\inc -I..\CORE -I..\HARDWARE\SPI -I..\HARDWARE\MMC_SD -I..\HARDWARE\SPI -I..\HARDWARE\LED -I..\HARDWARE\WNOTEPAD -I..\HARDWARE\RTC -I..\FATFS -I..\FATFS\option -I..\HARDWARE\USART3 -I..\APPS -I..\HARDWARE\OV2640 -I..\HARDWARE\24LC1024 -I..\HARDWARE\RAM -I.\RTE\_Target_1 -ID:\EmbeddedTools\MDK51_RAM\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\EmbeddedTools\MDK51_RAM\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\test_fatfs.crf ..\FATFS\TEST_FATFS.c]
                          THUMB

                          AREA ||i.StrToData||, CODE, READONLY, ALIGN=1

                  StrToData PROC
;;;234    
;;;235    u8 StrToData(u8 * data, u8 len)
000000  2901              CMP      r1,#1
;;;236    {
000002  d00c              BEQ      |L1.30|
;;;237    	u8 ltemp;
;;;238    	if(len == 1)
;;;239    	{
;;;240    		ltemp = data[0]-0x30;
;;;241    
;;;242    	}
;;;243    	else if(len == 2)
000004  2902              CMP      r1,#2
000006  d109              BNE      |L1.28|
;;;244    	{
;;;245    		ltemp = (data[0]-0x30)*10 + (data[1]-0x30);
000008  7841              LDRB     r1,[r0,#1]
00000a  7800              LDRB     r0,[r0,#0]
00000c  3830              SUBS     r0,r0,#0x30
00000e  eb000080          ADD      r0,r0,r0,LSL #2
000012  22d0              MOVS     r2,#0xd0
000014  eb020040          ADD      r0,r2,r0,LSL #1
000018  4408              ADD      r0,r0,r1
                  |L1.26|
00001a  b2c0              UXTB     r0,r0                 ;240
                  |L1.28|
;;;246    
;;;247    	 }
;;;248    	//else if(len == 3)
;;;249    		//ltemp = (data[0]-0x30)*100 + (data[1]-0x30)*10 + [data[2] - 0x30];
;;;250    
;;;251    	return ltemp;
;;;252    	
;;;253    }
00001c  4770              BX       lr
                  |L1.30|
00001e  7800              LDRB     r0,[r0,#0]            ;240
000020  3830              SUBS     r0,r0,#0x30           ;240
000022  e7fa              B        |L1.26|
;;;254    
                          ENDP


                          AREA ||i.Test_f_creat||, CODE, READONLY, ALIGN=1

                  Test_f_creat PROC
;;;330    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;331    FRESULT Test_f_creat(const TCHAR* path)//建立文件，输入文件路径和文件名
000000  b510              PUSH     {r4,lr}
;;;332    {
000002  f5ad6d8b          SUB      sp,sp,#0x458
000006  4604              MOV      r4,r0
;;;333        FATFS fs;            // Work area (file system object) for logical drive
;;;334    	FIL file;
;;;335        FRESULT res;         // FatFs function common result code
;;;336    
;;;337    	//检测磁盘是否插好
;;;338    	//if(disk_detect_OK()==FALSE ) return ;
;;;339    	//printf("\r\n inaert_ok:>");
;;;340    	// Register a work area for logical drive 0
;;;341    	f_mount(0, &fs);
000008  a989              ADD      r1,sp,#0x224
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       f_mount
;;;342    	res=f_open(&file,path,FA_CREATE_NEW); //创建一个新文件。如果文件已存在，则创建失败//FA_CREATE_NEW创建一个新文件。如果文件已存在，则创建失败。
000010  2204              MOVS     r2,#4
000012  4621              MOV      r1,r4
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       f_open
00001a  4604              MOV      r4,r0
;;;343                                                                                          //FA_CREATE_ALWAYS	//创建一个新文件。如果文件已存在，则它将被截断并覆盖。
;;;344                                                                                          //FA_OPEN_ALWAYS    //如果文件存在，则打开；否则，创建一个新文件。
;;;345    	//die(res);
;;;346    	f_close(&file);//关闭文件
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       f_close
;;;347    	f_mount(0, NULL);
000022  2100              MOVS     r1,#0
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       f_mount
;;;348    	return res;
;;;349    }
00002a  f50d6d8b          ADD      sp,sp,#0x458
00002e  4620              MOV      r0,r4                 ;348
000030  bd10              POP      {r4,pc}
;;;350    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                          ENDP


                          AREA ||i.Test_f_deldir||, CODE, READONLY, ALIGN=1

                  Test_f_deldir PROC
;;;289    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;290    FRESULT Test_f_deldir(const TCHAR* path)//删除一个目录,输入目录的路径;目录里的内容是空的才能删除Test_f_deldir("/dir");	
000000  b510              PUSH     {r4,lr}
;;;291    {
000002  f5ad7d0c          SUB      sp,sp,#0x230
000006  4604              MOV      r4,r0
;;;292        FATFS fs;            // Work area (file system object) for logical drive
;;;293    	//DIR	dir;
;;;294        FRESULT res;         // FatFs function common result code
;;;295    
;;;296    	//检测磁盘是否插好
;;;297    	//if(disk_detect_OK()==FALSE ) return ;
;;;298    	//printf("\r\n inaert_ok:>");
;;;299    	// Register a work area for logical drive 0
;;;300    	f_mount(0, &fs);
000008  4669              MOV      r1,sp
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       f_mount
;;;301    	//f_opendir (&dir,path);
;;;302    	res=f_unlink(path);//删除一个目录
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       f_unlink
000016  4604              MOV      r4,r0
;;;303    	//die(res);
;;;304    	f_mount(0, NULL);
000018  2100              MOVS     r1,#0
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       f_mount
;;;305    	return res;
;;;306    }
000020  f50d7d0c          ADD      sp,sp,#0x230
000024  4620              MOV      r0,r4                 ;305
000026  bd10              POP      {r4,pc}
;;;307    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                          ENDP


                          AREA ||i.Test_f_delfile||, CODE, READONLY, ALIGN=1

                  Test_f_delfile PROC
;;;350    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;351    FRESULT Test_f_delfile(const TCHAR* path)//删除一个文件,输入文件的路径;Test_f_delfile("/dir");	
000000  b510              PUSH     {r4,lr}
;;;352    {
000002  f5ad7d0c          SUB      sp,sp,#0x230
000006  4604              MOV      r4,r0
;;;353        FATFS fs;            // Work area (file system object) for logical drive
;;;354    	//DIR	dir;
;;;355        FRESULT res;         // FatFs function common result code
;;;356    
;;;357    	//检测磁盘是否插好
;;;358    	//if(disk_detect_OK()==FALSE ) return ;
;;;359    	//printf("\r\n inaert_ok:>");
;;;360    	// Register a work area for logical drive 0
;;;361    	f_mount(0, &fs);
000008  4669              MOV      r1,sp
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       f_mount
;;;362    	//f_opendir (&dir,path);
;;;363    	res=f_unlink(path);//删除一个文件
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       f_unlink
000016  4604              MOV      r4,r0
;;;364    	//die(res);
;;;365    	f_mount(0, NULL);
000018  2100              MOVS     r1,#0
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       f_mount
;;;366    	return res;
;;;367    }
000020  f50d7d0c          ADD      sp,sp,#0x230
000024  4620              MOV      r0,r4                 ;366
000026  bd10              POP      {r4,pc}
;;;368    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                          ENDP


                          AREA ||i.Test_f_getfree||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Test_f_getfree PROC
;;;116    }
;;;117    void Test_f_getfree(void)//获取卡的总容量及剩余容量
000000  b500              PUSH     {lr}
;;;118    {
000002  f5ad7d0f          SUB      sp,sp,#0x23c
;;;119        FATFS fs;
;;;120    	FATFS *pfs;
;;;121        DWORD clust;
;;;122    	FRESULT res;         // FatFs function common result code
;;;123    
;;;124    	//检测磁盘是否插好
;;;125    	if( disk_detect_OK()==FALSE ) return;
000006  f7fffffe          BL       disk_detect_OK
00000a  2800              CMP      r0,#0
00000c  d011              BEQ      |L5.50|
;;;126    
;;;127    	pfs=&fs;//指向
00000e  f8cdd230          STR      sp,[sp,#0x230]
;;;128    	// Register a work area for logical drive 0
;;;129        f_mount(0, &fs);//安装FATFS，就是给FATFS分配空间
000012  4669              MOV      r1,sp
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       f_mount
;;;130    
;;;131        // Get free clusters
;;;132        res = f_getfree("/", &clust, &pfs);//必须是根目录，默认磁盘0;"/"或者"0:/"
00001a  aa8c              ADD      r2,sp,#0x230
00001c  a98d              ADD      r1,sp,#0x234
00001e  a00d              ADR      r0,|L5.84|
000020  f7fffffe          BL       f_getfree
;;;133        if ( res==FR_OK ) 
000024  b140              CBZ      r0,|L5.56|
;;;134        {
;;;135    	    // Get free space
;;;136            printf("\r\n%d MB total disk space.\r\n%d MB available on the disk.\r\n",
;;;137                    (DWORD)(pfs->n_fatent - 2) * pfs->csize /2/1024,//总的磁盘空间M	=（总簇数-2）*每簇的扇区数/2/1024=可用簇数*每簇的扇区数/2/1024
;;;138                     clust * pfs->csize /2/1024);//空闲的磁盘空间M=剩余簇数*每簇的扇区数/2/1024
;;;139    	}
;;;140    	else die(res);//测试函数执行结果分析
000026  f7fffffe          BL       ||die||
                  |L5.42|
;;;141    	
;;;142    	// Unregister a work area before discard it
;;;143        f_mount(0, NULL);//卸载FATFS，就是释放FATFS结构体所占空间
00002a  2100              MOVS     r1,#0
00002c  4608              MOV      r0,r1
00002e  f7fffffe          BL       f_mount
                  |L5.50|
;;;144    }
000032  f50d7d0f          ADD      sp,sp,#0x23c
000036  bd00              POP      {pc}
                  |L5.56|
000038  988c              LDR      r0,[sp,#0x230]        ;136
00003a  9a8d              LDR      r2,[sp,#0x234]        ;136
00003c  6981              LDR      r1,[r0,#0x18]         ;136
00003e  7880              LDRB     r0,[r0,#2]            ;136
000040  1e89              SUBS     r1,r1,#2              ;136
000042  4341              MULS     r1,r0,r1              ;136
000044  4350              MULS     r0,r2,r0              ;136
000046  0ac2              LSRS     r2,r0,#11             ;136
000048  0ac9              LSRS     r1,r1,#11             ;136
00004a  a003              ADR      r0,|L5.88|
00004c  f7fffffe          BL       __2printf
000050  e7eb              B        |L5.42|
;;;145    
                          ENDP

000052  0000              DCW      0x0000
                  |L5.84|
000054  2f00              DCB      "/",0
000056  00                DCB      0
000057  00                DCB      0
                  |L5.88|
000058  0d0a2564          DCB      "\r\n%d MB total disk space.\r\n%d MB available on the d"
00005c  204d4220
000060  746f7461
000064  6c206469
000068  736b2073
00006c  70616365
000070  2e0d0a25
000074  64204d42
000078  20617661
00007c  696c6162
000080  6c65206f
000084  6e207468
000088  652064  
00008b  69736b2e          DCB      "isk.\r\n",0
00008f  0d0a00  
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.Test_f_getfreem||, CODE, READONLY, ALIGN=2

                  Test_f_getfreem PROC
;;;426    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;427    FRESULT Test_f_getfreem(DWORD *freem)//获取卡的剩余容量单位为M
000000  b530              PUSH     {r4,r5,lr}
;;;428    {
000002  f5ad7d0d          SUB      sp,sp,#0x234
000006  4605              MOV      r5,r0
;;;429        FATFS fs;
;;;430    	FATFS *pfs;
;;;431    	FRESULT res;         // FatFs function common result code
;;;432    	//检测磁盘是否插好
;;;433    	//if( disk_detect_OK()==FALSE ) return;
;;;434    	// Register a work area for logical drive 0
;;;435    	pfs=&fs;//指向
000008  f8cdd230          STR      sp,[sp,#0x230]
;;;436        f_mount(0, &fs);//安装FATFS，就是给FATFS分配空间
00000c  4669              MOV      r1,sp
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       f_mount
;;;437        // Get free clusters
;;;438        res = f_getfree("/",freem,&pfs);//必须是根目录，默认磁盘0;"/"或者"0:/"
000014  aa8c              ADD      r2,sp,#0x230
000016  4629              MOV      r1,r5
000018  a009              ADR      r0,|L6.64|
00001a  f7fffffe          BL       f_getfree
00001e  0004              MOVS     r4,r0
;;;439    	//die(res);
;;;440    	if ( res==FR_OK ) 
000020  d105              BNE      |L6.46|
;;;441      {
;;;442    	    // Get free space
;;;443            //printf("\r\n%d MB total disk space.\r\n%d MB available on the disk.\r\n",
;;;444                   //(DWORD)(pfs->n_fatent - 2) * (pfs->csize) /2/1024,//总的磁盘空间M	=（总簇数-2）*每簇的扇区数/2/1024=可用簇数*每簇的扇区数/2/1024
;;;445                     //(*freem)*(pfs->csize)/2/1024);//空闲的磁盘空间M=剩余簇数*每簇的扇区数/2/1024
;;;446    	 *freem=((*freem)*pfs->csize)/2/1024;
000022  998c              LDR      r1,[sp,#0x230]
000024  6828              LDR      r0,[r5,#0]
000026  7889              LDRB     r1,[r1,#2]
000028  4348              MULS     r0,r1,r0
00002a  0ac0              LSRS     r0,r0,#11
00002c  6028              STR      r0,[r5,#0]
                  |L6.46|
;;;447    	}
;;;448    	//else die(res);//测试函数执行结果分析
;;;449    	// Unregister a work area before discard it
;;;450        f_mount(0, NULL);//卸载FATFS，就是释放FATFS结构体所占空间
00002e  2100              MOVS     r1,#0
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       f_mount
;;;451    	return res;
;;;452    }
000036  f50d7d0d          ADD      sp,sp,#0x234
00003a  4620              MOV      r0,r4                 ;451
00003c  bd30              POP      {r4,r5,pc}
;;;453    //unsigned
                          ENDP

00003e  0000              DCW      0x0000
                  |L6.64|
000040  2f00              DCB      "/",0
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.Test_f_mkdir||, CODE, READONLY, ALIGN=1

                  Test_f_mkdir PROC
;;;273    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;274    FRESULT Test_f_mkdir(const TCHAR* path)//创建一个新目录,输入目录的路径Test_f_mkdir("/dir");只能一级一级的建立目录	
000000  b510              PUSH     {r4,lr}
;;;275    {
000002  f5ad7d0c          SUB      sp,sp,#0x230
000006  4604              MOV      r4,r0
;;;276        FATFS fs;            // Work area (file system object) for logical drive
;;;277        FRESULT res;         // FatFs function common result code
;;;278    
;;;279    	//检测磁盘是否插好
;;;280    	//if(disk_detect_OK()==FALSE ) return ;
;;;281    	//printf("\r\n inaert_ok:>");
;;;282    	// Register a work area for logical drive 0
;;;283    	f_mount(0, &fs);
000008  4669              MOV      r1,sp
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       f_mount
;;;284    	res=f_mkdir(path);//创建一个新目录
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       f_mkdir
000016  4604              MOV      r4,r0
;;;285    	//die(res);
;;;286    	f_mount(0, NULL);
000018  2100              MOVS     r1,#0
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       f_mount
;;;287    	return res;
;;;288    }
000020  f50d7d0c          ADD      sp,sp,#0x230
000024  4620              MOV      r0,r4                 ;287
000026  bd10              POP      {r4,pc}
;;;289    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                          ENDP


                          AREA ||i.Test_f_mkfs||, CODE, READONLY, ALIGN=1

                  Test_f_mkfs PROC
;;;257    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;258    FRESULT Test_f_mkfs(BYTE drv)//对卡进行格式化，驱动器号一般为0
000000  b510              PUSH     {r4,lr}
;;;259    {
000002  f5ad7d0c          SUB      sp,sp,#0x230
000006  4604              MOV      r4,r0
;;;260        FATFS fs;            // Work area (file system object) for logical drive
;;;261        FRESULT res;         // FatFs function common result code
;;;262    
;;;263    	//检测磁盘是否插好
;;;264    	//if(disk_detect_OK()==FALSE ) return ;
;;;265    	//printf("\r\n inaert_ok:>");
;;;266    	// Register a work area for logical drive 0
;;;267    	f_mount(drv, &fs);
000008  4669              MOV      r1,sp
00000a  f7fffffe          BL       f_mount
;;;268    	res=f_mkfs(drv, 0, 0);/* Create a file system on the drive 在驱动器创建一个文件系统（驱动器号，分区规则（0:FDISK, 1:SFD），分配的单元大小）*/
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       f_mkfs
000018  4604              MOV      r4,r0
;;;269    	//die(res);
;;;270    	f_mount(0, NULL);
00001a  2100              MOVS     r1,#0
00001c  4608              MOV      r0,r1
00001e  f7fffffe          BL       f_mount
;;;271    	return res;
;;;272    }
000022  f50d7d0c          ADD      sp,sp,#0x230
000026  4620              MOV      r0,r4                 ;271
000028  bd10              POP      {r4,pc}
;;;273    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                          ENDP


                          AREA ||i.Test_f_read||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  Test_f_read PROC
;;;145    
;;;146    void Test_f_read(void)//读文件的数据，如果没有此文件则返回错误
000000  b570              PUSH     {r4-r6,lr}
;;;147    {
000002  f5ad6dce          SUB      sp,sp,#0x670
;;;148        FATFS fs;            // Work area (file system object) for logical drive
;;;149        FIL fsrc;            // file objects
;;;150        BYTE buffer[512];     // file copy buffer
;;;151        FRESULT res;         // FatFs function common result code
;;;152        UINT br;             // File R count
;;;153    	u16 i;
;;;154    	
;;;155    
;;;156    	char path[20]="新建文件.txt";
000006  2214              MOVS     r2,#0x14
000008  491e              LDR      r1,|L9.132|
00000a  f20d6054          ADD      r0,sp,#0x654
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;157    
;;;158    	//检测磁盘是否插好
;;;159    	if( disk_detect_OK()==FALSE ) return;
000012  f7fffffe          BL       disk_detect_OK
000016  2800              CMP      r0,#0
000018  d030              BEQ      |L9.124|
;;;160    
;;;161        // Register a work area for logical drive 0
;;;162        f_mount(0, &fs);
00001a  f20d4124          ADD      r1,sp,#0x424
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       f_mount
;;;163    
;;;164    	printf("\r\nread file:>");
000024  a018              ADR      r0,|L9.136|
000026  f7fffffe          BL       __2printf
;;;165    //	USART_Scanf_Name(path);//通过串口输入文件路径名/dir/file.txt或者0:dir/file.txt或者0:/dir/file.txt
;;;166    
;;;167    	//Open source file
;;;168        res = f_open(&fsrc, path, FA_OPEN_EXISTING | FA_READ);//打开存在的文件，如果没有则返回错误
00002a  2201              MOVS     r2,#1
00002c  f20d6154          ADD      r1,sp,#0x654
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       f_open
;;;169    	die(res);
000036  f7fffffe          BL       ||die||
00003a  2400              MOVS     r4,#0
00003c  ad89              ADD      r5,sp,#0x224          ;150
;;;170    	
;;;171    	//buffer空间设大一点，会提高读的速度。
;;;172    	//如果文件实际大小512byte，
;;;173    	//设为buffer[512]时，只需要循坏一次，如果设为buffer[1]，需要循坏512次。
;;;174    	//下面两行主要是去除1s误差。
;;;175    
;;;176    	for (;;) 
;;;177    	{
;;;178    		for(i=0;i<sizeof(buffer);i++) buffer[i]='\0';//清除缓存
00003e  f44f7600          MOV      r6,#0x200
                  |L9.66|
000042  2000              MOVS     r0,#0
000044  4632              MOV      r2,r6
                  |L9.70|
000046  542c              STRB     r4,[r5,r0]
000048  1c40              ADDS     r0,r0,#1
00004a  b280              UXTH     r0,r0
00004c  4290              CMP      r0,r2
00004e  d3fa              BCC      |L9.70|
;;;179    
;;;180    		res = f_read(&fsrc, buffer, sizeof(buffer), &br);
000050  f50d63cd          ADD      r3,sp,#0x668
000054  a989              ADD      r1,sp,#0x224
000056  4668              MOV      r0,sp
000058  f7fffffe          BL       f_read
;;;181            if (res ||(br == 0)) break;   // error or eof	
00005c  b938              CBNZ     r0,|L9.110|
00005e  f8dd0668          LDR      r0,[sp,#0x668]
000062  b120              CBZ      r0,|L9.110|
;;;182    		
;;;183    		printf("%s",buffer);	
000064  a989              ADD      r1,sp,#0x224
000066  a00c              ADR      r0,|L9.152|
000068  f7fffffe          BL       __2printf
00006c  e7e9              B        |L9.66|
                  |L9.110|
;;;184        }
;;;185    
;;;186    			    
;;;187        // Close all files
;;;188        f_close(&fsrc);
00006e  4668              MOV      r0,sp
000070  f7fffffe          BL       f_close
;;;189        // Unregister a work area before discard it
;;;190        f_mount(0, NULL);
000074  2100              MOVS     r1,#0
000076  4608              MOV      r0,r1
000078  f7fffffe          BL       f_mount
                  |L9.124|
;;;191    }
00007c  f50d6dce          ADD      sp,sp,#0x670
000080  bd70              POP      {r4-r6,pc}
;;;192    
                          ENDP

000082  0000              DCW      0x0000
                  |L9.132|
                          DCD      ||.constdata||
                  |L9.136|
000088  0d0a7265          DCB      "\r\nread file:>",0
00008c  61642066
000090  696c653a
000094  3e00    
000096  00                DCB      0
000097  00                DCB      0
                  |L9.152|
000098  257300            DCB      "%s",0
00009b  00                DCB      0

                          AREA ||i.Test_f_readdir||, CODE, READONLY, ALIGN=1

                  Test_f_readdir PROC
;;;307    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;308    FRESULT Test_f_readdir(const TCHAR* path,char (*filename)[13])//获取目录中的文件,输入目录的路径;输出文件名和文件夹名Test_f_readdir("/DIR",name);char name[5][13]	
000000  b570              PUSH     {r4-r6,lr}
;;;309    {
000002  f5ad7d1a          SUB      sp,sp,#0x268
000006  460c              MOV      r4,r1
000008  4605              MOV      r5,r0
;;;310        FATFS fs;            // Work area (file system object) for logical drive
;;;311    	DIR	dir;
;;;312    	FILINFO finf;
;;;313        FRESULT res;         // FatFs function common result code
;;;314    
;;;315    	//检测磁盘是否插好
;;;316    	//if(disk_detect_OK()==FALSE ) return ;
;;;317    	//printf("\r\n inaert_ok:>");
;;;318    	// Register a work area for logical drive 0
;;;319    	f_mount(0, &fs);
00000a  4669              MOV      r1,sp
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       f_mount
;;;320    	f_opendir (&dir,path);
000012  4629              MOV      r1,r5
000014  a88c              ADD      r0,sp,#0x230
000016  f7fffffe          BL       f_opendir
00001a  f20d2555          ADD      r5,sp,#0x255          ;312
;;;321    
;;;322    	while(((res=f_readdir(&dir,&finf))==FR_OK)&&(finf.fname[0]))//获取目录中的文件	
00001e  e004              B        |L10.42|
                  |L10.32|
;;;323    	{strcpy(*(filename++),finf.fname);
000020  4620              MOV      r0,r4
000022  340d              ADDS     r4,r4,#0xd
000024  4629              MOV      r1,r5
000026  f7fffffe          BL       strcpy
                  |L10.42|
00002a  a993              ADD      r1,sp,#0x24c          ;322
00002c  a88c              ADD      r0,sp,#0x230          ;322
00002e  f7fffffe          BL       f_readdir
000032  0006              MOVS     r6,r0                 ;322
000034  d103              BNE      |L10.62|
000036  f89d0255          LDRB     r0,[sp,#0x255]        ;322
00003a  2800              CMP      r0,#0                 ;322
00003c  d1f0              BNE      |L10.32|
                  |L10.62|
;;;324    	//printf("%s",finf.fname);
;;;325    	}
;;;326    	//die(res);
;;;327    	f_mount(0, NULL);
00003e  2100              MOVS     r1,#0
000040  4608              MOV      r0,r1
000042  f7fffffe          BL       f_mount
;;;328    	return res;
;;;329    }
000046  f50d7d1a          ADD      sp,sp,#0x268
00004a  4630              MOV      r0,r6                 ;328
00004c  bd70              POP      {r4-r6,pc}
;;;330    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                          ENDP


                          AREA ||i.Test_f_readfile||, CODE, READONLY, ALIGN=1

                  Test_f_readfile PROC
;;;368    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;369    FRESULT Test_f_readfile(const TCHAR* path,char *buff,DWORD ofs,UINT strl)//读文件的数据，如果没有此文件则返回错误;输入文件的路径名，内容缓存，读取开始偏移指针，读取的字节数
000000  b5f0              PUSH     {r4-r7,lr}
;;;370    {																		  //Test_f_readfile("/dir/r.txt",str,0,sizeof(strr));
000002  f2ad4d5c          SUB      sp,sp,#0x45c
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
00000a  461e              MOV      r6,r3
00000c  4617              MOV      r7,r2
;;;371        FATFS fs;            // Work area (file system object) for logical drive
;;;372        FIL file;            // file objects
;;;373        FRESULT res;         // FatFs function common result code
;;;374        UINT br;             // File R count 文件读回的字节计数
;;;375    	//u16 i;
;;;376    	//检测磁盘是否插好
;;;377    	//if( disk_detect_OK()==FALSE ) return;
;;;378        // Register a work area for logical drive 0
;;;379    	//for(i=0;i<sizeof(buff);i++) buff[i]='\0';
;;;380        f_mount(0, &fs);
00000e  a989              ADD      r1,sp,#0x224
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       f_mount
;;;381    	//Open source file
;;;382        res = f_open(&file, path, FA_OPEN_EXISTING | FA_READ);//打开存在的文件，如果没有则返回错误
000016  2201              MOVS     r2,#1
000018  4621              MOV      r1,r4
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       f_open
;;;383    	//die(res);
;;;384    	res = f_lseek(&file,ofs); //指针移到文件ofs个字节处
000020  4639              MOV      r1,r7
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       f_lseek
;;;385    	//buffer空间设大一点，会提高读的速度。
;;;386    	//如果文件实际大小512byte，
;;;387    	//设为buffer[512]时，只需要循坏一次，如果设为buffer[1]，需要循坏512次。
;;;388    	//for (;;) 
;;;389    	{
;;;390    		//for(i=0;i<sizeof(buff);i++) buff[i]='\0';//清除缓存
;;;391    
;;;392    		res = f_read(&file, buff, strl, &br);
000028  f20d4354          ADD      r3,sp,#0x454
00002c  4632              MOV      r2,r6
00002e  4629              MOV      r1,r5
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       f_read
000036  4604              MOV      r4,r0
;;;393            //if (res ||(br == 0)) break;   // error or eof如果错误或者到文件末尾则退出
;;;394    		
;;;395    		//printf("%s",buff);	
;;;396        }		    
;;;397        // Close all files
;;;398        f_close(&file);
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       f_close
;;;399        // Unregister a work area before discard it
;;;400        f_mount(0, NULL);
00003e  2100              MOVS     r1,#0
000040  4608              MOV      r0,r1
000042  f7fffffe          BL       f_mount
;;;401    	return res;
;;;402    }
000046  f20d4d5c          ADD      sp,sp,#0x45c
00004a  4620              MOV      r0,r4                 ;401
00004c  bdf0              POP      {r4-r7,pc}
;;;403    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                          ENDP


                          AREA ||i.Test_f_write||, CODE, READONLY, ALIGN=2

                  Test_f_write PROC
;;;192    
;;;193    void Test_f_write(void)//写数据到文件，如果没有此文件则创建文件
000000  b510              PUSH     {r4,lr}
;;;194    {
000002  f5ad6d90          SUB      sp,sp,#0x480
;;;195        FATFS fs;            // Work area (file system object) for logical drive
;;;196        FRESULT res;         // FatFs function common result code
;;;197    		FIL Make_file;
;;;198        char file_name[20]="新建文件.txt";
000006  2214              MOVS     r2,#0x14
000008  4929              LDR      r1,|L12.176|
00000a  f20d4064          ADD      r0,sp,#0x464
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;199        char Storage_buffer[] ="this is a test!";
000012  a028              ADR      r0,|L12.180|
000014  f20d4454          ADD      r4,sp,#0x454
000018  c80f              LDM      r0,{r0-r3}
00001a  e884000f          STM      r4,{r0-r3}
;;;200    	
;;;201    	UINT bw;
;;;202    	//检测磁盘是否插好
;;;203    	if( disk_detect_OK()==FALSE ) return;
00001e  f7fffffe          BL       disk_detect_OK
000022  2800              CMP      r0,#0
000024  d041              BEQ      |L12.170|
;;;204    	 printf("\r\n inaert_ok:>");
000026  a027              ADR      r0,|L12.196|
000028  f7fffffe          BL       __2printf
;;;205        // Register a work area for logical drive 0
;;;206        f_mount(0, &fs);
00002c  a989              ADD      r1,sp,#0x224
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       f_mount
;;;207    
;;;208    	printf("\r\n Make file Name:>");
000034  a027              ADR      r0,|L12.212|
000036  f7fffffe          BL       __2printf
;;;209    // 	USART_Scanf_Name(file_name);//通过串口输入源文件路径名/dir/file.txt或者0:dir/file.txt或者0:/dir/file.txt
;;;210    
;;;211        res = f_open(&Make_file, file_name,  FA_OPEN_ALWAYS | FA_WRITE); //可写方式打开 没有文件则创建 
00003a  2212              MOVS     r2,#0x12
00003c  f20d4164          ADD      r1,sp,#0x464
000040  4668              MOV      r0,sp
000042  f7fffffe          BL       f_open
000046  4604              MOV      r4,r0
;;;212    	 printf("\r\n open_ok:>");
000048  a027              ADR      r0,|L12.232|
00004a  f7fffffe          BL       __2printf
;;;213    	 die(res);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       ||die||
;;;214        res = f_lseek(&Make_file, Make_file.fsize); //指针移到文件最后  
000054  4668              MOV      r0,sp
000056  9903              LDR      r1,[sp,#0xc]
000058  f7fffffe          BL       f_lseek
00005c  4604              MOV      r4,r0
;;;215          printf("\r\n seek_ok:>");
00005e  a026              ADR      r0,|L12.248|
000060  f7fffffe          BL       __2printf
;;;216    	 die(res);
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       ||die||
;;;217    	res = f_write(&Make_file, Storage_buffer, (sizeof (Storage_buffer))-1 , &bw); //每次需要写入的数据字节数，去掉最后的\0所以-1  
00006a  f50d638f          ADD      r3,sp,#0x478
00006e  220f              MOVS     r2,#0xf
000070  f20d4154          ADD      r1,sp,#0x454
000074  4668              MOV      r0,sp
000076  f7fffffe          BL       f_write
00007a  4604              MOV      r4,r0
;;;218         printf("\r\n write_ok:>");
00007c  a022              ADR      r0,|L12.264|
00007e  f7fffffe          BL       __2printf
;;;219    	 die(res);
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       ||die||
;;;220    	res = f_lseek(&Make_file, Make_file.fsize); //指针移到文件最后  
000088  4668              MOV      r0,sp
00008a  9903              LDR      r1,[sp,#0xc]
00008c  f7fffffe          BL       f_lseek
;;;221    	f_close(&Make_file);//关闭文件
000090  4668              MOV      r0,sp
000092  f7fffffe          BL       f_close
;;;222    	printf("\r\n close_ok:>");
000096  a020              ADR      r0,|L12.280|
000098  f7fffffe          BL       __2printf
;;;223    
;;;224    	printf("\r\n写文件测试OK!\r\n");
00009c  a022              ADR      r0,|L12.296|
00009e  f7fffffe          BL       __2printf
;;;225    
;;;226    	// Unregister a work area before discard it
;;;227        f_mount(0, NULL);
0000a2  2100              MOVS     r1,#0
0000a4  4608              MOV      r0,r1
0000a6  f7fffffe          BL       f_mount
                  |L12.170|
;;;228    }
0000aa  f50d6d90          ADD      sp,sp,#0x480
0000ae  bd10              POP      {r4,pc}
;;;229    
                          ENDP

                  |L12.176|
                          DCD      ||.constdata||+0x14
                  |L12.180|
0000b4  74686973          DCB      "this is a test!",0
0000b8  20697320
0000bc  61207465
0000c0  73742100
                  |L12.196|
0000c4  0d0a2069          DCB      "\r\n inaert_ok:>",0
0000c8  6e616572
0000cc  745f6f6b
0000d0  3a3e00  
0000d3  00                DCB      0
                  |L12.212|
0000d4  0d0a204d          DCB      "\r\n Make file Name:>",0
0000d8  616b6520
0000dc  66696c65
0000e0  204e616d
0000e4  653a3e00
                  |L12.232|
0000e8  0d0a206f          DCB      "\r\n open_ok:>",0
0000ec  70656e5f
0000f0  6f6b3a3e
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L12.248|
0000f8  0d0a2073          DCB      "\r\n seek_ok:>",0
0000fc  65656b5f
000100  6f6b3a3e
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0
                  |L12.264|
000108  0d0a2077          DCB      "\r\n write_ok:>",0
00010c  72697465
000110  5f6f6b3a
000114  3e00    
000116  00                DCB      0
000117  00                DCB      0
                  |L12.280|
000118  0d0a2063          DCB      "\r\n close_ok:>",0
00011c  6c6f7365
000120  5f6f6b3a
000124  3e00    
000126  00                DCB      0
000127  00                DCB      0
                  |L12.296|
000128  0d0ad0b4          DCB      "\r\n",208,180,206,196,188,254,178,226,202,212,"OK!\r\n",0
00012c  cec4bcfe
000130  b2e2cad4
000134  4f4b210d
000138  0a00    
00013a  00                DCB      0
00013b  00                DCB      0

                          AREA ||i.Test_f_writefile||, CODE, READONLY, ALIGN=1

                  Test_f_writefile PROC
;;;403    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;404    FRESULT Test_f_writefile(const TCHAR* path,char *buff,DWORD ofs,UINT strl)//写数据到文件，如果没有此文件则创建文件;输入文件的路径名，内容缓存，写开始偏移指针，写的字节数
000000  b5f0              PUSH     {r4-r7,lr}
;;;405    {																		  //Test_f_writefile("/dir/r.txt",strw,0,strlen(strw));
000002  f2ad4d5c          SUB      sp,sp,#0x45c
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
00000a  461e              MOV      r6,r3
00000c  4617              MOV      r7,r2
;;;406        FATFS fs;            // Work area (file system object) for logical drive
;;;407        FRESULT res;         // FatFs function common result code
;;;408    	FIL file;
;;;409    	UINT bw;             //文件写入的字节计数
;;;410    	//检测磁盘是否插好
;;;411    	//if( disk_detect_OK()==FALSE ) return;
;;;412        // Register a work area for logical drive 0
;;;413        f_mount(0, &fs);
00000e  a989              ADD      r1,sp,#0x224
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       f_mount
;;;414        res = f_open(&file, path,  FA_OPEN_ALWAYS | FA_WRITE); //可写方式打开 没有文件则创建 
000016  2212              MOVS     r2,#0x12
000018  4621              MOV      r1,r4
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       f_open
;;;415    	 //die(res);
;;;416        res = f_lseek(&file, ofs); //指针移到文件ofs处；输入file.fsize指针移到文件最后 
000020  4639              MOV      r1,r7
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       f_lseek
;;;417    	 //die(res);
;;;418    	res = f_write(&file, buff, strl, &bw); //每次需要写入的数据字节数;如果btr为strlen(buff)则写入所有的字符
000028  f20d4354          ADD      r3,sp,#0x454
00002c  4632              MOV      r2,r6
00002e  4629              MOV      r1,r5
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       f_write
000036  4604              MOV      r4,r0
;;;419    	 //die(res);
;;;420    	//res = f_lseek(&file, Make_file.fsize); //指针移到文件最后,一边再一次的写入  
;;;421    	f_close(&file);//关闭文件
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       f_close
;;;422    	// Unregister a work area before discard it
;;;423        f_mount(0, NULL);
00003e  2100              MOVS     r1,#0
000040  4608              MOV      r0,r1
000042  f7fffffe          BL       f_mount
;;;424    	return res;
;;;425    }
000046  f20d4d5c          ADD      sp,sp,#0x45c
00004a  4620              MOV      r0,r4                 ;424
00004c  bdf0              POP      {r4-r7,pc}
;;;426    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                          ENDP


                          AREA ||i.die||, CODE, READONLY, ALIGN=2

                  ||die|| PROC
;;;25     //测试函数执行结果分析
;;;26     void die(FRESULT res)
000000  280f              CMP      r0,#0xf
;;;27     {
;;;28         switch(res)
000002  d224              BCS      |L14.78|
000004  e8dff000          TBB      [pc,r0]
000008  0823230a          DCB      0x08,0x23,0x23,0x0a
00000c  0c0e1014          DCB      0x0c,0x0e,0x10,0x14
000010  161e1812          DCB      0x16,0x1e,0x18,0x12
000014  1a1c2000          DCB      0x1a,0x1c,0x20,0x00
;;;29     	{
;;;30     	    case FR_OK:	//The function succeeded. 
;;;31     		{
;;;32     		    printf("\r\nThe function succeeded!\r\n");
000018  a00e              ADR      r0,|L14.84|
;;;33     			break;
00001a  e016              B        |L14.74|
;;;34     		}
;;;35     		case FR_NOT_READY://The disk drive cannot work due to no medium in the drive or any other reason
;;;36     		{
;;;37     		    printf("\r\nThe disk drive cannot work due to no medium in the drive or any other reason!\r\n");
00001c  4814              LDR      r0,|L14.112|
;;;38     			break;
00001e  e014              B        |L14.74|
;;;39     		}
;;;40     		case FR_NO_FILE://Could not find the file.
;;;41     		{
;;;42     		    printf("\r\nCould not find the file!\r\n");
000020  a014              ADR      r0,|L14.116|
;;;43     			break;
000022  e012              B        |L14.74|
;;;44     		}
;;;45     		case FR_NO_PATH://Could not find the path
;;;46     		{
;;;47     		    printf("\r\nCould not find the path!\r\n");
000024  a01b              ADR      r0,|L14.148|
;;;48     			break;
000026  e010              B        |L14.74|
;;;49     		}
;;;50     		case FR_INVALID_NAME://The path name is invalid
;;;51     		{
;;;52     		    printf("\r\nThe path name is invalid!\r\n");
000028  a022              ADR      r0,|L14.180|
;;;53     			break;
00002a  e00e              B        |L14.74|
;;;54     		}
;;;55     		case FR_INVALID_DRIVE://The drive number is invalid
;;;56     		{
;;;57     		    printf("\r\nThe drive number is invalid!\r\n");
00002c  a029              ADR      r0,|L14.212|
;;;58     			break;
00002e  e00c              B        |L14.74|
;;;59     		}
;;;60     		case FR_DENIED://The directory cannot be created due to directory table or disk is full. 
;;;61     		{
;;;62     		    printf("\r\nThe directory cannot be created due to directory table or disk is full!\r\n");
000030  4831              LDR      r0,|L14.248|
;;;63     			break;
000032  e00a              B        |L14.74|
;;;64     		}
;;;65     		case FR_EXIST://A file or directory that has same name is already existing
;;;66     		{
;;;67     		    printf("\r\nA file or directory that has same name is already existing!\r\n");
000034  a031              ADR      r0,|L14.252|
;;;68     			break;
000036  e008              B        |L14.74|
;;;69     		}
;;;70     //		case FR_RW_ERROR://The function failed due to a disk error or an internal error
;;;71     /*
;;;72     		case FR_RW_ERROR://The function failed due to a disk error or an internal error
;;;73     		{
;;;74     		    printp("\r\nThe function failed due to a disk error or an internal error!\r\n");
;;;75     			break;
;;;76     		}
;;;77     */
;;;78     		case FR_WRITE_PROTECTED://The medium is write protected
;;;79     		{
;;;80     		    printf("\r\nThe medium is write protected!\r\n");
000038  a040              ADR      r0,|L14.316|
;;;81     			break;
00003a  e006              B        |L14.74|
;;;82     		}
;;;83     		case FR_NOT_ENABLED://The logical drive has no work area
;;;84     		{
;;;85     		    printf("\r\nThe logical drive has no work area!\r\n");
00003c  a048              ADR      r0,|L14.352|
;;;86     			break;
00003e  e004              B        |L14.74|
;;;87     		}
;;;88     		case FR_NO_FILESYSTEM://There is no valid FAT partition on the disk
;;;89     		{
;;;90     		    printf("\r\nThere is no valid FAT partition on the disk!\r\n");
000040  a051              ADR      r0,|L14.392|
;;;91     			break;
000042  e002              B        |L14.74|
;;;92     		}
;;;93     		case FR_INVALID_OBJECT://The file object is invalid
;;;94     		{
;;;95     		    printf("\r\nThe file object is invalid!\r\n");
000044  a05d              ADR      r0,|L14.444|
;;;96     			break;
000046  e000              B        |L14.74|
;;;97     		}
;;;98            
;;;99     	    //The function aborted before start in format due to a reason as follows. 
;;;100            //The disk size is too small. 
;;;101            //Invalid parameter was given to any parameter. 
;;;102            //Not allowable cluster size for this drive. This can occure when number of clusters becomes around 0xFF7 and 0xFFF7. 
;;;103    		case FR_MKFS_ABORTED://
;;;104    		{
;;;105    		    printf("\r\nThe function aborted before start in format!\r\n");
000048  a064              ADR      r0,|L14.476|
                  |L14.74|
;;;106    			break;
;;;107    		}
;;;108    		
;;;109    		default:
;;;110    		{
;;;111    		    printf("\r\nerror!\r\n");
00004a  f7ffbffe          B.W      __2printf
                  |L14.78|
00004e  a070              ADR      r0,|L14.528|
;;;112    			break;
000050  e7fb              B        |L14.74|
;;;113    		}	
;;;114    	}
;;;115    	return;
;;;116    }
;;;117    void Test_f_getfree(void)//获取卡的总容量及剩余容量
                          ENDP

000052  0000              DCW      0x0000
                  |L14.84|
000054  0d0a5468          DCB      "\r\nThe function succeeded!\r\n",0
000058  65206675
00005c  6e637469
000060  6f6e2073
000064  75636365
000068  65646564
00006c  210d0a00
                  |L14.112|
                          DCD      ||.conststring||
                  |L14.116|
000074  0d0a436f          DCB      "\r\nCould not find the file!\r\n",0
000078  756c6420
00007c  6e6f7420
000080  66696e64
000084  20746865
000088  2066696c
00008c  65210d0a
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L14.148|
000094  0d0a436f          DCB      "\r\nCould not find the path!\r\n",0
000098  756c6420
00009c  6e6f7420
0000a0  66696e64
0000a4  20746865
0000a8  20706174
0000ac  68210d0a
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L14.180|
0000b4  0d0a5468          DCB      "\r\nThe path name is invalid!\r\n",0
0000b8  65207061
0000bc  7468206e
0000c0  616d6520
0000c4  69732069
0000c8  6e76616c
0000cc  6964210d
0000d0  0a00    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L14.212|
0000d4  0d0a5468          DCB      "\r\nThe drive number is invalid!\r\n",0
0000d8  65206472
0000dc  69766520
0000e0  6e756d62
0000e4  65722069
0000e8  7320696e
0000ec  76616c69
0000f0  64210d0a
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L14.248|
                          DCD      ||.conststring||+0x54
                  |L14.252|
0000fc  0d0a4120          DCB      "\r\nA file or directory that has same name is already e"
000100  66696c65
000104  206f7220
000108  64697265
00010c  63746f72
000110  79207468
000114  61742068
000118  61732073
00011c  616d6520
000120  6e616d65
000124  20697320
000128  616c7265
00012c  61647920
000130  65      
000131  78697374          DCB      "xisting!\r\n",0
000135  696e6721
000139  0d0a00  
                  |L14.316|
00013c  0d0a5468          DCB      "\r\nThe medium is write protected!\r\n",0
000140  65206d65
000144  6469756d
000148  20697320
00014c  77726974
000150  65207072
000154  6f746563
000158  74656421
00015c  0d0a00  
00015f  00                DCB      0
                  |L14.352|
000160  0d0a5468          DCB      "\r\nThe logical drive has no work area!\r\n",0
000164  65206c6f
000168  67696361
00016c  6c206472
000170  69766520
000174  68617320
000178  6e6f2077
00017c  6f726b20
000180  61726561
000184  210d0a00
                  |L14.392|
000188  0d0a5468          DCB      "\r\nThere is no valid FAT partition on the disk!\r\n",0
00018c  65726520
000190  6973206e
000194  6f207661
000198  6c696420
00019c  46415420
0001a0  70617274
0001a4  6974696f
0001a8  6e206f6e
0001ac  20746865
0001b0  20646973
0001b4  6b210d0a
0001b8  00      
0001b9  00                DCB      0
0001ba  00                DCB      0
0001bb  00                DCB      0
                  |L14.444|
0001bc  0d0a5468          DCB      "\r\nThe file object is invalid!\r\n",0
0001c0  65206669
0001c4  6c65206f
0001c8  626a6563
0001cc  74206973
0001d0  20696e76
0001d4  616c6964
0001d8  210d0a00
                  |L14.476|
0001dc  0d0a5468          DCB      "\r\nThe function aborted before start in format!\r\n",0
0001e0  65206675
0001e4  6e637469
0001e8  6f6e2061
0001ec  626f7274
0001f0  65642062
0001f4  65666f72
0001f8  65207374
0001fc  61727420
000200  696e2066
000204  6f726d61
000208  74210d0a
00020c  00      
00020d  00                DCB      0
00020e  00                DCB      0
00020f  00                DCB      0
                  |L14.528|
000210  0d0a6572          DCB      "\r\nerror!\r\n",0
000214  726f7221
000218  0d0a00  
00021b  00                DCB      0

                          AREA ||i.disk_detect_OK||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  disk_detect_OK PROC
;;;12     //检测磁盘是否插好
;;;13     BOOL disk_detect_OK(void)
000000  b510              PUSH     {r4,lr}
;;;14     {
;;;15       if( disk_status(0)==STA_NODISK )/* Physical drive nmuber (0..) */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       disk_status
000008  2802              CMP      r0,#2
00000a  d001              BEQ      |L15.16|
;;;16     	{
;;;17     	    printf("\r\n\r\n%48s\r\n","<未检测到磁盘,请检查SD卡是否插好...>");
;;;18     		return FALSE;
;;;19     	}
;;;20     	return TRUE;
00000c  2001              MOVS     r0,#1
;;;21     }
00000e  bd10              POP      {r4,pc}
                  |L15.16|
000010  a102              ADR      r1,|L15.28|
000012  a00c              ADR      r0,|L15.68|
000014  f7fffffe          BL       __2printf
000018  2000              MOVS     r0,#0                 ;18
00001a  bd10              POP      {r4,pc}
;;;22     
                          ENDP

                  |L15.28|
00001c  3cceb4bc          DCB      "<",206,180,188,236,178,226,181,189,180,197,197,204,",",199
000020  ecb2e2b5
000024  bdb4c5c5
000028  cc2cc7  
00002b  ebbcecb2          DCB      235,188,236,178,233,"SD",191,168,202,199,183,241,178,229
00002f  e95344bf
000033  a8cac7b7
000037  f1b2e5  
00003a  bac32e2e          DCB      186,195,"...>",0
00003e  2e3e00  
000041  00                DCB      0
000042  00                DCB      0
000043  00                DCB      0
                  |L15.68|
000044  0d0a0d0a          DCB      "\r\n\r\n%48s\r\n",0
000048  25343873
00004c  0d0a00  
00004f  00                DCB      0

                          AREA ||i.readfirenum||, CODE, READONLY, ALIGN=1

                  readfirenum PROC
;;;453    //unsigned
;;;454    void readfirenum(char *path,char *data)
000000  b530              PUSH     {r4,r5,lr}
;;;455    {
000002  f2ad4d5c          SUB      sp,sp,#0x45c
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
;;;456    	//char data[20];
;;;457    	FATFS fs;            // Work area (file system object) for logical drive
;;;458    	FIL file;            // file objects
;;;459    	UINT br;             // File R count 文件读回的字节计数
;;;460    	f_mount(0, &fs);
00000a  a989              ADD      r1,sp,#0x224
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       f_mount
;;;461    
;;;462    	f_open(&file, path, FA_OPEN_EXISTING | FA_READ);//打开存在的文件，如果没有则返回错误
000012  2201              MOVS     r2,#1
000014  4621              MOV      r1,r4
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       f_open
;;;463    
;;;464    //	res = f_lseek(&file,ofs); //指针移到文件ofs个字节处
;;;465    
;;;466    	f_read(&file, data, file.fsize, &br);
00001c  f20d4354          ADD      r3,sp,#0x454
000020  4629              MOV      r1,r5
000022  4668              MOV      r0,sp
000024  9a03              LDR      r2,[sp,#0xc]
000026  f7fffffe          BL       f_read
;;;467    	f_close(&file);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       f_close
;;;468    
;;;469    	f_mount(0, NULL);
000030  2100              MOVS     r1,#0
000032  4608              MOV      r0,r1
000034  f7fffffe          BL       f_mount
;;;470    	//return  atoi(data);
;;;471    	
;;;472    }
000038  f20d4d5c          ADD      sp,sp,#0x45c
00003c  bd30              POP      {r4,r5,pc}
;;;473    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  d0c2bda8          DCB      0xd0,0xc2,0xbd,0xa8
000004  cec4bcfe          DCB      0xce,0xc4,0xbc,0xfe
000008  2e747874          DCB      0x2e,0x74,0x78,0x74
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000014  d0c2bda8          DCB      0xd0,0xc2,0xbd,0xa8
000018  cec4bcfe          DCB      0xce,0xc4,0xbc,0xfe
00001c  2e747874          DCB      0x2e,0x74,0x78,0x74
000020  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  0d0a5468          DCB      "\r\nThe disk drive cannot work due to no medium in the "
000004  65206469
000008  736b2064
00000c  72697665
000010  2063616e
000014  6e6f7420
000018  776f726b
00001c  20647565
000020  20746f20
000024  6e6f206d
000028  65646975
00002c  6d20696e
000030  20746865
000034  20      
000035  64726976          DCB      "drive or any other reason!\r\n",0
000039  65206f72
00003d  20616e79
000041  206f7468
000045  65722072
000049  6561736f
00004d  6e210d0a
000051  00      
000052  00                DCB      0
000053  00                DCB      0
000054  0d0a5468          DCB      "\r\nThe directory cannot be created due to directory ta"
000058  65206469
00005c  72656374
000060  6f727920
000064  63616e6e
000068  6f742062
00006c  65206372
000070  65617465
000074  64206475
000078  6520746f
00007c  20646972
000080  6563746f
000084  72792074
000088  61      
000089  626c6520          DCB      "ble or disk is full!\r\n",0
00008d  6f722064
000091  69736b20
000095  69732066
000099  756c6c21
00009d  0d0a00  
