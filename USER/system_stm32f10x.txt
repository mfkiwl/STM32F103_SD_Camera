; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\system_stm32f10x.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\system_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\HARDWARE\LED -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\STM32F10x_FWLib\inc -I..\CORE -I..\HARDWARE\SPI -I..\HARDWARE\MMC_SD -I..\HARDWARE\SPI -I..\HARDWARE\LED -I..\HARDWARE\WNOTEPAD -I..\HARDWARE\RTC -I..\FATFS -I..\FATFS\option -I..\HARDWARE\USART3 -I..\APPS -I..\HARDWARE\OV2640 -I..\HARDWARE\24LC1024 -I..\HARDWARE\RAM -I.\RTE\_Target_1 -ID:\EmbeddedTools\MDK51_RAM\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\EmbeddedTools\MDK51_RAM\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\system_stm32f10x.crf system_stm32f10x.c]
                          THUMB

                          AREA ||i.SetSysClockTo72||, CODE, READONLY, ALIGN=2

                  SetSysClockTo72 PROC
;;;928      */
;;;929    static void SetSysClockTo72(void)
000000  b50c              PUSH     {r2,r3,lr}
;;;930    {
;;;931        __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2200              MOVS     r2,#0
;;;932    
;;;933        /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
;;;934        /* Enable HSE */
;;;935        RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000004  4826              LDR      r0,|L1.160|
000006  9200              STR      r2,[sp,#0]            ;931
000008  9201              STR      r2,[sp,#4]
00000a  6801              LDR      r1,[r0,#0]
00000c  f4413180          ORR      r1,r1,#0x10000
000010  6001              STR      r1,[r0,#0]
;;;936    
;;;937        /* Wait till HSE is ready and if Time out is reached exit */
;;;938        do {
;;;939            HSEStatus = RCC->CR & RCC_CR_HSERDY;
;;;940            StartUpCounter++;
;;;941        } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
000012  f44f63a0          MOV      r3,#0x500
                  |L1.22|
000016  6801              LDR      r1,[r0,#0]            ;939
000018  f4013100          AND      r1,r1,#0x20000        ;939
00001c  9101              STR      r1,[sp,#4]            ;940
00001e  9900              LDR      r1,[sp,#0]            ;940
000020  1c49              ADDS     r1,r1,#1              ;940
000022  9100              STR      r1,[sp,#0]
000024  9901              LDR      r1,[sp,#4]
000026  b911              CBNZ     r1,|L1.46|
000028  9900              LDR      r1,[sp,#0]
00002a  4299              CMP      r1,r3
00002c  d1f3              BNE      |L1.22|
                  |L1.46|
;;;942    
;;;943        if ((RCC->CR & RCC_CR_HSERDY) != RESET) {
00002e  6801              LDR      r1,[r0,#0]
000030  0389              LSLS     r1,r1,#14
000032  d533              BPL      |L1.156|
;;;944            HSEStatus = (uint32_t)0x01;
000034  2101              MOVS     r1,#1
;;;945        } else {
;;;946            HSEStatus = (uint32_t)0x00;
;;;947        }
;;;948    
;;;949        if (HSEStatus == (uint32_t)0x01) {
;;;950            /* Enable Prefetch Buffer */
;;;951            FLASH->ACR |= FLASH_ACR_PRFTBE;
000036  9101              STR      r1,[sp,#4]
000038  491a              LDR      r1,|L1.164|
00003a  680a              LDR      r2,[r1,#0]
00003c  f0420210          ORR      r2,r2,#0x10
000040  600a              STR      r2,[r1,#0]
;;;952    
;;;953            /* Flash 2 wait state */
;;;954            FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
000042  680a              LDR      r2,[r1,#0]
000044  f0220203          BIC      r2,r2,#3
000048  600a              STR      r2,[r1,#0]
;;;955            FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;
00004a  680a              LDR      r2,[r1,#0]
00004c  f0420202          ORR      r2,r2,#2
000050  600a              STR      r2,[r1,#0]
;;;956    
;;;957    
;;;958            /* HCLK = SYSCLK */
;;;959            RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
000052  6841              LDR      r1,[r0,#4]
000054  6041              STR      r1,[r0,#4]
;;;960    
;;;961            /* PCLK2 = HCLK */
;;;962            RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000056  6841              LDR      r1,[r0,#4]
000058  6041              STR      r1,[r0,#4]
;;;963    
;;;964            /* PCLK1 = HCLK */
;;;965            RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
00005a  6841              LDR      r1,[r0,#4]
00005c  f4416180          ORR      r1,r1,#0x400
000060  6041              STR      r1,[r0,#4]
;;;966    
;;;967    #ifdef STM32F10X_CL
;;;968            /* Configure PLLs ------------------------------------------------------*/
;;;969            /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;970            /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;971    
;;;972            RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;973                                      RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;974            RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;975                                     RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
;;;976    
;;;977            /* Enable PLL2 */
;;;978            RCC->CR |= RCC_CR_PLL2ON;
;;;979            /* Wait till PLL2 is ready */
;;;980            while((RCC->CR & RCC_CR_PLL2RDY) == 0) {
;;;981            }
;;;982    
;;;983    
;;;984            /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */
;;;985            RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;986            RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |
;;;987                                    RCC_CFGR_PLLMULL9);
;;;988    #else
;;;989            /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
;;;990            RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
000062  6841              LDR      r1,[r0,#4]
000064  f421117c          BIC      r1,r1,#0x3f0000
000068  6041              STR      r1,[r0,#4]
;;;991                                                RCC_CFGR_PLLMULL));
;;;992            RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
00006a  6841              LDR      r1,[r0,#4]
00006c  f44111e8          ORR      r1,r1,#0x1d0000
000070  6041              STR      r1,[r0,#4]
;;;993    #endif /* STM32F10X_CL */
;;;994    
;;;995            /* Enable PLL */
;;;996            RCC->CR |= RCC_CR_PLLON;
000072  6801              LDR      r1,[r0,#0]
000074  f0417180          ORR      r1,r1,#0x1000000
000078  6001              STR      r1,[r0,#0]
                  |L1.122|
;;;997    
;;;998            /* Wait till PLL is ready */
;;;999            while((RCC->CR & RCC_CR_PLLRDY) == 0) {
00007a  6801              LDR      r1,[r0,#0]
00007c  0189              LSLS     r1,r1,#6
00007e  d5fc              BPL      |L1.122|
;;;1000           }
;;;1001   
;;;1002           /* Select PLL as system clock source */
;;;1003           RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
000080  6841              LDR      r1,[r0,#4]
000082  f0210103          BIC      r1,r1,#3
000086  6041              STR      r1,[r0,#4]
;;;1004           RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
000088  6841              LDR      r1,[r0,#4]
00008a  f0410102          ORR      r1,r1,#2
00008e  6041              STR      r1,[r0,#4]
                  |L1.144|
;;;1005   
;;;1006           /* Wait till PLL is used as system clock source */
;;;1007           while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08) {
000090  6841              LDR      r1,[r0,#4]
000092  f3c10181          UBFX     r1,r1,#2,#2
000096  2902              CMP      r1,#2
000098  d1fa              BNE      |L1.144|
;;;1008           }
;;;1009       } else {
;;;1010           /* If HSE fails to start-up, the application will have wrong clock
;;;1011                configuration. User can add here some code to deal with this error */
;;;1012       }
;;;1013   }
00009a  bd0c              POP      {r2,r3,pc}
                  |L1.156|
00009c  9201              STR      r2,[sp,#4]            ;946
00009e  bd0c              POP      {r2,r3,pc}
;;;1014   #endif
                          ENDP

                  |L1.160|
                          DCD      0x40021000
                  |L1.164|
                          DCD      0x40022000

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;305      */
;;;306    void SystemCoreClockUpdate (void)
000000  4a15              LDR      r2,|L2.88|
;;;307    {
000002  b510              PUSH     {r4,lr}
;;;308        uint32_t tmp = 0, pllmull = 0, pllsource = 0;
;;;309    
;;;310    #ifdef  STM32F10X_CL
;;;311        uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;312    #endif /* STM32F10X_CL */
;;;313    
;;;314    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;315        uint32_t prediv1factor = 0;
;;;316    #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
;;;317    
;;;318        /* Get SYSCLK source -------------------------------------------------------*/
;;;319        tmp = RCC->CFGR & RCC_CFGR_SWS;
000004  6850              LDR      r0,[r2,#4]
;;;320    
;;;321        switch (tmp) {
;;;322        case 0x00:  /* HSI used as system clock */
;;;323            SystemCoreClock = HSI_VALUE;
000006  4b15              LDR      r3,|L2.92|
000008  f010010c          ANDS     r1,r0,#0xc            ;319
00000c  4814              LDR      r0,|L2.96|
00000e  d003              BEQ      |L2.24|
000010  2904              CMP      r1,#4                 ;321
000012  d001              BEQ      |L2.24|
000014  2908              CMP      r1,#8                 ;321
000016  d001              BEQ      |L2.28|
                  |L2.24|
;;;324            break;
000018  6003              STR      r3,[r0,#0]  ; SystemCoreClock
00001a  e012              B        |L2.66|
                  |L2.28|
;;;325        case 0x04:  /* HSE used as system clock */
;;;326            SystemCoreClock = HSE_VALUE;
;;;327            break;
;;;328        case 0x08:  /* PLL used as system clock */
;;;329    
;;;330            /* Get PLL clock source and multiplication factor ----------------------*/
;;;331            pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
00001c  6851              LDR      r1,[r2,#4]
;;;332            pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
00001e  6853              LDR      r3,[r2,#4]
000020  f4011170          AND      r1,r1,#0x3c0000       ;331
;;;333    
;;;334    #ifndef STM32F10X_CL
;;;335            pllmull = ( pllmull >> 18) + 2;
000024  f04f0402          MOV      r4,#2
000028  f4133f80          TST      r3,#0x10000           ;332
00002c  eb044191          ADD      r1,r4,r1,LSR #18
;;;336    
;;;337            if (pllsource == 0x00) {
000030  d002              BEQ      |L2.56|
;;;338                /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;339                SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;340            } else {
;;;341    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;342                prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;343                /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;344                SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;
;;;345    #else
;;;346                /* HSE selected as PLL clock entry */
;;;347                if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET) {
000032  6853              LDR      r3,[r2,#4]
000034  039b              LSLS     r3,r3,#14
000036  d501              BPL      |L2.60|
                  |L2.56|
000038  4b0a              LDR      r3,|L2.100|
00003a  e000              B        |L2.62|
                  |L2.60|
;;;348                    /* HSE oscillator clock divided by 2 */
;;;349                    SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
;;;350                } else {
;;;351                    SystemCoreClock = HSE_VALUE * pllmull;
00003c  4b07              LDR      r3,|L2.92|
                  |L2.62|
00003e  4359              MULS     r1,r3,r1              ;349
000040  6001              STR      r1,[r0,#0]            ;349  ; SystemCoreClock
                  |L2.66|
;;;352                }
;;;353    #endif
;;;354            }
;;;355    #else
;;;356            pllmull = pllmull >> 18;
;;;357    
;;;358            if (pllmull != 0x0D) {
;;;359                pllmull += 2;
;;;360            } else {
;;;361                /* PLL multiplication factor = PLL input clock * 6.5 */
;;;362                pllmull = 13 / 2;
;;;363            }
;;;364    
;;;365            if (pllsource == 0x00) {
;;;366                /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;367                SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;368            } else {
;;;369                /* PREDIV1 selected as PLL clock entry */
;;;370    
;;;371                /* Get PREDIV1 clock source and division factor */
;;;372                prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
;;;373                prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;374    
;;;375                if (prediv1source == 0) {
;;;376                    /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;377                    SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;
;;;378                } else {
;;;379                    /* PLL2 clock selected as PREDIV1 clock entry */
;;;380    
;;;381                    /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;382                    prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
;;;383                    pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2;
;;;384                    SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;
;;;385                }
;;;386            }
;;;387    #endif /* STM32F10X_CL */
;;;388            break;
;;;389    
;;;390        default:
;;;391            SystemCoreClock = HSI_VALUE;
;;;392            break;
;;;393        }
;;;394    
;;;395        /* Compute HCLK clock frequency ----------------*/
;;;396        /* Get HCLK prescaler */
;;;397        tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
000042  6851              LDR      r1,[r2,#4]
000044  4a06              LDR      r2,|L2.96|
000046  f3c11103          UBFX     r1,r1,#4,#4
00004a  1d12              ADDS     r2,r2,#4
00004c  5c51              LDRB     r1,[r2,r1]
;;;398        /* HCLK clock frequency */
;;;399        SystemCoreClock >>= tmp;
00004e  6802              LDR      r2,[r0,#0]  ; SystemCoreClock
000050  40ca              LSRS     r2,r2,r1
000052  6002              STR      r2,[r0,#0]  ; SystemCoreClock
;;;400    }
000054  bd10              POP      {r4,pc}
;;;401    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      0x40021000
                  |L2.92|
                          DCD      0x007a1200
                  |L2.96|
                          DCD      ||.data||
                  |L2.100|
                          DCD      0x003d0900

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;211      */
;;;212    void SystemInit (void)
000000  480f              LDR      r0,|L3.64|
;;;213    {
000002  b510              PUSH     {r4,lr}
;;;214        /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
;;;215        /* Set HSION bit */
;;;216        RCC->CR |= (uint32_t)0x00000001;
000004  6801              LDR      r1,[r0,#0]
000006  f0410101          ORR      r1,r1,#1
00000a  6001              STR      r1,[r0,#0]
;;;217    
;;;218        /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;219    #ifndef STM32F10X_CL
;;;220        RCC->CFGR &= (uint32_t)0xF8FF0000;
00000c  6841              LDR      r1,[r0,#4]
00000e  4a0d              LDR      r2,|L3.68|
000010  4011              ANDS     r1,r1,r2
000012  6041              STR      r1,[r0,#4]
;;;221    #else
;;;222        RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;223    #endif /* STM32F10X_CL */
;;;224    
;;;225        /* Reset HSEON, CSSON and PLLON bits */
;;;226        RCC->CR &= (uint32_t)0xFEF6FFFF;
000014  6801              LDR      r1,[r0,#0]
000016  4a0c              LDR      r2,|L3.72|
000018  4011              ANDS     r1,r1,r2
00001a  6001              STR      r1,[r0,#0]
;;;227    
;;;228        /* Reset HSEBYP bit */
;;;229        RCC->CR &= (uint32_t)0xFFFBFFFF;
00001c  6801              LDR      r1,[r0,#0]
00001e  f4212180          BIC      r1,r1,#0x40000
000022  6001              STR      r1,[r0,#0]
;;;230    
;;;231        /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;232        RCC->CFGR &= (uint32_t)0xFF80FFFF;
000024  6841              LDR      r1,[r0,#4]
000026  f42101fe          BIC      r1,r1,#0x7f0000
00002a  6041              STR      r1,[r0,#4]
;;;233    
;;;234    #ifdef STM32F10X_CL
;;;235        /* Reset PLL2ON and PLL3ON bits */
;;;236        RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;237    
;;;238        /* Disable all interrupts and clear pending bits  */
;;;239        RCC->CIR = 0x00FF0000;
;;;240    
;;;241        /* Reset CFGR2 register */
;;;242        RCC->CFGR2 = 0x00000000;
;;;243    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;244        /* Disable all interrupts and clear pending bits  */
;;;245        RCC->CIR = 0x009F0000;
;;;246    
;;;247        /* Reset CFGR2 register */
;;;248        RCC->CFGR2 = 0x00000000;
;;;249    #else
;;;250        /* Disable all interrupts and clear pending bits  */
;;;251        RCC->CIR = 0x009F0000;
00002c  f44f011f          MOV      r1,#0x9f0000
000030  6081              STR      r1,[r0,#8]
000032  f7fffffe          BL       SetSysClockTo72
;;;252    #endif /* STM32F10X_CL */
;;;253    
;;;254    #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
;;;255    #ifdef DATA_IN_ExtSRAM
;;;256        SystemInit_ExtMemCtl();
;;;257    #endif /* DATA_IN_ExtSRAM */
;;;258    #endif
;;;259    
;;;260        /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
;;;261        /* Configure the Flash Latency cycles and enable prefetch buffer */
;;;262        SetSysClock();
;;;263    
;;;264    #ifdef VECT_TAB_SRAM
;;;265        SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;266    #else
;;;267        SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
000036  4905              LDR      r1,|L3.76|
000038  f04f6000          MOV      r0,#0x8000000
00003c  6008              STR      r0,[r1,#0]
;;;268    #endif
;;;269    }
00003e  bd10              POP      {r4,pc}
;;;270    
                          ENDP

                  |L3.64|
                          DCD      0x40021000
                  |L3.68|
                          DCD      0xf8ff0000
                  |L3.72|
                          DCD      0xfef6ffff
                  |L3.76|
                          DCD      0xe000ed08

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x044aa200
                  AHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09
