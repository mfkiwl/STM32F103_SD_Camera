; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\mmc_sd.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\mmc_sd.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\HARDWARE\LED -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\STM32F10x_FWLib\inc -I..\CORE -I..\HARDWARE\SPI -I..\HARDWARE\MMC_SD -I..\HARDWARE\SPI -I..\HARDWARE\LED -I..\HARDWARE\WNOTEPAD -I..\HARDWARE\RTC -I..\FATFS -I..\FATFS\option -I..\HARDWARE\USART3 -I..\APPS -I..\HARDWARE\OV2640 -I..\HARDWARE\24LC1024 -I..\HARDWARE\RAM -I.\RTE\_Target_1 -ID:\EmbeddedTools\MDK51_RAM\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\EmbeddedTools\MDK51_RAM\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\mmc_sd.crf ..\HARDWARE\MMC_SD\mmc_sd.c]
                          THUMB

                          AREA ||i.SD_DisSelect||, CODE, READONLY, ALIGN=2

                  SD_DisSelect PROC
;;;38     //取消选择,释放SPI总线
;;;39     void SD_DisSelect(void) {
000000  4903              LDR      r1,|L1.16|
;;;40         SD_CS=1;
000002  2001              MOVS     r0,#1
000004  f8c1018c          STR      r0,[r1,#0x18c]
;;;41         SD_SPI_ReadWriteByte(0xff);//提供额外的8个时钟
000008  20ff              MOVS     r0,#0xff
00000a  f7ffbffe          B.W      SPIx_ReadWriteByte
;;;42     }
;;;43     //选择sd卡,并且等待卡准备OK
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x42210000

                          AREA ||i.SD_GetCID||, CODE, READONLY, ALIGN=1

                  SD_GetCID PROC
;;;133    //		 1：错误
;;;134    u8 SD_GetCID(u8 *cid_data) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;135        u8 r1;
;;;136        //发CMD10命令，读CID
;;;137        r1=SD_SendCmd(CMD10,0,0x01);
000004  2201              MOVS     r2,#1
000006  2100              MOVS     r1,#0
000008  200a              MOVS     r0,#0xa
00000a  f7fffffe          BL       SD_SendCmd
00000e  0004              MOVS     r4,r0
;;;138        if(r1==0x00) {
000010  d104              BNE      |L2.28|
;;;139            r1=SD_RecvData(cid_data,16);//接收16个字节的数据
000012  2110              MOVS     r1,#0x10
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       SD_RecvData
00001a  4604              MOV      r4,r0
                  |L2.28|
;;;140        }
;;;141        SD_DisSelect();//取消片选
00001c  f7fffffe          BL       SD_DisSelect
;;;142        if(r1)return 1;
000020  b10c              CBZ      r4,|L2.38|
000022  2001              MOVS     r0,#1
;;;143        else return 0;
;;;144    }
000024  bd70              POP      {r4-r6,pc}
                  |L2.38|
000026  2000              MOVS     r0,#0                 ;143
000028  bd70              POP      {r4-r6,pc}
;;;145    //获取SD卡的CSD信息，包括容量和速度信息
                          ENDP


                          AREA ||i.SD_GetCSD||, CODE, READONLY, ALIGN=1

                  SD_GetCSD PROC
;;;148    //		 1：错误
;;;149    u8 SD_GetCSD(u8 *csd_data) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;150        u8 r1;
;;;151        r1=SD_SendCmd(CMD9,0,0x01);//发CMD9命令，读CSD
000004  2201              MOVS     r2,#1
000006  2100              MOVS     r1,#0
000008  2009              MOVS     r0,#9
00000a  f7fffffe          BL       SD_SendCmd
00000e  0004              MOVS     r4,r0
;;;152        if(r1==0) {
000010  d104              BNE      |L3.28|
;;;153            r1=SD_RecvData(csd_data, 16);//接收16个字节的数据
000012  2110              MOVS     r1,#0x10
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       SD_RecvData
00001a  4604              MOV      r4,r0
                  |L3.28|
;;;154        }
;;;155        SD_DisSelect();//取消片选
00001c  f7fffffe          BL       SD_DisSelect
;;;156        if(r1)return 1;
000020  b10c              CBZ      r4,|L3.38|
000022  2001              MOVS     r0,#1
;;;157        else return 0;
;;;158    }
000024  bd70              POP      {r4-r6,pc}
                  |L3.38|
000026  2000              MOVS     r0,#0                 ;157
000028  bd70              POP      {r4-r6,pc}
;;;159    //获取SD卡的总扇区数（扇区数）
                          ENDP


                          AREA ||i.SD_GetResponse||, CODE, READONLY, ALIGN=1

                  SD_GetResponse PROC
;;;64     //    其他,得到回应值失败
;;;65     u8 SD_GetResponse(u8 Response) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;66         u16 Count=0xFFF;//等待次数
000004  f64074ff          MOV      r4,#0xfff
000008  e001              B        |L4.14|
                  |L4.10|
00000a  1e64              SUBS     r4,r4,#1              ;65
;;;67         while ((SD_SPI_ReadWriteByte(0XFF)!=Response)&&Count)Count--;//等待得到准确的回应
00000c  b2a4              UXTH     r4,r4
                  |L4.14|
00000e  20ff              MOVS     r0,#0xff
000010  f7fffffe          BL       SD_SPI_ReadWriteByte
000014  42a8              CMP      r0,r5
000016  d002              BEQ      |L4.30|
000018  2c00              CMP      r4,#0
00001a  d1f6              BNE      |L4.10|
00001c  e002              B        |L4.36|
                  |L4.30|
;;;68         if (Count==0)return MSD_RESPONSE_FAILURE;//得到回应失败
00001e  b10c              CBZ      r4,|L4.36|
;;;69         else return MSD_RESPONSE_NO_ERROR;//正确回应
000020  2000              MOVS     r0,#0
;;;70     }
000022  bd70              POP      {r4-r6,pc}
                  |L4.36|
000024  20ff              MOVS     r0,#0xff              ;68
000026  bd70              POP      {r4-r6,pc}
;;;71     //从sd卡读取一个数据包的内容
                          ENDP


                          AREA ||i.SD_GetSectorCount||, CODE, READONLY, ALIGN=1

                  SD_GetSectorCount PROC
;;;162    //每扇区的字节数必为512，因为如果不是512，则初始化不能通过.
;;;163    u32 SD_GetSectorCount(void) {
000000  b51f              PUSH     {r0-r4,lr}
;;;164        u8 csd[16];
;;;165        u32 Capacity;
;;;166        u8 n;
;;;167        u16 csize;
;;;168        //取CSD信息，如果期间出错，返回0
;;;169        if(SD_GetCSD(csd)!=0) return 0;
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       SD_GetCSD
000008  b110              CBZ      r0,|L5.16|
00000a  2000              MOVS     r0,#0
                  |L5.12|
;;;170        //如果为SDHC卡，按照下面方式计算
;;;171        if((csd[0]&0xC0)==0x40) { //V2.00的卡
;;;172            csize = csd[9] + ((u16)csd[8] << 8) + 1;
;;;173            Capacity = (u32)csize << 10;//得到扇区数
;;;174        } else { //V1.XX的卡
;;;175            n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
;;;176            csize = (csd[8] >> 6) + ((u16)csd[7] << 2) + ((u16)(csd[6] & 3) << 10) + 1;
;;;177            Capacity= (u32)csize << (n - 9);//得到扇区数
;;;178        }
;;;179        return Capacity;
;;;180    }
00000c  b004              ADD      sp,sp,#0x10
00000e  bd10              POP      {r4,pc}
                  |L5.16|
000010  f89d1000          LDRB     r1,[sp,#0]            ;171
000014  2001              MOVS     r0,#1                 ;171
000016  ebb01f91          CMP      r0,r1,LSR #6          ;171
00001a  d109              BNE      |L5.48|
00001c  f89d2008          LDRB     r2,[sp,#8]            ;172
000020  f89d1009          LDRB     r1,[sp,#9]            ;172
000024  eb002002          ADD      r0,r0,r2,LSL #8       ;172
000028  4408              ADD      r0,r0,r1              ;172
00002a  0400              LSLS     r0,r0,#16             ;172
00002c  0980              LSRS     r0,r0,#6              ;173
00002e  e7ed              B        |L5.12|
                  |L5.48|
000030  f89d0005          LDRB     r0,[sp,#5]            ;175
000034  f89d100a          LDRB     r1,[sp,#0xa]          ;175
000038  f000000f          AND      r0,r0,#0xf            ;175
00003c  eb0010d1          ADD      r0,r0,r1,LSR #7       ;175
000040  f89d1009          LDRB     r1,[sp,#9]            ;175
000044  f89d2007          LDRB     r2,[sp,#7]            ;176
000048  f0010103          AND      r1,r1,#3              ;175
00004c  eb000141          ADD      r1,r0,r1,LSL #1       ;175
000050  f89d0008          LDRB     r0,[sp,#8]            ;176
000054  0980              LSRS     r0,r0,#6              ;176
000056  eb000082          ADD      r0,r0,r2,LSL #2       ;176
00005a  f89d2006          LDRB     r2,[sp,#6]            ;176
00005e  f0020203          AND      r2,r2,#3              ;176
000062  eb002082          ADD      r0,r0,r2,LSL #10      ;176
000066  1c40              ADDS     r0,r0,#1              ;176
000068  1fc9              SUBS     r1,r1,#7              ;176
00006a  4088              LSLS     r0,r0,r1              ;177
00006c  e7ce              B        |L5.12|
;;;181    u8 SD_Idle_Sta(void) {
                          ENDP


                          AREA ||i.SD_Idle_Sta||, CODE, READONLY, ALIGN=1

                  SD_Idle_Sta PROC
;;;180    }
;;;181    u8 SD_Idle_Sta(void) {
000000  b510              PUSH     {r4,lr}
;;;182        u16 i;
;;;183        u8 retry;
;;;184        for(i=0; i<0xf00; i++); //纯延时，等待SD卡上电完成
000002  2000              MOVS     r0,#0
000004  f44f6170          MOV      r1,#0xf00
                  |L6.8|
000008  1c40              ADDS     r0,r0,#1
00000a  b280              UXTH     r0,r0
00000c  4288              CMP      r0,r1
00000e  d3fb              BCC      |L6.8|
;;;185        //先产生>74个脉冲，让SD卡自己初始化完成
;;;186        for(i=0; i<10; i++)SPIx_ReadWriteByte(0xFF);
000010  2400              MOVS     r4,#0
                  |L6.18|
000012  20ff              MOVS     r0,#0xff
000014  f7fffffe          BL       SPIx_ReadWriteByte
000018  1c64              ADDS     r4,r4,#1
00001a  b2a4              UXTH     r4,r4
00001c  2c0a              CMP      r4,#0xa
00001e  d3f8              BCC      |L6.18|
;;;187        //-----------------SD卡复位到idle开始-----------------
;;;188        //循环连续发送CMD0，直到SD卡返回0x01,进入IDLE状态
;;;189        //超时则直接退出
;;;190        retry = 0;
000020  2400              MOVS     r4,#0
                  |L6.34|
;;;191        do {
;;;192            //发送CMD0，让SD卡进入IDLE状态
;;;193            i = SD_SendCmd(CMD0, 0, 0x95);
000022  2100              MOVS     r1,#0
000024  2295              MOVS     r2,#0x95
000026  4608              MOV      r0,r1
000028  f7fffffe          BL       SD_SendCmd
00002c  1c64              ADDS     r4,r4,#1
;;;194            retry++;
00002e  b2e4              UXTB     r4,r4
;;;195        } while((i!=0x01)&&(retry<200));
000030  2801              CMP      r0,#1
000032  d001              BEQ      |L6.56|
000034  2cc8              CMP      r4,#0xc8
000036  d3f4              BCC      |L6.34|
                  |L6.56|
;;;196        //跳出循环后，检查原因：初始化成功？or 重试超时？
;;;197        if(retry==200)return 1; //失败
000038  2cc8              CMP      r4,#0xc8
00003a  d001              BEQ      |L6.64|
;;;198        return 0;//成功
00003c  2000              MOVS     r0,#0
;;;199    }
00003e  bd10              POP      {r4,pc}
                  |L6.64|
000040  2001              MOVS     r0,#1                 ;197
000042  bd10              POP      {r4,pc}
;;;200    //初始化SD卡
                          ENDP


                          AREA ||i.SD_Initialize||, CODE, READONLY, ALIGN=2

                  SD_Initialize PROC
;;;200    //初始化SD卡
;;;201    u8 SD_Initialize(void) {
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;202        u8 r1;      // 存放SD卡的返回值
;;;203        u16 retry;  // 用来进行超时计数
;;;204        u8 buf[4];
;;;205        u16 i;
;;;206    
;;;207        SD_SPI_Init();		//初始化IO
000004  f7fffffe          BL       SD_SPI_Init
000008  2038              MOVS     r0,#0x38
00000a  f7fffffe          BL       SPIx_SetSpeed
;;;208        SD_SPI_SpeedLow();	//设置到低速模式
;;;209        //for(i=0;i<0xf00;i++);//纯延时，等待SD卡上电完成
;;;210        for(i=0; i<10; i++)SD_SPI_ReadWriteByte(0XFF); //发送最少74个脉冲
00000e  2400              MOVS     r4,#0
                  |L7.16|
000010  20ff              MOVS     r0,#0xff
000012  f7fffffe          BL       SPIx_ReadWriteByte
000016  1c64              ADDS     r4,r4,#1
000018  b2a4              UXTH     r4,r4
00001a  2c0a              CMP      r4,#0xa
00001c  d3f8              BCC      |L7.16|
;;;211        retry=20;
00001e  2414              MOVS     r4,#0x14
                  |L7.32|
;;;212        do {
;;;213            r1=SD_SendCmd(CMD0,0,0x95);//进入IDLE状态
000020  2100              MOVS     r1,#0
000022  2295              MOVS     r2,#0x95
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       SD_SendCmd
00002a  4605              MOV      r5,r0
;;;214        } while((r1!=0X01) && retry--);
00002c  2801              CMP      r0,#1
00002e  d002              BEQ      |L7.54|
000030  1e64              SUBS     r4,r4,#1
000032  b2a4              UXTH     r4,r4
000034  d2f4              BCS      |L7.32|
                  |L7.54|
;;;215        SD_Type=0;//默认无卡
000036  4e47              LDR      r6,|L7.340|
000038  2700              MOVS     r7,#0
;;;216        if(r1==0X01) {
00003a  2d01              CMP      r5,#1
00003c  7037              STRB     r7,[r6,#0]            ;215
00003e  d17a              BNE      |L7.310|
;;;217            if(SD_SendCmd(CMD8,0x1AA,0x87)==1) { //SD V2.0
000040  2287              MOVS     r2,#0x87
000042  f44f71d5          MOV      r1,#0x1aa
000046  2008              MOVS     r0,#8
000048  f7fffffe          BL       SD_SendCmd
;;;218                for(i=0; i<4; i++)buf[i]=SD_SPI_ReadWriteByte(0XFF);	//Get trailing return value of R7 resp
;;;219                if(buf[2]==0X01&&buf[3]==0XAA) { //卡是否支持2.7~3.6V
;;;220                    retry=0XFFFE;
00004c  f64f78fe          MOV      r8,#0xfffe
000050  2801              CMP      r0,#1                 ;217
000052  d01e              BEQ      |L7.146|
;;;221                    do {
;;;222                        SD_SendCmd(CMD55,0,0X01);	//发送CMD55
;;;223                        r1=SD_SendCmd(CMD41,0x40000000,0X01);//发送CMD41
;;;224                    } while(r1&&retry--);
;;;225                    if(retry&&SD_SendCmd(CMD58,0,0X01)==0) { //鉴别SD2.0卡版本开始
;;;226                        for(i=0; i<4; i++)buf[i]=SD_SPI_ReadWriteByte(0XFF); //得到OCR值
;;;227                        if(buf[0]&0x40)SD_Type=SD_TYPE_V2HC;    //检查CCS
;;;228                        else SD_Type=SD_TYPE_V2;
;;;229                    }
;;;230                }
;;;231            } else { //SD V1.x/ MMC	V3
;;;232                SD_SendCmd(CMD55,0,0X01);		//发送CMD55
000054  2201              MOVS     r2,#1
000056  2100              MOVS     r1,#0
000058  2037              MOVS     r0,#0x37
00005a  f7fffffe          BL       SD_SendCmd
;;;233                r1=SD_SendCmd(CMD41,0,0X01);	//发送CMD41
00005e  2201              MOVS     r2,#1
000060  2100              MOVS     r1,#0
000062  2029              MOVS     r0,#0x29
000064  f7fffffe          BL       SD_SendCmd
;;;234                if(r1<=1) {
000068  2801              CMP      r0,#1
00006a  d84f              BHI      |L7.268|
;;;235                    SD_Type=SD_TYPE_V1;
00006c  2002              MOVS     r0,#2
00006e  7030              STRB     r0,[r6,#0]
;;;236                    retry=0XFFFE;
000070  4644              MOV      r4,r8
                  |L7.114|
;;;237                    do { //等待退出IDLE模式
;;;238                        SD_SendCmd(CMD55,0,0X01);	//发送CMD55
000072  2201              MOVS     r2,#1
000074  2100              MOVS     r1,#0
000076  2037              MOVS     r0,#0x37
000078  f7fffffe          BL       SD_SendCmd
;;;239                        r1=SD_SendCmd(CMD41,0,0X01);//发送CMD41
00007c  2201              MOVS     r2,#1
00007e  2100              MOVS     r1,#0
000080  2029              MOVS     r0,#0x29
000082  f7fffffe          BL       SD_SendCmd
000086  0005              MOVS     r5,r0
;;;240                    } while(r1&&retry--);
000088  d04d              BEQ      |L7.294|
00008a  1e64              SUBS     r4,r4,#1
00008c  b2a4              UXTH     r4,r4
00008e  d2f0              BCS      |L7.114|
000090  e049              B        |L7.294|
                  |L7.146|
000092  2400              MOVS     r4,#0                 ;218
000094  466f              MOV      r7,sp                 ;204
                  |L7.150|
000096  20ff              MOVS     r0,#0xff              ;218
000098  f7fffffe          BL       SD_SPI_ReadWriteByte
00009c  5538              STRB     r0,[r7,r4]            ;218
00009e  1c64              ADDS     r4,r4,#1              ;218
0000a0  b2a4              UXTH     r4,r4                 ;218
0000a2  2c04              CMP      r4,#4                 ;218
0000a4  d3f7              BCC      |L7.150|
0000a6  f89d0002          LDRB     r0,[sp,#2]            ;219
0000aa  2801              CMP      r0,#1                 ;219
0000ac  d143              BNE      |L7.310|
0000ae  f89d0003          LDRB     r0,[sp,#3]            ;219
0000b2  28aa              CMP      r0,#0xaa              ;219
0000b4  d13f              BNE      |L7.310|
0000b6  4644              MOV      r4,r8                 ;220
0000b8  f04f4880          MOV      r8,#0x40000000        ;223
                  |L7.188|
0000bc  2201              MOVS     r2,#1                 ;222
0000be  2100              MOVS     r1,#0                 ;222
0000c0  2037              MOVS     r0,#0x37              ;222
0000c2  f7fffffe          BL       SD_SendCmd
0000c6  2201              MOVS     r2,#1                 ;223
0000c8  4641              MOV      r1,r8                 ;223
0000ca  2029              MOVS     r0,#0x29              ;223
0000cc  f7fffffe          BL       SD_SendCmd
0000d0  0005              MOVS     r5,r0                 ;223
0000d2  d002              BEQ      |L7.218|
0000d4  1e64              SUBS     r4,r4,#1              ;224
0000d6  b2a4              UXTH     r4,r4                 ;224
0000d8  d2f0              BCS      |L7.188|
                  |L7.218|
0000da  b1b4              CBZ      r4,|L7.266|
0000dc  2201              MOVS     r2,#1                 ;225
0000de  2100              MOVS     r1,#0                 ;225
0000e0  203a              MOVS     r0,#0x3a              ;225
0000e2  f7fffffe          BL       SD_SendCmd
0000e6  b980              CBNZ     r0,|L7.266|
0000e8  2400              MOVS     r4,#0                 ;226
                  |L7.234|
0000ea  20ff              MOVS     r0,#0xff              ;226
0000ec  f7fffffe          BL       SD_SPI_ReadWriteByte
0000f0  5538              STRB     r0,[r7,r4]            ;226
0000f2  1c64              ADDS     r4,r4,#1              ;226
0000f4  b2a4              UXTH     r4,r4                 ;226
0000f6  2c04              CMP      r4,#4                 ;226
0000f8  d3f7              BCC      |L7.234|
0000fa  f89d0000          LDRB     r0,[sp,#0]            ;227
0000fe  0640              LSLS     r0,r0,#25             ;227
000100  d501              BPL      |L7.262|
000102  2006              MOVS     r0,#6                 ;227
000104  e000              B        |L7.264|
                  |L7.262|
000106  2004              MOVS     r0,#4                 ;228
                  |L7.264|
000108  7030              STRB     r0,[r6,#0]            ;228
                  |L7.266|
00010a  e014              B        |L7.310|
                  |L7.268|
;;;241                } else {
;;;242                    SD_Type=SD_TYPE_MMC;//MMC V3
00010c  2001              MOVS     r0,#1
00010e  7030              STRB     r0,[r6,#0]
;;;243                    retry=0XFFFE;
000110  4644              MOV      r4,r8
                  |L7.274|
;;;244                    do { //等待退出IDLE模式
;;;245                        r1=SD_SendCmd(CMD1,0,0X01);//发送CMD1
000112  2201              MOVS     r2,#1
000114  2100              MOVS     r1,#0
000116  4610              MOV      r0,r2
000118  f7fffffe          BL       SD_SendCmd
00011c  0005              MOVS     r5,r0
;;;246                    } while(r1&&retry--);
00011e  d002              BEQ      |L7.294|
000120  1e64              SUBS     r4,r4,#1
000122  b2a4              UXTH     r4,r4
000124  d2f5              BCS      |L7.274|
                  |L7.294|
;;;247                }
;;;248                if(retry==0||SD_SendCmd(CMD16,512,0X01)!=0)SD_Type=SD_TYPE_ERR;//错误的卡
000126  b12c              CBZ      r4,|L7.308|
000128  2201              MOVS     r2,#1
00012a  0251              LSLS     r1,r2,#9
00012c  2010              MOVS     r0,#0x10
00012e  f7fffffe          BL       SD_SendCmd
000132  b100              CBZ      r0,|L7.310|
                  |L7.308|
000134  7037              STRB     r7,[r6,#0]
                  |L7.310|
;;;249            }
;;;250        }
;;;251        SD_DisSelect();//取消片选
000136  f7fffffe          BL       SD_DisSelect
00013a  2000              MOVS     r0,#0
00013c  f7fffffe          BL       SPIx_SetSpeed
;;;252        SD_SPI_SpeedHigh();//高速
;;;253        if(SD_Type)return 0;
000140  7830              LDRB     r0,[r6,#0]  ; SD_Type
000142  b110              CBZ      r0,|L7.330|
000144  2000              MOVS     r0,#0
                  |L7.326|
;;;254        else if(r1)return r1;
;;;255        return 0xaa;//其他错误
;;;256    }
000146  e8bd83f8          POP      {r3-r9,pc}
                  |L7.330|
00014a  b10d              CBZ      r5,|L7.336|
00014c  4628              MOV      r0,r5                 ;254
00014e  e7fa              B        |L7.326|
                  |L7.336|
000150  20aa              MOVS     r0,#0xaa              ;255
000152  e7f8              B        |L7.326|
;;;257    
                          ENDP

                  |L7.340|
                          DCD      ||.data||

                          AREA ||i.SD_ReadDisk||, CODE, READONLY, ALIGN=2

                  SD_ReadDisk PROC
;;;262    //返回值:0,ok;其他,失败.
;;;263    u8 SD_ReadDisk(u8*buf,u32 sector,u8 cnt) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
;;;264        u8 r1;
;;;265        if(SD_Type!=SD_TYPE_V2HC)sector <<= 9;//转换为字节地址
000006  4818              LDR      r0,|L8.104|
000008  4615              MOV      r5,r2                 ;263
00000a  7800              LDRB     r0,[r0,#0]  ; SD_Type
00000c  2806              CMP      r0,#6
00000e  d000              BEQ      |L8.18|
000010  0249              LSLS     r1,r1,#9
                  |L8.18|
;;;266        if(cnt==1) {
;;;267            r1=SD_SendCmd(CMD17,sector,0X01);//读命令
;;;268            if(r1==0) { //指令发送成功
;;;269                r1=SD_RecvData(buf,512);//接收512个字节
000012  f44f7700          MOV      r7,#0x200
000016  2d01              CMP      r5,#1                 ;266
;;;270            }
;;;271        } else {
;;;272            r1=SD_SendCmd(CMD18,sector,0X01);//连续读命令
000018  f04f0201          MOV      r2,#1
00001c  d019              BEQ      |L8.82|
00001e  2012              MOVS     r0,#0x12
000020  f7fffffe          BL       SD_SendCmd
                  |L8.36|
;;;273            do {
;;;274                r1=SD_RecvData(buf,512);//接收512个字节
000024  4639              MOV      r1,r7
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       SD_RecvData
00002c  1e6d              SUBS     r5,r5,#1
00002e  4604              MOV      r4,r0
000030  f5067600          ADD      r6,r6,#0x200
;;;275                buf+=512;
;;;276            } while(--cnt && r1==0);
000034  f01505ff          ANDS     r5,r5,#0xff
000038  d001              BEQ      |L8.62|
00003a  2c00              CMP      r4,#0
00003c  d0f2              BEQ      |L8.36|
                  |L8.62|
;;;277            SD_SendCmd(CMD12,0,0X01);	//发送停止命令
00003e  2201              MOVS     r2,#1
000040  2100              MOVS     r1,#0
000042  200c              MOVS     r0,#0xc
000044  f7fffffe          BL       SD_SendCmd
                  |L8.72|
;;;278        }
;;;279        SD_DisSelect();//取消片选
000048  f7fffffe          BL       SD_DisSelect
;;;280        return r1;//
00004c  4620              MOV      r0,r4
;;;281    }
00004e  e8bd81f0          POP      {r4-r8,pc}
                  |L8.82|
000052  2011              MOVS     r0,#0x11              ;267
000054  f7fffffe          BL       SD_SendCmd
000058  0004              MOVS     r4,r0                 ;267
00005a  d1f5              BNE      |L8.72|
00005c  4639              MOV      r1,r7                 ;269
00005e  4630              MOV      r0,r6                 ;269
000060  f7fffffe          BL       SD_RecvData
000064  4604              MOV      r4,r0                 ;269
000066  e7ef              B        |L8.72|
;;;282    //写SD卡
                          ENDP

                  |L8.104|
                          DCD      ||.data||

                          AREA ||i.SD_RecvData||, CODE, READONLY, ALIGN=1

                  SD_RecvData PROC
;;;74     //返回值:0,成功;其他,失败;
;;;75     u8 SD_RecvData(u8*buf,u16 len) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;76         if(SD_GetResponse(0xFE))return 1;//等待SD卡发回数据起始令牌0xFE
000006  20fe              MOVS     r0,#0xfe
000008  f7fffffe          BL       SD_GetResponse
00000c  b128              CBZ      r0,|L9.26|
00000e  2001              MOVS     r0,#1
;;;77         while(len--) { //开始接收数据
;;;78             *buf=SPIx_ReadWriteByte(0xFF);
;;;79             buf++;
;;;80         }
;;;81         //下面是2个伪CRC（dummy CRC）
;;;82         SD_SPI_ReadWriteByte(0xFF);
;;;83         SD_SPI_ReadWriteByte(0xFF);
;;;84         return 0;//读取成功
;;;85     }
000010  bd70              POP      {r4-r6,pc}
                  |L9.18|
000012  f7fffffe          BL       SPIx_ReadWriteByte
000016  f8040b01          STRB     r0,[r4],#1            ;78
                  |L9.26|
00001a  1e6d              SUBS     r5,r5,#1              ;77
00001c  b2ad              UXTH     r5,r5                 ;77
00001e  f04f00ff          MOV      r0,#0xff              ;82
000022  d2f6              BCS      |L9.18|
000024  f7fffffe          BL       SPIx_ReadWriteByte
000028  20ff              MOVS     r0,#0xff              ;83
00002a  f7fffffe          BL       SPIx_ReadWriteByte
00002e  2000              MOVS     r0,#0                 ;84
000030  bd70              POP      {r4-r6,pc}
;;;86     //向sd卡写入一个数据包的内容 512字节
                          ENDP


                          AREA ||i.SD_SPI_Init||, CODE, READONLY, ALIGN=2

                  SD_SPI_Init PROC
;;;23     //SPI硬件层初始化
;;;24     void SD_SPI_Init(void) {
000000  b538              PUSH     {r3-r5,lr}
;;;25         GPIO_InitTypeDef GPIO_InitStructure;
;;;26         RCC_APB2PeriphClockCmd(	RCC_APB2Periph_GPIOA, ENABLE );
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;27     
;;;28         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4;
00000a  201c              MOVS     r0,#0x1c
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;29         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP ;   //推挽输出
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;30         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
;;;31         GPIO_Init(GPIOA, &GPIO_InitStructure);
000018  4c08              LDR      r4,|L10.60|
00001a  f88d0002          STRB     r0,[sp,#2]            ;30
00001e  4669              MOV      r1,sp
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       GPIO_Init
;;;32         GPIO_SetBits(GPIOA,GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4);
000026  211c              MOVS     r1,#0x1c
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       GPIO_SetBits
;;;33     
;;;34         SPIx_Init();
00002e  f7fffffe          BL       SPIx_Init
;;;35         SD_CS=1;
000032  4903              LDR      r1,|L10.64|
000034  2001              MOVS     r0,#1
000036  f8c1018c          STR      r0,[r1,#0x18c]
;;;36     }
00003a  bd38              POP      {r3-r5,pc}
;;;37     ///////////////////////////////////////////////////////////////////////////////////
                          ENDP

                  |L10.60|
                          DCD      0x40010800
                  |L10.64|
                          DCD      0x42210000

                          AREA ||i.SD_SPI_ReadWriteByte||, CODE, READONLY, ALIGN=1

                  SD_SPI_ReadWriteByte PROC
;;;11     //返回值:读到的数据
;;;12     u8 SD_SPI_ReadWriteByte(u8 data) {
000000  f7ffbffe          B.W      SPIx_ReadWriteByte
;;;13         return SPIx_ReadWriteByte(data);
;;;14     }
;;;15     //SD卡初始化的时候,需要低速
                          ENDP


                          AREA ||i.SD_SPI_SpeedHigh||, CODE, READONLY, ALIGN=1

                  SD_SPI_SpeedHigh PROC
;;;19     //SD卡正常工作的时候,可以高速了
;;;20     void SD_SPI_SpeedHigh(void) {
000000  2000              MOVS     r0,#0
;;;21         SPIx_SetSpeed(SPI_BaudRatePrescaler_2);//设置到高速模式
000002  f7ffbffe          B.W      SPIx_SetSpeed
;;;22     }
;;;23     //SPI硬件层初始化
                          ENDP


                          AREA ||i.SD_SPI_SpeedLow||, CODE, READONLY, ALIGN=1

                  SD_SPI_SpeedLow PROC
;;;15     //SD卡初始化的时候,需要低速
;;;16     void SD_SPI_SpeedLow(void) {
000000  2038              MOVS     r0,#0x38
;;;17         SPIx_SetSpeed(SPI_BaudRatePrescaler_256);//设置到低速模式
000002  f7ffbffe          B.W      SPIx_SetSpeed
;;;18     }
;;;19     //SD卡正常工作的时候,可以高速了
                          ENDP


                          AREA ||i.SD_Select||, CODE, READONLY, ALIGN=2

                  SD_Select PROC
;;;44     //返回值:0,成功;1,失败;
;;;45     u8 SD_Select(void) {
000000  4906              LDR      r1,|L14.28|
000002  b510              PUSH     {r4,lr}
;;;46         SD_CS=0;
000004  2000              MOVS     r0,#0
000006  f8c1018c          STR      r0,[r1,#0x18c]
;;;47         if(SD_WaitReady()==0)return 0;//等待成功
00000a  f7fffffe          BL       SD_WaitReady
00000e  2800              CMP      r0,#0
000010  d002              BEQ      |L14.24|
;;;48         SD_DisSelect();
000012  f7fffffe          BL       SD_DisSelect
;;;49         return 1;//等待失败
000016  2001              MOVS     r0,#1
                  |L14.24|
;;;50     }
000018  bd10              POP      {r4,pc}
;;;51     //等待卡准备好
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x42210000

                          AREA ||i.SD_SendBlock||, CODE, READONLY, ALIGN=1

                  SD_SendBlock PROC
;;;89     //返回值:0,成功;其他,失败;
;;;90     u8 SD_SendBlock(u8*buf,u8 cmd) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;91         u16 t;
;;;92         if(SD_WaitReady())return 1;//等待准备失效
000006  f7fffffe          BL       SD_WaitReady
00000a  b108              CBZ      r0,|L15.16|
00000c  2001              MOVS     r0,#1
;;;93         SD_SPI_ReadWriteByte(cmd);
;;;94         if(cmd!=0XFD) { //不是结束指令
;;;95             for(t=0; t<512; t++)SPIx_ReadWriteByte(buf[t]); //提高速度,减少函数传参时间
;;;96             SD_SPI_ReadWriteByte(0xFF);//忽略crc
;;;97             SD_SPI_ReadWriteByte(0xFF);
;;;98             t=SD_SPI_ReadWriteByte(0xFF);//接收响应
;;;99             if((t&0x1F)!=0x05)return 2;//响应错误
;;;100        }
;;;101        return 0;//写入成功
;;;102    }
00000e  bd70              POP      {r4-r6,pc}
                  |L15.16|
000010  4620              MOV      r0,r4                 ;93
000012  f7fffffe          BL       SPIx_ReadWriteByte
000016  2cfd              CMP      r4,#0xfd              ;94
000018  d018              BEQ      |L15.76|
00001a  2400              MOVS     r4,#0                 ;95
00001c  f44f7600          MOV      r6,#0x200             ;95
                  |L15.32|
000020  5d28              LDRB     r0,[r5,r4]            ;95
000022  f7fffffe          BL       SPIx_ReadWriteByte
000026  1c64              ADDS     r4,r4,#1              ;95
000028  b2a4              UXTH     r4,r4                 ;95
00002a  42b4              CMP      r4,r6                 ;95
00002c  d3f8              BCC      |L15.32|
00002e  20ff              MOVS     r0,#0xff              ;96
000030  f7fffffe          BL       SPIx_ReadWriteByte
000034  20ff              MOVS     r0,#0xff              ;97
000036  f7fffffe          BL       SPIx_ReadWriteByte
00003a  20ff              MOVS     r0,#0xff              ;98
00003c  f7fffffe          BL       SD_SPI_ReadWriteByte
000040  f000001f          AND      r0,r0,#0x1f           ;99
000044  2805              CMP      r0,#5                 ;99
000046  d001              BEQ      |L15.76|
000048  2002              MOVS     r0,#2                 ;99
00004a  bd70              POP      {r4-r6,pc}
                  |L15.76|
00004c  2000              MOVS     r0,#0                 ;101
00004e  bd70              POP      {r4-r6,pc}
;;;103    
                          ENDP


                          AREA ||i.SD_SendCmd||, CODE, READONLY, ALIGN=1

                  SD_SendCmd PROC
;;;108    //返回值:SD卡返回的响应
;;;109    u8 SD_SendCmd(u8 cmd, u32 arg, u8 crc) {
000000  b570              PUSH     {r4-r6,lr}
000002  4616              MOV      r6,r2
000004  460c              MOV      r4,r1
000006  4605              MOV      r5,r0
;;;110        u8 r1;
;;;111        u8 Retry=0;
;;;112        SD_DisSelect();//取消上次片选
000008  f7fffffe          BL       SD_DisSelect
;;;113        if(SD_Select())return 0XFF;//片选失效
00000c  f7fffffe          BL       SD_Select
000010  b108              CBZ      r0,|L16.22|
000012  20ff              MOVS     r0,#0xff
                  |L16.20|
;;;114        //发送
;;;115        SD_SPI_ReadWriteByte(cmd | 0x40);//分别写入命令
;;;116        SD_SPI_ReadWriteByte(arg >> 24);
;;;117        SD_SPI_ReadWriteByte(arg >> 16);
;;;118        SD_SPI_ReadWriteByte(arg >> 8);
;;;119        SD_SPI_ReadWriteByte(arg);
;;;120        SD_SPI_ReadWriteByte(crc);
;;;121        if(cmd==CMD12)SD_SPI_ReadWriteByte(0xff);//Skip a stuff byte when stop reading
;;;122        //等待响应，或超时退出
;;;123        Retry=0X1F;
;;;124        do {
;;;125            r1=SD_SPI_ReadWriteByte(0xFF);
;;;126        } while((r1&0X80) && Retry--);
;;;127        //返回状态值
;;;128        return r1;
;;;129    }
000014  bd70              POP      {r4-r6,pc}
                  |L16.22|
000016  f0450040          ORR      r0,r5,#0x40           ;115
00001a  f7fffffe          BL       SPIx_ReadWriteByte
00001e  0e20              LSRS     r0,r4,#24             ;116
000020  f7fffffe          BL       SPIx_ReadWriteByte
000024  f3c44007          UBFX     r0,r4,#16,#8          ;117
000028  f7fffffe          BL       SPIx_ReadWriteByte
00002c  f3c42007          UBFX     r0,r4,#8,#8           ;118
000030  f7fffffe          BL       SPIx_ReadWriteByte
000034  b2e0              UXTB     r0,r4                 ;119
000036  f7fffffe          BL       SPIx_ReadWriteByte
00003a  4630              MOV      r0,r6                 ;120
00003c  f7fffffe          BL       SPIx_ReadWriteByte
000040  2d0c              CMP      r5,#0xc               ;121
000042  d102              BNE      |L16.74|
000044  20ff              MOVS     r0,#0xff              ;121
000046  f7fffffe          BL       SPIx_ReadWriteByte
                  |L16.74|
00004a  241f              MOVS     r4,#0x1f              ;123
                  |L16.76|
00004c  20ff              MOVS     r0,#0xff              ;125
00004e  f7fffffe          BL       SD_SPI_ReadWriteByte
000052  0601              LSLS     r1,r0,#24             ;126
000054  d5de              BPL      |L16.20|
000056  1e64              SUBS     r4,r4,#1              ;126
000058  b2e4              UXTB     r4,r4                 ;126
00005a  d2f7              BCS      |L16.76|
00005c  bd70              POP      {r4-r6,pc}
;;;130    //获取SD卡的CID信息，包括制造商信息
                          ENDP


                          AREA ||i.SD_WaitReady||, CODE, READONLY, ALIGN=1

                  SD_WaitReady PROC
;;;52     //返回值:0,准备好了;其他,错误代码
;;;53     u8 SD_WaitReady(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;54         u32 t=0;
000002  2400              MOVS     r4,#0
;;;55         do {
;;;56             if(SD_SPI_ReadWriteByte(0XFF)==0XFF)return 0;//OK
;;;57             t++;
;;;58         } while(t<0XFFFFFF);//等待
000004  f06f457f          MVN      r5,#0xff000000
                  |L17.8|
000008  20ff              MOVS     r0,#0xff              ;56
00000a  f7fffffe          BL       SD_SPI_ReadWriteByte
00000e  28ff              CMP      r0,#0xff              ;56
000010  d004              BEQ      |L17.28|
000012  1c64              ADDS     r4,r4,#1              ;56
000014  42ac              CMP      r4,r5
000016  d3f7              BCC      |L17.8|
;;;59         return 1;
000018  2001              MOVS     r0,#1
;;;60     }
00001a  bd70              POP      {r4-r6,pc}
                  |L17.28|
00001c  2000              MOVS     r0,#0                 ;56
00001e  bd70              POP      {r4-r6,pc}
;;;61     //等待SD卡回应
                          ENDP


                          AREA ||i.SD_WriteDisk||, CODE, READONLY, ALIGN=2

                  SD_WriteDisk PROC
;;;286    //返回值:0,ok;其他,失败.
;;;287    u8 SD_WriteDisk(u8*buf,u32 sector,u8 cnt) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
;;;288        u8 r1;
;;;289        if(SD_Type!=SD_TYPE_V2HC)sector *= 512;//转换为字节地址
000004  481d              LDR      r0,|L18.124|
000006  4615              MOV      r5,r2                 ;287
000008  460c              MOV      r4,r1                 ;287
00000a  7800              LDRB     r0,[r0,#0]  ; SD_Type
00000c  2806              CMP      r0,#6
00000e  d000              BEQ      |L18.18|
000010  024c              LSLS     r4,r1,#9
                  |L18.18|
;;;290        if(cnt==1) {
000012  2d01              CMP      r5,#1
000014  d013              BEQ      |L18.62|
;;;291            r1=SD_SendCmd(CMD24,sector,0X01);//读命令
;;;292            if(r1==0) { //指令发送成功
;;;293                r1=SD_SendBlock(buf,0xFE);//写512个字节
;;;294            }
;;;295        } else {
;;;296            if(SD_Type!=SD_TYPE_MMC) {
000016  2801              CMP      r0,#1
000018  d009              BEQ      |L18.46|
;;;297                SD_SendCmd(CMD55,0,0X01);
00001a  2201              MOVS     r2,#1
00001c  2100              MOVS     r1,#0
00001e  2037              MOVS     r0,#0x37
000020  f7fffffe          BL       SD_SendCmd
;;;298                SD_SendCmd(CMD23,cnt,0X01);//发送指令
000024  2201              MOVS     r2,#1
000026  4629              MOV      r1,r5
000028  2017              MOVS     r0,#0x17
00002a  f7fffffe          BL       SD_SendCmd
                  |L18.46|
;;;299            }
;;;300            r1=SD_SendCmd(CMD25,sector,0X01);//连续读命令
00002e  2201              MOVS     r2,#1
000030  4621              MOV      r1,r4
000032  2019              MOVS     r0,#0x19
000034  f7fffffe          BL       SD_SendCmd
000038  0004              MOVS     r4,r0
;;;301            if(r1==0) {
00003a  d00a              BEQ      |L18.82|
00003c  e01a              B        |L18.116|
                  |L18.62|
00003e  2201              MOVS     r2,#1                 ;291
000040  4621              MOV      r1,r4                 ;291
000042  2018              MOVS     r0,#0x18              ;291
000044  f7fffffe          BL       SD_SendCmd
000048  0004              MOVS     r4,r0                 ;291
00004a  d113              BNE      |L18.116|
00004c  21fe              MOVS     r1,#0xfe              ;293
00004e  4630              MOV      r0,r6                 ;293
000050  e00d              B        |L18.110|
                  |L18.82|
;;;302                do {
;;;303                    r1=SD_SendBlock(buf,0xFC);//接收512个字节
000052  21fc              MOVS     r1,#0xfc
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       SD_SendBlock
00005a  1e6d              SUBS     r5,r5,#1
00005c  f5067600          ADD      r6,r6,#0x200
;;;304                    buf+=512;
;;;305                } while(--cnt && r1==0);
000060  f01505ff          ANDS     r5,r5,#0xff
000064  d001              BEQ      |L18.106|
000066  2800              CMP      r0,#0
000068  d0f3              BEQ      |L18.82|
                  |L18.106|
;;;306                r1=SD_SendBlock(0,0xFD);//接收512个字节
00006a  21fd              MOVS     r1,#0xfd
00006c  2000              MOVS     r0,#0
                  |L18.110|
00006e  f7fffffe          BL       SD_SendBlock
000072  4604              MOV      r4,r0
                  |L18.116|
;;;307            }
;;;308        }
;;;309        SD_DisSelect();//取消片选
000074  f7fffffe          BL       SD_DisSelect
;;;310        return r1;//
000078  4620              MOV      r0,r4
;;;311    }
00007a  bd70              POP      {r4-r6,pc}
;;;312    
                          ENDP

                  |L18.124|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=0

                  SD_Type
000000  00                DCB      0x00
