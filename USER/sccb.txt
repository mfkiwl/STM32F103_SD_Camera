; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\sccb.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\sccb.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\HARDWARE\LED -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\STM32F10x_FWLib\inc -I..\CORE -I..\HARDWARE\SPI -I..\HARDWARE\MMC_SD -I..\HARDWARE\SPI -I..\HARDWARE\LED -I..\HARDWARE\WNOTEPAD -I..\HARDWARE\RTC -I..\FATFS -I..\FATFS\option -I..\HARDWARE\USART3 -I..\APPS -I..\HARDWARE\OV2640 -I..\HARDWARE\24LC1024 -I..\HARDWARE\RAM -I.\RTE\_Target_1 -ID:\EmbeddedTools\MDK51_RAM\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\EmbeddedTools\MDK51_RAM\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\sccb.crf ..\HARDWARE\OV2640\sccb.c]
                          THUMB

                          AREA ||i.SCCB_Init||, CODE, READONLY, ALIGN=2

                  SCCB_Init PROC
;;;7      //CHECK OK
;;;8      void SCCB_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;9      {
;;;10         GPIO_InitTypeDef  GPIO_InitStructure;
;;;11     
;;;12         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	 //使能PD,PG端口时钟
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;13         //PG13 替换为PA12  PD3替换为PA11
;;;14         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;				 // 端口配置
00000a  f44f6400          MOV      r4,#0x800
00000e  f8ad4000          STRH     r4,[sp,#0]
;;;15         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //输入
000012  2010              MOVS     r0,#0x10
000014  f88d0003          STRB     r0,[sp,#3]
;;;16         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
;;;17         GPIO_Init(GPIOA, &GPIO_InitStructure);
00001a  4d11              LDR      r5,|L1.96|
00001c  f88d0002          STRB     r0,[sp,#2]            ;16
000020  4669              MOV      r1,sp
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       GPIO_Init
;;;18         GPIO_SetBits(GPIOA,GPIO_Pin_11);						 // 输出高
000028  4621              MOV      r1,r4
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       GPIO_SetBits
;;;19     
;;;20         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;				 // 端口配置
000030  0064              LSLS     r4,r4,#1
000032  f8ad4000          STRH     r4,[sp,#0]
;;;21         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; 		 //输输出
000036  2248              MOVS     r2,#0x48
000038  f88d2003          STRB     r2,[sp,#3]
;;;22         GPIO_Init(GPIOA, &GPIO_InitStructure);
00003c  4669              MOV      r1,sp
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       GPIO_Init
;;;23         GPIO_SetBits(GPIOA,GPIO_Pin_12);						 // 输出高
000044  4621              MOV      r1,r4
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       GPIO_SetBits
;;;24     
;;;25         SCCB_SDA_OUT();
00004c  1d28              ADDS     r0,r5,#4
00004e  6801              LDR      r1,[r0,#0]
000050  f4212170          BIC      r1,r1,#0xf0000
000054  6001              STR      r1,[r0,#0]
000056  6801              LDR      r1,[r0,#0]
000058  f4413140          ORR      r1,r1,#0x30000
00005c  6001              STR      r1,[r0,#0]
;;;26     }
00005e  bd38              POP      {r3-r5,pc}
;;;27     
                          ENDP

                  |L1.96|
                          DCD      0x40010800

                          AREA ||i.SCCB_No_Ack||, CODE, READONLY, ALIGN=2

                  SCCB_No_Ack PROC
;;;53     //产生NA信号
;;;54     void SCCB_No_Ack(void)
000000  b570              PUSH     {r4-r6,lr}
;;;55     {
;;;56         delay_us(50);
000002  2032              MOVS     r0,#0x32
000004  f7fffffe          BL       delay_us
;;;57         SCCB_SDA=1;
000008  4c0a              LDR      r4,|L2.52|
00000a  2001              MOVS     r0,#1
00000c  f8c401b0          STR      r0,[r4,#0x1b0]
;;;58         SCCB_SCL=1;
000010  f8c401ac          STR      r0,[r4,#0x1ac]
;;;59         delay_us(50);
000014  2032              MOVS     r0,#0x32
000016  f50474d6          ADD      r4,r4,#0x1ac
00001a  f7fffffe          BL       delay_us
;;;60         SCCB_SCL=0;
00001e  2500              MOVS     r5,#0
000020  6025              STR      r5,[r4,#0]
;;;61         delay_us(50);
000022  2032              MOVS     r0,#0x32
000024  f7fffffe          BL       delay_us
;;;62         SCCB_SDA=0;
000028  6065              STR      r5,[r4,#4]
;;;63         delay_us(50);
00002a  e8bd4070          POP      {r4-r6,lr}
00002e  2032              MOVS     r0,#0x32
000030  f7ffbffe          B.W      delay_us
;;;64     }
;;;65     //SCCB,写入一个字节
                          ENDP

                  |L2.52|
                          DCD      0x42210000

                          AREA ||i.SCCB_RD_Byte||, CODE, READONLY, ALIGN=2

                  SCCB_RD_Byte PROC
;;;91     //返回值:读到的数据
;;;92     u8 SCCB_RD_Byte(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;93     {
;;;94         u8 temp=0,j;
;;;95         SCCB_SDA_IN();		//设置SDA为输入
000004  4f17              LDR      r7,|L3.100|
000006  2400              MOVS     r4,#0                 ;94
000008  6838              LDR      r0,[r7,#0]
00000a  f4202070          BIC      r0,r0,#0xf0000
00000e  6038              STR      r0,[r7,#0]
000010  6838              LDR      r0,[r7,#0]
000012  f4402000          ORR      r0,r0,#0x80000
000016  6038              STR      r0,[r7,#0]
;;;96         for(j=8; j>0; j--) {	//循环8次接收数据
;;;97             delay_us(50);
;;;98             SCCB_SCL=1;
000018  4e13              LDR      r6,|L3.104|
00001a  2508              MOVS     r5,#8                 ;96
00001c  f04f0801          MOV      r8,#1
000020  46a1              MOV      r9,r4
                  |L3.34|
000022  2032              MOVS     r0,#0x32              ;97
000024  f7fffffe          BL       delay_us
000028  f8c681ac          STR      r8,[r6,#0x1ac]
;;;99             temp=temp<<1;
00002c  0660              LSLS     r0,r4,#25
00002e  0e04              LSRS     r4,r0,#24
;;;100            if(SCCB_READ_SDA)temp++;
000030  f8d60130          LDR      r0,[r6,#0x130]
000034  b108              CBZ      r0,|L3.58|
000036  1c64              ADDS     r4,r4,#1
000038  b2e4              UXTB     r4,r4
                  |L3.58|
;;;101            delay_us(50);
00003a  2032              MOVS     r0,#0x32
00003c  f7fffffe          BL       delay_us
;;;102            SCCB_SCL=0;
000040  f8c691ac          STR      r9,[r6,#0x1ac]
000044  1e6d              SUBS     r5,r5,#1
000046  f01505ff          ANDS     r5,r5,#0xff           ;96
00004a  d1ea              BNE      |L3.34|
;;;103        }
;;;104        SCCB_SDA_OUT();		//设置SDA为输出
00004c  6838              LDR      r0,[r7,#0]
00004e  f4202070          BIC      r0,r0,#0xf0000
000052  6038              STR      r0,[r7,#0]
000054  6838              LDR      r0,[r7,#0]
000056  f4403040          ORR      r0,r0,#0x30000
00005a  6038              STR      r0,[r7,#0]
;;;105        return temp;
00005c  4620              MOV      r0,r4
;;;106    }
00005e  e8bd87f0          POP      {r4-r10,pc}
;;;107    //写寄存器
                          ENDP

000062  0000              DCW      0x0000
                  |L3.100|
                          DCD      0x40010804
                  |L3.104|
                          DCD      0x42210000

                          AREA ||i.SCCB_RD_Reg||, CODE, READONLY, ALIGN=1

                  SCCB_RD_Reg PROC
;;;122    //返回值:读到的寄存器值
;;;123    u8 SCCB_RD_Reg(u8 reg)
000000  b510              PUSH     {r4,lr}
;;;124    {
000002  4604              MOV      r4,r0
;;;125        u8 val=0;
;;;126        SCCB_Start(); 				//启动SCCB传输
000004  f7fffffe          BL       SCCB_Start
;;;127        SCCB_WR_Byte(SCCB_ID);		//写器件ID
000008  2060              MOVS     r0,#0x60
00000a  f7fffffe          BL       SCCB_WR_Byte
;;;128        delay_us(100);
00000e  2064              MOVS     r0,#0x64
000010  f7fffffe          BL       delay_us
;;;129        SCCB_WR_Byte(reg);			//写寄存器地址
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SCCB_WR_Byte
;;;130        delay_us(100);
00001a  2064              MOVS     r0,#0x64
00001c  f7fffffe          BL       delay_us
;;;131        SCCB_Stop();
000020  f7fffffe          BL       SCCB_Stop
;;;132        delay_us(100);
000024  2064              MOVS     r0,#0x64
000026  f7fffffe          BL       delay_us
;;;133        //设置寄存器地址后，才是读
;;;134        SCCB_Start();
00002a  f7fffffe          BL       SCCB_Start
;;;135        SCCB_WR_Byte(SCCB_ID|0X01);	//发送读命令
00002e  2061              MOVS     r0,#0x61
000030  f7fffffe          BL       SCCB_WR_Byte
;;;136        delay_us(100);
000034  2064              MOVS     r0,#0x64
000036  f7fffffe          BL       delay_us
;;;137        val=SCCB_RD_Byte();		 	//读取数据
00003a  f7fffffe          BL       SCCB_RD_Byte
00003e  4604              MOV      r4,r0
;;;138        SCCB_No_Ack();
000040  f7fffffe          BL       SCCB_No_Ack
;;;139        SCCB_Stop();
000044  f7fffffe          BL       SCCB_Stop
;;;140        return val;
000048  4620              MOV      r0,r4
;;;141    }
00004a  bd10              POP      {r4,pc}
;;;142    
                          ENDP


                          AREA ||i.SCCB_Start||, CODE, READONLY, ALIGN=2

                  SCCB_Start PROC
;;;30     //在激活状态下,SDA和SCL均为低电平
;;;31     void SCCB_Start(void)
000000  b570              PUSH     {r4-r6,lr}
;;;32     {
;;;33         SCCB_SDA=1;     //数据线高电平
000002  4c09              LDR      r4,|L5.40|
000004  2001              MOVS     r0,#1
000006  f8c401b0          STR      r0,[r4,#0x1b0]
;;;34         SCCB_SCL=1;	    //在时钟线高的时候数据线由高至低
00000a  f8c401ac          STR      r0,[r4,#0x1ac]
;;;35         delay_us(50);
00000e  2032              MOVS     r0,#0x32
000010  f50474d6          ADD      r4,r4,#0x1ac
000014  f7fffffe          BL       delay_us
;;;36         SCCB_SDA=0;
000018  2500              MOVS     r5,#0
00001a  6065              STR      r5,[r4,#4]
;;;37         delay_us(50);
00001c  2032              MOVS     r0,#0x32
00001e  f7fffffe          BL       delay_us
;;;38         SCCB_SCL=0;	    //数据线恢复低电平，单操作函数必要
000022  6025              STR      r5,[r4,#0]
;;;39     }
000024  bd70              POP      {r4-r6,pc}
;;;40     
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x42210000

                          AREA ||i.SCCB_Stop||, CODE, READONLY, ALIGN=2

                  SCCB_Stop PROC
;;;43     //空闲状况下,SDA,SCL均为高电平
;;;44     void SCCB_Stop(void)
000000  b570              PUSH     {r4-r6,lr}
;;;45     {
;;;46         SCCB_SDA=0;
000002  4c0a              LDR      r4,|L6.44|
000004  2000              MOVS     r0,#0
000006  f8c401b0          STR      r0,[r4,#0x1b0]
;;;47         delay_us(50);
00000a  2032              MOVS     r0,#0x32
00000c  f50474d6          ADD      r4,r4,#0x1ac
000010  f7fffffe          BL       delay_us
;;;48         SCCB_SCL=1;
000014  2501              MOVS     r5,#1
000016  6025              STR      r5,[r4,#0]
;;;49         delay_us(50);
000018  2032              MOVS     r0,#0x32
00001a  f7fffffe          BL       delay_us
;;;50         SCCB_SDA=1;
00001e  6065              STR      r5,[r4,#4]
;;;51         delay_us(50);
000020  e8bd4070          POP      {r4-r6,lr}
000024  2032              MOVS     r0,#0x32
000026  f7ffbffe          B.W      delay_us
;;;52     }
;;;53     //产生NA信号
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x42210000

                          AREA ||i.SCCB_WR_Byte||, CODE, READONLY, ALIGN=2

                  SCCB_WR_Byte PROC
;;;66     //返回值:0,成功;1,失败.
;;;67     u8 SCCB_WR_Byte(u8 dat)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;68     {
;;;69         u8 j,res;
;;;70         for(j=0; j<8; j++) { //循环8次发送数据
000004  2400              MOVS     r4,#0
;;;71             if(dat&0x80)SCCB_SDA=1;
000006  4e1e              LDR      r6,|L7.128|
000008  4605              MOV      r5,r0                 ;68
00000a  46a0              MOV      r8,r4                 ;70
00000c  2701              MOVS     r7,#1
                  |L7.14|
00000e  0628              LSLS     r0,r5,#24
000010  d502              BPL      |L7.24|
000012  f8c671b0          STR      r7,[r6,#0x1b0]
000016  e001              B        |L7.28|
                  |L7.24|
;;;72             else SCCB_SDA=0;
000018  f8c681b0          STR      r8,[r6,#0x1b0]
                  |L7.28|
;;;73             dat<<=1;
00001c  0668              LSLS     r0,r5,#25
00001e  0e05              LSRS     r5,r0,#24
;;;74             delay_us(50);
000020  2032              MOVS     r0,#0x32
000022  f7fffffe          BL       delay_us
;;;75             SCCB_SCL=1;
000026  f8c671ac          STR      r7,[r6,#0x1ac]
;;;76             delay_us(50);
00002a  2032              MOVS     r0,#0x32
00002c  f7fffffe          BL       delay_us
;;;77             SCCB_SCL=0;
000030  f8c681ac          STR      r8,[r6,#0x1ac]
000034  1c64              ADDS     r4,r4,#1
000036  b2e4              UXTB     r4,r4                 ;70
000038  2c08              CMP      r4,#8                 ;70
00003a  d3e8              BCC      |L7.14|
;;;78         }
;;;79         SCCB_SDA_IN();		//设置SDA为输入
00003c  4c11              LDR      r4,|L7.132|
00003e  6820              LDR      r0,[r4,#0]
000040  f4202070          BIC      r0,r0,#0xf0000
000044  6020              STR      r0,[r4,#0]
000046  6820              LDR      r0,[r4,#0]
000048  f4402000          ORR      r0,r0,#0x80000
00004c  6020              STR      r0,[r4,#0]
;;;80         delay_us(50);
00004e  2032              MOVS     r0,#0x32
000050  f7fffffe          BL       delay_us
;;;81         SCCB_SCL=1;			//接收第九位,以判断是否发送成功
000054  f8c671ac          STR      r7,[r6,#0x1ac]
;;;82         delay_us(50);
000058  2032              MOVS     r0,#0x32
00005a  f7fffffe          BL       delay_us
;;;83         if(SCCB_READ_SDA)res=1;  //SDA=1发送失败，返回1
00005e  f8d60130          LDR      r0,[r6,#0x130]
000062  b100              CBZ      r0,|L7.102|
000064  2001              MOVS     r0,#1
                  |L7.102|
;;;84         else res=0;         //SDA=0发送成功，返回0
;;;85         SCCB_SCL=0;
000066  f8c681ac          STR      r8,[r6,#0x1ac]
;;;86         SCCB_SDA_OUT();		//设置SDA为输出
00006a  6821              LDR      r1,[r4,#0]
00006c  f4212170          BIC      r1,r1,#0xf0000
000070  6021              STR      r1,[r4,#0]
000072  6821              LDR      r1,[r4,#0]
000074  f4413140          ORR      r1,r1,#0x30000
000078  6021              STR      r1,[r4,#0]
;;;87         return res;
;;;88     }
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;89     //SCCB 读取一个字节
                          ENDP

00007e  0000              DCW      0x0000
                  |L7.128|
                          DCD      0x42210000
                  |L7.132|
                          DCD      0x40010804

                          AREA ||i.SCCB_WR_Reg||, CODE, READONLY, ALIGN=1

                  SCCB_WR_Reg PROC
;;;108    //返回值:0,成功;1,失败.
;;;109    u8 SCCB_WR_Reg(u8 reg,u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;110    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;111        u8 res=0;
000006  2400              MOVS     r4,#0
;;;112        SCCB_Start(); 					//启动SCCB传输
000008  f7fffffe          BL       SCCB_Start
;;;113        if(SCCB_WR_Byte(SCCB_ID))res=1;	//写器件ID
00000c  2060              MOVS     r0,#0x60
00000e  f7fffffe          BL       SCCB_WR_Byte
000012  b100              CBZ      r0,|L8.22|
000014  2401              MOVS     r4,#1
                  |L8.22|
;;;114        delay_us(100);
000016  2064              MOVS     r0,#0x64
000018  f7fffffe          BL       delay_us
;;;115        if(SCCB_WR_Byte(reg))res=1;		//写寄存器地址
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       SCCB_WR_Byte
000022  b100              CBZ      r0,|L8.38|
000024  2401              MOVS     r4,#1
                  |L8.38|
;;;116        delay_us(100);
000026  2064              MOVS     r0,#0x64
000028  f7fffffe          BL       delay_us
;;;117        if(SCCB_WR_Byte(data))res=1; 	//写数据
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SCCB_WR_Byte
000032  b100              CBZ      r0,|L8.54|
000034  2401              MOVS     r4,#1
                  |L8.54|
;;;118        SCCB_Stop();
000036  f7fffffe          BL       SCCB_Stop
;;;119        return	res;
00003a  4620              MOV      r0,r4
;;;120    }
00003c  bd70              POP      {r4-r6,pc}
;;;121    //读寄存器
                          ENDP

